<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haohao Notes</title>
  
  <subtitle>DREAM OF TECHNICAL ACHIEVEMENT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huixing.org/"/>
  <updated>2021-10-13T08:47:25.455Z</updated>
  <id>http://blog.huixing.org/</id>
  
  <author>
    <name>Tan Hao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>音视频开发基础概念</title>
    <link href="http://blog.huixing.org/audio-and-video-development-concept/"/>
    <id>http://blog.huixing.org/audio-and-video-development-concept/</id>
    <published>2021-10-13T07:01:41.000Z</published>
    <updated>2021-10-13T08:47:25.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是声音"><a href="#什么是声音" class="headerlink" title="什么是声音"></a>什么是声音</h2><h3 id="声音是波"><a href="#声音是波" class="headerlink" title="声音是波"></a>声音是波</h3><p>说到声音，爱好音乐的人首先可能会想到优美的音乐或者是劲爆十足的舞曲，这些音乐只是声音的一种。音乐是由乐器弹奏或者歌手演唱而产生的，那么声音是如何产生的呢?回想一下中学物理课本上的定义 </p><p>– 声音是由物体振动而产生的</p><p><img src="https://tva1.sinaimg.cn/large/003088Elly1gvdp7mzv0fj60hs0ewq3u02.jpg" alt="震动是声音的产生原因"></p><p>当小球撞击到音叉的时候，音叉会发生振动，对周围的空气产生挤压，从而产生声音。声音是一种压力波，当演奏乐器、拍打一扇门或者敲击桌面时，它们的振动都会引起空气有节奏的振动，使周围的空气产生疏密变化，形成疏密相间的纵波(可以理解为石头落入水中激起的波纹)，由此就产生了声波，这种现象会一直延续到振动消失为止。</p><h3 id="声波的三要素"><a href="#声波的三要素" class="headerlink" title="声波的三要素"></a>声波的三要素</h3><p>声波的三要素是频率、振幅和波形，频率代表音阶的高低，振幅代表响度，波形代表音色。</p><p>频率(过零率)越高，波长就越短。低频声响的波长则较长，所以其可 以更容易地绕过障碍物，因此能量衰减就小，声音就会传得远，反之则会 得到完全相反的结论。</p><p>响度其实就是能量大小的反映，用不同的力度敲击桌子，声音的大 小势必也会不同。在生活中，分贝常用于描述响度的大小。声音超过一定 的分贝，人类的耳朵就会受不了。</p><p>音色其实也不难理解，在同样的音调(频率)和响度(振幅)下，钢琴 和小提琴的声音听起来是完全不相同的，因为它们的音色不同。波的形 状决定了其所代表声音的音色，钢琴和小提琴的音色不同就是因为它们 的介质所产生的波形不同。</p><p>人类耳朵的听力有一个频率范围，大约是20Hz~20kHz，不过，即使 是在这个频率范围内，不同的频率，听力的感觉也会不一样，业界非常著 名的等响曲线，就是用来描述等响条件下声压级与声波频率关系的。</p><p><img src="https://tva1.sinaimg.cn/large/003088Elly1gvdq207goej60nj0jj79102.jpg" alt="等响曲线"></p><p>从图中可以看出，人耳对3~4kHz频率范围内的声音比较敏感，而对于较低或较高频率的声音，敏感度就会有所减弱;在声压级较低时，听觉的频率特性会很不均匀;而在声压级较高时，听觉的频率特性会变得较为均匀。频率范围较宽的音乐，其声压以80~90dB为最佳，超过90dB 将会损害人耳(105dB为人耳极限)。</p><h3 id="声音的传播介质"><a href="#声音的传播介质" class="headerlink" title="声音的传播介质"></a>声音的传播介质</h3><p>吉他是通过演奏者拨动琴弦来发出声音的，鼓是通过鼓槌敲击鼓面发出声音的，这些声音的产生都离不开振动，就连我们说话也是因为声带振动而产生声音的。</p><p>既然都是振动产生的声音，那为什么吉他、鼓和人声听起来相差这么大呢?</p><p>这是因为介质不同。</p><p>我们的声带振动发出声音之后，经过口腔、颅腔等局部区域的反射，再经过空气传播到别人的耳朵里，这就是我们说的话被别人听到的过程，其中包括了最初的发声介质与颅腔、口腔，还有中间的传播介质等。</p><p>事实上，声音的传播介质很广，它可以通过空气、液体和固体进行传播;</p><p>而且介质不同，传播的速度也不同，比如，声音在空气中的传播速度为340m/s，在蒸馏水中的传播速度为 1497m/s，而在铁棒中的传播速度则可以高达5200m/s;不过，声音在真空中是无法传播的。</p><h3 id="回声"><a href="#回声" class="headerlink" title="回声"></a>回声</h3><p>当我们在高山或空旷地带高声大喊的时候，经常会听到回声(echo)。之所以会有回声是因为声音在传播过程中遇到障碍物会反弹回来，再次被我们听到。</p><p><img src="https://tva1.sinaimg.cn/large/003088Elly1gvdq3jkbjmj60np09q0tv02.jpg" alt="回声"></p><p>但是，若两种声音传到我们的耳朵里的时差小于80毫秒，我们就无法区分开这两种声音了，其实在日常生活中，人耳也在收集回声，只不过由于嘈杂的外界环境以及回声的分贝(衡量声音能量值大小的单位)比较低，所以我们的耳朵分辨不出这样的声音，或者说是大脑能接收到但分辨不出。</p><p>注意：当原声与回声时间间隔大于0.1秒，能被人耳分辨出，叫做回声；当小于0.1秒，则为混响（混响使音量增大，所以音箱的原理就是混响）。</p><h3 id="共鸣"><a href="#共鸣" class="headerlink" title="共鸣"></a>共鸣</h3><p>自然界中有光能、水能，生活中有机械能、电能，其实声音也可以产生能量，例如两个频率相同的物体，敲击其中一个物体时另一个物体也会振动发声程。</p><p>这种现象称为共鸣，共鸣证明了声音传播可以带动另一个物体振动，也就是说，声音的传播过程也是一种能量的传播过程。<br><img src="https://tva1.sinaimg.cn/large/003088Elly1gvdq4ec4l1j60fc0bv0ut02.jpg" alt="共鸣"></p><h2 id="数字音频"><a href="#数字音频" class="headerlink" title="数字音频"></a>数字音频</h2><p>数字音频也就是将模拟信号数字化,分别是采样、量化和编码。</p><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><p>首先要对模拟信号进行采样，所谓采样就是在时间轴上对信号进行数字化。根据奈奎斯特定理(也称为采样定理)，按比声音最高频率高2倍以上的频率对声音进行采样(也称为AD转换)，前面提到过，对于高质量的音频信号，其频率范围(人耳能够听到的频率范围)是20Hz~20kHz，所以采样频率一般为44.1kHz，这样就可以保证采样声音达到20kHz也能被数字化，从而使得经过数字化处理之后，人耳听到的声音质量不会被降低。而所谓的44.1kHz就是代表1秒会采样44100次<br><img src="https://tva1.sinaimg.cn/large/003088Elly1gvdq4xc3sgj60ds05oaa402.jpg" alt="采样"></p><h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><p>那么，具体的每个采样又该如何表示呢?这就涉及将要讲解的第二个概念:量化。量化是指在幅度轴上对信号进行数字化，比如用16比特的二进制信号来表示声音的一个采样，而16比特(一个short)所表示的范围是[-32768，32767]，共有65536个可能取值，因此最终模拟的音频信号在幅度上也分为了65536层<br><img src="https://tva1.sinaimg.cn/large/003088Elly1gvdq5axltxj60dp0583yu02.jpg" alt="量化"><br>既然每一个量化都是一个采样，那么这么多的采样该如何进行存储呢?</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>这就涉及将要讲解的第三个概念:编码。所谓编码，就是按照一定的格式记录采样和量化后的数字数据，比如顺序存储或压缩存储，等等。</p><p>这里面涉及了很多种格式，通常所说的音频的裸数据格式就是脉冲编码调制(Pulse Code Modulation，PCM)数据。</p><p>描述一段PCM数据一般需 要以下几个概念:量化格式(sampleFormat)、采样率(sampleRate)、声道数(channel)。</p><p>以CD的音质为例:量化格式(有的地方描述为位深度)为16比特(2字节)，采样率为44100，声道数为2，这些信息就描述了CD的音质。</p><p>而对于声音格式，还有一个概念用来描述它的大小，称为数据比特 率，即1秒时间内的比特数目，它用于衡量音频数据单位时间内的容量大小。</p><p>而对于CD音质的数据，比特率为多少呢?</p><p><code>44100 * 16 * 2 = 1378.125kbps</code></p><p>那么在1分钟里，这类CD音质的数据需要占据多大的存储空间呢? 计算如下:</p><p><code>1378.125 * 60 / 8 / 1024 = 10.09MB</code></p><p>当然，如果sampleFormat更加精确(比如用4字节来描述一个采样)，或者sampleRate更加密集(比如48kHz的采样率)，那么所占的存储空间就会更大，同时能够描述的声音细节就会越精确。存储的这段二进制数据即表示将模拟信号转换为数字信号了，以后就可以对这段二进制数据进行存储、播放、复制，或者进行其他任何操作。</p><p><strong>麦克风是如何采集声音的</strong></p><p>麦克风里面有一层碳膜，非常薄而且十分敏感。</p><p>声音其实是一种纵波，会压缩空气也会压缩这层碳膜，碳膜在受到挤压时也会发出振动，在碳膜的下方就是一个电极，碳膜在振动的时候会接触电极，接触时间的长短和频率与声波的振动幅度和频率有关，这样就完成了声音信号到电信号的转换。之后再经过放大电路处理，就可以实施 后面的采样量化处理了。</p><p>前面提到过分贝，那么什么是分贝呢?</p><p>分贝是用来表示声音强度的单位。日常生活中听到的声音，若以声压值来表示，由于其变化范围非常大，可以达到六个数量级以上，同时由于我们的耳朵对声音信号强弱刺激的反应不是线性的(等响曲线)，而是呈对数比例关系，所以引入分贝的概念来表达声学量值。所谓分贝是指两个相同的物理量 (例如，A1和A0)之比取以10为底的对数并乘以10(或20)，即:<br><code>N= 10 * lg(A1 / A0)</code></p><p>分贝符号为“dB”，它是无量纲的。式中A0是基准量(或参考量)，A1 是被量度量。</p><h2 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h2><p>前面提到了CD音质的数据采样格式，曾计算出每分钟需要的存储空间约为10.1MB，如果仅仅是将其存放在存储设备(光盘、硬盘)中，可能是可以接受的，但是若要在网络中实时在线传播的话，那么这个数据量可能就太大了，所以必须对其进行压缩编码。</p><p>压缩编码的基本指标之一就是压缩比，压缩比通常小于1(否则就没有必要去做压缩，因为压缩就是要减小数据容量)。压缩算法包括有损压缩和无损压缩。</p><p>无损压缩是指解压后的数据可以完全复原。在常用的压缩格式中，用得较多的是有损压缩，有损压缩是指解压后的数据不能完全复原，会丢失一部分信息，压缩比越小，丢失的信息就越多，信号还原后的失真就会越大。根据不同的应用场景(包括存储设备、传输网络环境、播放设备等)，可以选用不同的压缩编码算法，如PCM、WAV、AAC、MP3、Ogg等。</p><p>压缩编码的原理实际上是压缩掉冗余信号，冗余信号是指不能被人耳感知到的信号，包含人耳听觉范围之外的音频信号以及被掩蔽掉的音频信号等。人耳听觉范围之外的音频信号在前面已经提到过，所以在此不再赘述。而被掩蔽掉的音频信号则主要是因为人耳的掩蔽效应，主要表现为频域掩蔽效应与时域掩蔽效应，无论是在时域还是频域上，被掩蔽掉的声音信号都被认为是冗余信息，不进行编码处理。</p><p>下面介绍几种常用的压缩编码格式。</p><ol><li>WAV编码</li></ol><p>PCM(脉冲编码调制)是Pulse Code Modulation的缩写。</p><p>前面已经介 绍过PCM大致的工作流程，而WAV编码的一种实现(有多种实现方式，但是都不会进行压缩操作)就是在PCM数据格式的前面加上44字节，分 别用来描述PCM的采样率、声道数、数据格式等信息。</p><p>特点:音质非常好，大量软件都支持。</p><p>适用场合:多媒体开发的中间文件、保存音乐和音效素材。</p><ol start="2"><li>MP3编码</li></ol><p>MP3具有不错的压缩比，使用LAME编码(MP3编码格式的一种实现)的中高码率的MP3文件，听感上非常接近源WAV文件，当然在不同的 应用场景下，应该调整合适的参数以达到最好的效果。</p><p>特点:音质在128Kbit/s以上表现还不错，压缩比比较高，大量软件和 硬件都支持，兼容性好。</p><p>适用场合:高比特率下对兼容性有要求的音乐欣赏。</p><ol start="3"><li>AAC编码</li></ol><p>AAC是新一代的音频有损压缩技术，它通过一些附加的编码技术(比如PS、SBR等)，衍生出了LC-AAC、HE-AAC、HE-AAC v2三种主要的 编码格式。LC-AAC是比较传统的AAC，相对而言，其主要应用于中高码 率场景的编码(≥80Kbit/s);HE-AAC(相当于AAC+SBR)主要应用于中低 码率场景的编码(≤80Kbit/s);而新近推出的HE-AAC v2(相当于 AAC+SBR+PS)主要应用于低码率场景的编码(≤48Kbit/s)。事实上大部 分编码器都设置为≤48Kbit/s自动启用PS技术，而&gt;48Kbit/s则不加PS，相 当于普通的HE-AAC。</p><p>特点:在小于128Kbit/s的码率下表现优异，并且多用于视频中的音频编码。</p><p>适用场合:128Kbit/s以下的音频编码，多用于视频中音频轨的编码。</p><ol start="4"><li>Ogg编码</li></ol><p>Ogg是一种非常有潜力的编码，在各种码率下都有比较优秀的表现，尤其是在中低码率场景下。Ogg除了音质好之外，还是完全免费的，这为Ogg获得更多的支持打好了基础。Ogg有着非常出色的算法，可以用更小 的码率达到更好的音质，128Kbit/s的Ogg比192Kbit/s甚至更高码率的 MP3还要出色。但目前因为还没有媒体服务软件的支持，因此基于Ogg的数字广播还无法实现。Ogg目前受支持的情况还不够好，无论是软件上的 还是硬件上的支持，都无法和MP3相提并论。</p><p>特点:可以用比MP3更小的码率实现比MP3更好的音质，高中低码率 下均有良好的表现，兼容性不够好，流媒体特性不支持。</p><p>适用场合:语音聊天的音频消息场景。</p><h2 id="图像的物理现象"><a href="#图像的物理现象" class="headerlink" title="图像的物理现象"></a>图像的物理现象</h2><p>视频是由一幅幅图像组成的，所以要学习视频还得从图像学习开始。</p><p>与音频的学习方法类似，视频的学习依然是从图像的物理现象开始回顾，这里需要回顾一下小学做过的三棱镜实验，还记得如何利用三棱镜将太阳光分解成彩色的光带吗?</p><p>第一个做这个实验的人是牛顿，各色光因其所形成的折射角不同而彼此分离，就像彩虹一样，所以白光能够 分解成多种色彩的光。</p><p>后来人们通过实验证明，红绿蓝三种色光无法被 分解，故称为三原色光，等量的三原色光相加会变为白光，即白光中含有 等量的红光(R)、绿光(G)、蓝光(B)。</p><p>在日常生活中，由于光的反射，我们才能看到各类物体的轮廓及颜色。但是如果将这个理论应用到手机上，那么结论还是这个样子吗?</p><p>答案是否定的，因为在黑暗中我们也可以看到手机屏幕上的内容，实际上人眼能看到手机屏幕上的内容的原理如下。</p><p><img src="https://tva1.sinaimg.cn/large/003088Elly1gvdqlnwbwnj60fa0fa47102.jpg" alt="显示原理点阵列"></p><p>假设一部手机屏幕的分辨率是1280×720，说明水平方向有720个像素点，垂直方向有1280个像素点，所以整个手机屏幕就有1280×720个像素点(这也是分辨率的含义)。</p><p>每个像素点都由三个子像素点组成，这些密密麻麻的子像素点在显微镜下可以看得一清二楚。</p><p>当要显示某篇文字或者某幅图像时，就会把这幅图像的每一个像素点的RGB通道分别对应的屏幕位置上的子像素点绘制到屏幕上，从而显示整个图像。</p><p>所以在黑暗的环境下也能看到手机屏幕上的内容，是因为手机屏幕是自发光的，而不是通过光的反射才被人们看到的。</p><h2 id="图像的数值表示"><a href="#图像的数值表示" class="headerlink" title="图像的数值表示"></a>图像的数值表示</h2><h3 id="RGB表示方式"><a href="#RGB表示方式" class="headerlink" title="RGB表示方式"></a>RGB表示方式</h3><p>我们已经知道任何一个图像都可以由RGB组成，那么一个像素点的RGB该如何表示呢?音频里面的每一个采样(sample) 均使用16个比特来表示，那么像素里面的子像素又该如何表示呢?</p><p>常用的表示方式有以下几种。</p><p>浮点表示:取值范围为0.0~1.0，比如，在OpenGL ES中对每一个子像素点的表示使用的就是这种表达方式。</p><p>整数表示:取值范围为0~255或者00~FF，8个比特表示一个子像素，32个比特表示一个像素，这就是类似于某些平台上表示图像格式的 RGBA_8888数据格式。比如，Android平台上RGB_565的表示方法为16比特模式表示一个像素，R用5个比特来表示，G用6个比特来表示，B用5个比特来表示。</p><p>对于一幅图像，一般使用整数表示方法来进行描述，比如计算一张1280×720的RGBA_8888图像的大小，可采用如下方式:</p><p><code>1280 * 720 * 4 = 3.516MB</code></p><p>这也是位图(bitmap)在内存中所占用的大小，所以每一张图像的裸数据都是很大的。对于图像的裸数据来讲，直接在网络上进行传输也是不太可能的，所以就有了图像的压缩格式，比如JPEG压缩:JPEG是静态图像压缩标准，由ISO制定。JPEG图像压缩算法在提供良好的压缩性能 的同时，具有较好的重建质量。这种算法被广泛应用于图像处理领域，当然其也是一种有损压缩。在很多网站如淘宝上使用的都是这种压缩之后的图片，但是，这种压缩不能直接应用于视频压缩，因为对于视频来讲，还有一个时域上的因素需要考虑，也就是说，不仅仅要考虑帧内编码，还要考虑帧间编码。视频采用的是更成熟的算法。后面会讲到。</p><h3 id="YUV表示方式"><a href="#YUV表示方式" class="headerlink" title="YUV表示方式"></a>YUV表示方式</h3><p>对于视频帧的裸数据表示，其实更多的是YUV数据格式的表示，YUV主要应用于优化彩色视频信号的传输，使其向后兼容老式黑白电视。</p><p>与RGB视频信号传输相比，它最大的优点在于只需要占用极少的频宽(RGB要求三个独立的视频信号同时传输)。</p><p>其中“Y”表示明亮度 (Luminance或Luma)，也称灰阶值;</p><p>而“U”和“V”表示的则是色度 (Chrominance或Chroma)，它们的作用是描述影像的色彩及饱和度，用于 指定像素的颜色。</p><p>“亮度”是透过RGB输入信号来建立的，方法是将RGB信号的特定部分叠加到一起。</p><p>“色度”则定义了颜色的两个方面——色调与饱和度，分别用Cr和Cb来表示。</p><p>其中，Cr反映了RGB输入信号红色部 分与RGB信号亮度值之间的差异，而Cb反映的则是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。</p><p>之所以采用YUV色彩空间，是因为它的亮度信号Y和色度信号U、V 是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就 是黑白灰度图像。彩色电视采用YUV空间正是为了用亮度信号Y解决彩 色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信 号，最常用的表示形式是Y、U、V都使用8个字节来表示，所以取值范围 就是0~255。在广播电视系统中不传输很低和很高的数值，实际上是为 了防止信号变动造成过载，因而把这“两边”的数值作为“保护带”，不论是 Rec.601还是BT.709的广播电视标准中，Y的取值范围都是16~235，UV 的取值范围都是16~240。</p><p>YUV最常用的采样格式是4:2:0，4:2:0并不意味着只有Y、Cb而没 有Cr分量。它指的是对每行扫描线来说，只有一种色度分量是以2:1的抽 样率来存储的。相邻的扫描行存储着不同的色度分量，也就是说，如果某 一行是4:2:0，那么其下一行就是4:0:2，再下一行是4:2:0，以此类推。对 于每个色度分量来说，水平方向和竖直方向的抽样率都是2:1，所以可以 说色度的抽样率是4:1。对非压缩的8比特量化的视频来说，8×4的一张图片需要占用48字节的内存。</p><p><img src="https://tva1.sinaimg.cn/large/003088Elly1gvdqsvi3fvj60ec06fwht02.jpg" alt="YUV"></p><p>相较于RGB，我们可以计算一帧为1280×720的视频帧，用YUV420P的格式来表示，其数据量的大小如下:<br><code>1280 * 720 * 1 + 1280 * 720 * 0.5 = 1.318MB</code></p><p>如果fps(1秒的视频帧数目)是24，按照一般电影的长度90分钟来计算，那么这部电影用YUV420P的数据格式来表示的话，其数据量的大小就是:<br><code>1.318MB * 24fps * 90min * 60s = 166.8GB</code></p><p>所以仅用这种方式来存储电影肯定是不可行的，更别说在网络上进 行流媒体播放了，那么如何对电影进行存储以及流媒体播放呢?答案是需要进行视频编码，下一节将会讨论视频的编码。</p><h3 id="YUV和RGB的转化"><a href="#YUV和RGB的转化" class="headerlink" title="YUV和RGB的转化"></a>YUV和RGB的转化</h3><p>前面已经讲过，凡是渲染到屏幕上的东西(文字、图片或者其他)，都要转换为RGB的表示形式，那么YUV的表示形式和RGB的表示形式之间 是如何进行转换的呢?对于标清电视601标准，它从YUV转换到RGB的公式与高清电视709的标准是不同的，通过如下的计算即可得知。</p><p><img src="https://tva1.sinaimg.cn/large/003088Elly1gvdquptu44j60lu0a775q02.jpg" alt="标清电视使用标准"></p><p><img src="https://tva1.sinaimg.cn/large/003088Elly1gvdqv3lqroj60ly0a875r02.jpg" alt="高清电视使用标准"></p><p>那么什么时候该用哪一种转换呢?比较典型的场景是在iOS平台中使用摄像头采集出YUV数据之后，上传显卡成为一个纹理ID，这个时候就需要做YUV到RGB的转换(具体的细节会在后面的章节中详细讲解)。在iOS的摄像头采集出一帧数据之后(CMSampleBufferRef)，我们可以在 其中调用CVBufferGetAttachment来获取YCbCrMatrix，用于决定使用哪 一个矩阵进行转换，对于Android的摄像头，由于其是直接纹理ID的回调，所以不涉及这个问题。其他场景下需要大家自行寻找对应的文档，以找出适合的转换矩阵进行转换。</p><h2 id="视频的编码方式"><a href="#视频的编码方式" class="headerlink" title="视频的编码方式"></a>视频的编码方式</h2><h3 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h3><p>还记得前面讨论的音频压缩方式吗?</p><p>音频压缩主要是去除冗余信息，从而实现数据量的压缩。</p><p>那么对于视频压缩，又该从哪几方面来对数据进行压缩呢?</p><p>其实与前面提到的音频编码类似，视频压缩也是通过去除冗余信息来进行压缩的。</p><p>相较于音频数据，视频数据有极强的相关性，也就是说有大量的冗余信息，包括空间上的冗余信息和时间上的冗余信息。</p><p>使用帧间编码技术可以去除时间上的冗余信息，具体包括以下几个部分。</p><ul><li><p>运动补偿:运动补偿是通过先前的局部图像来预测、补偿当前的局部图像，它是减少帧序列冗余信息的有效方法。</p></li><li><p>运动表示:不同区域的图像需要使用不同的运动矢量来描述运动信息。</p></li><li><p>运动估计:运动估计是从视频序列中抽取运动信息的一整套技术。</p></li></ul><p>使用帧内编码技术可以去除空间上的冗余信息。</p><p>还记得前面提到过的图像编码标准JPEG吗?</p><p>对于视频，ISO同样也制定了标准:Motion JPEG即MPEG，MPEG算法是适用于动态视频的压缩算法，它除了对单幅图像进行编码外，还利用图像序列中的相关原则去除冗余，这样可以大大提高视频的压缩比。</p><p>截至目前，MPEG的版本一直在不断更新中，主要包括这样几个版本:</p><ul><li>Mpeg1(用于VCD)</li><li>Mpeg2(用于 DVD)</li><li>Mpeg4 AVC(现在流媒体使用最多的就是它了)</li></ul><p>相比较于ISO制定的MPEG的视频压缩标准，ITU-T制定的H.261、 H.262、H.263、H.264一系列视频编码标准是一套单独的体系。</p><p>其中， H.264集中了以往标准的所有优点，并吸取了以往标准的经验，采用的是简洁设计，这使得它比Mpeg4更容易推广。</p><p>现在使用最多的就是H.264标准，H.264创造了多参考帧、多块类型、整数变换、帧内预测等新的压缩技术，使用了更精细的分像素运动矢量(1/4、1/8)和新一代的环路滤波器，这使得压缩性能得到大大提高，系统也变得更加完善。</p><h3 id="编码概念"><a href="#编码概念" class="headerlink" title="编码概念"></a>编码概念</h3><h4 id="IPB帧"><a href="#IPB帧" class="headerlink" title="IPB帧"></a>IPB帧</h4><p>视频压缩中，每帧都代表着一幅静止的图像。而在进行实际压缩时，会采取各种算法以减少数据的容量，其中IPB帧就是最常见的一种。</p><ul><li>I帧:帧内编码帧(intra picture)，I帧通常是每个GOP(MPEG所使用 的一种视频压缩技术)的第一个帧，经过适度地压缩，作为随机访问的参 考点，可以当成静态图像。I帧可以看作一个图像经过压缩后的产物，I帧 压缩可以得到6:1的压缩比而不会产生任何可觉察的模糊现象。I帧压缩 可去掉视频的空间冗余信息，下面即将介绍的P帧和B帧是为了去掉时间 冗余信息。</li><li>P帧:前向预测编码帧(predictive-frame)，通过将图像序列中前面已 编码帧的时间冗余信息充分去除来压缩传输数据量的编码图像，也称为 预测帧。</li><li>B帧:双向预测内插编码帧(bi-directional interpolated prediction frame)，既考虑源图像序列前面的已编码帧，又顾及源图像序列后面的已 编码帧之间的时间冗余信息，来压缩传输数据量的编码图像，也称为双 向预测帧。</li></ul><p>基于上面的定义，我们可以从解码的角度来理解IPB帧。</p><ul><li>I帧自身可以通过视频解压算法解压成一张单独的完整视频画面，所以I帧去掉的是视频帧在空间维度上的冗余信息。</li><li>P帧需要参考其前面的一个I帧或者P帧来解码成一张完整的视频画面。</li><li>B帧则需要参考其前一个I帧或者P帧及其后面的一个P帧来生成一 张完整的视频画面，所以P帧与B帧去掉的是视频帧在时间维度上的冗余 信息。</li></ul><h4 id="IDR帧与I帧的理解"><a href="#IDR帧与I帧的理解" class="headerlink" title="IDR帧与I帧的理解"></a>IDR帧与I帧的理解</h4><p>在H264的概念中有一个帧称为IDR帧，那么IDR帧与I帧的区别是什么呢?</p><p>首先来看一下IDR的英文全称instantaneous decoding refresh picture，因为H264采用了多帧预测，所以I帧之后的P帧有可能会参考I帧之前的帧，这就使得在随机访问的时候不能以找到I帧作为参考条件，因为即使找到I帧，I帧之后的帧还是有可能解析不出来，而IDR帧就是一种特殊的I帧，即这一帧之后的所有参考帧只会参考到这个IDR帧，而不会再参考前面的帧。在解码器中，一旦收到一个IDR帧，就会立即清理参考帧缓冲区，并将IDR帧作为被参考的帧。</p><h4 id="PTS与DTS"><a href="#PTS与DTS" class="headerlink" title="PTS与DTS"></a>PTS与DTS</h4><p>DTS主要用于视频的解码，英文全称是Decoding Time Stamp，PTS主要用于在解码阶段进行视频的同步和输出，全称是Presentation Time Stamp。在没有B帧的情况下，DTS和PTS的输出顺序是一样的。</p><p>因为B帧打乱了解码和显示的顺序，所以一旦存在B帧，PTS与DTS势必就会不 同，本书后边的章节里会详细讲解如何结合硬件编码器来重新设置PTS 和DTS的值，以便将硬件编码器和FFmpeg结合起来使用。这里先简单介 绍一下FFmpeg中使用的PTS和DTS的概念，FFmpeg中使用AVPacket结构 体来描述解码前或编码后的压缩数据，用AVFrame结构体来描述解码后或编码前的原始数据。</p><p>对于视频来说，AVFrame就是视频的一帧图像，这 帧图像什么时候显示给用户，取决于它的PTS。DTS是AVPacket里的一个成员，表示该压缩包应该在什么时候被解码，如果视频里各帧的编码是按输入顺序(显示顺序)依次进行的，那么解码和显示时间应该是一致的，但是事实上，在大多数编解码标准(如H.264或HEVC)中，编码顺序和输入顺序并不一致，于是才会需要PTS和DTS这两种不同的时间戳。</p><h4 id="GOP的概念"><a href="#GOP的概念" class="headerlink" title="GOP的概念"></a>GOP的概念</h4><p>两个I帧之间形成的一组图片，就是GOP(Group Of Picture)的概念。</p><p>通常在为编码器设置参数的时候，必须要设置gop_size的值，其代表的是两个I帧之间的帧数目前面已经讲解过，一个GOP中容量最大的帧就是I帧，所以相对来讲，gop_size设置得越大，整个画面的质量就会越好，但是在解码端必须从接收到的第一个I帧开始才可以正确解码出原始图像，否则会无法正确解码(这也是前面提到的I帧可以作为随机访问的帧)。</p><p>在提高视频质量的技巧中，还有个技巧是多使用B帧，一般来说，I的压缩率是7(与JPG差不多)，P是20，B可以达到50，可见使用B帧能节省大量空 间，节省出来的空间可以用来更多地保存I帧，这样就能在相同的码率下提供更好的画质。</p><p>所以我们要根据不同的业务场景，适当地设置gop_size的大小，以得到更高质量的视频。</p><p>结合IPB帧和图，相信大家能够更好地理解PTS与DTS的概念。</p><p><img src="https://tva1.sinaimg.cn/large/003088Elly1gvdr11461sj60nf08jjst02.jpg" alt="IPB帧"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是声音&quot;&gt;&lt;a href=&quot;#什么是声音&quot; class=&quot;headerlink&quot; title=&quot;什么是声音&quot;&gt;&lt;/a&gt;什么是声音&lt;/h2&gt;&lt;h3 id=&quot;声音是波&quot;&gt;&lt;a href=&quot;#声音是波&quot; class=&quot;headerlink&quot; title=&quot;声音是波&quot;&gt;&lt;/a&gt;声音是波&lt;/h3&gt;&lt;p&gt;说到声音，爱好音乐的人首先可能会想到优美的音乐或者是劲爆十足的舞曲，这些音乐只是声音的一种。音乐是由乐器弹奏或者歌手演唱而产生的，那么声音是如何产生的呢?回想一下中学物理课本上的定义 &lt;/p&gt;
&lt;p&gt;– 声音是由物体振动而产生的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/003088Elly1gvdp7mzv0fj60hs0ewq3u02.jpg&quot; alt=&quot;震动是声音的产生原因&quot;&gt;&lt;/p&gt;
&lt;p&gt;当小球撞击到音叉的时候，音叉会发生振动，对周围的空气产生挤压，从而产生声音。声音是一种压力波，当演奏乐器、拍打一扇门或者敲击桌面时，它们的振动都会引起空气有节奏的振动，使周围的空气产生疏密变化，形成疏密相间的纵波(可以理解为石头落入水中激起的波纹)，由此就产生了声波，这种现象会一直延续到振动消失为止。&lt;/p&gt;
&lt;h3 id=&quot;声波的三要素&quot;&gt;&lt;a href=&quot;#声波的三要素&quot; class=&quot;headerlink&quot; title=&quot;声波的三要素&quot;&gt;&lt;/a&gt;声波的三要素&lt;/h3&gt;&lt;p&gt;声波的三要素是频率、振幅和波形，频率代表音阶的高低，振幅代表响度，波形代表音色。&lt;/p&gt;
&lt;p&gt;频率(过零率)越高，波长就越短。低频声响的波长则较长，所以其可 以更容易地绕过障碍物，因此能量衰减就小，声音就会传得远，反之则会 得到完全相反的结论。&lt;/p&gt;
&lt;p&gt;响度其实就是能量大小的反映，用不同的力度敲击桌子，声音的大 小势必也会不同。在生活中，分贝常用于描述响度的大小。声音超过一定 的分贝，人类的耳朵就会受不了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ElasticSearch VS. Solr VS. Sphinx：最好的开源搜索引擎比较</title>
    <link href="http://blog.huixing.org/elasticsearch_vs_solr_vs_sphinx/"/>
    <id>http://blog.huixing.org/elasticsearch_vs_solr_vs_sphinx/</id>
    <published>2021-07-23T02:39:05.000Z</published>
    <updated>2021-10-13T08:17:44.423Z</updated>
    
    <content type="html"><![CDATA[<p>译者按：本文是来自一家乌克兰技术公司的文章。该文章译者认为着重在应用上，而非单纯的性能对比。给自己的平台选择一个合适的搜索引擎比任何一个吹嘘技术强大的好。虽然最近一两年 ES发展飞速，但sphinx的简单易用性还是赢得很多机构公司的青睐，比如优酷土豆都是用sphinx。所以使用之前，务必先了解自己的业务诉求，再选择合适的搜索引擎，而非一昧跟风。翻译若有误请指正，谢谢查看！</p><p>编译自：<a href="https://greenice.net/elasticsearch-vs-solr-vs-sphinx-best-open-source-search-platform-comparison/">ELASTICSEARCH VS. SOLR VS. SPHINX: BEST OPEN SOURCE SEARCH PLATFORM COMPARISON</a></p><p>作者：Anna Klimenko</p><p>从业务角度来看，您应该将高效的搜索引擎视为一种强大的工具，能够提高转换率并为网站所有者带来更多利润。如果您的网站搜索机制没有提供相关结果或搜索性能太低，用户将离开网站并转到其竞争对手。</p><p>那么，什么是高效的搜索引擎？</p><p>搜索的主要目的是检索与用户查询最相关的匹配，排除网站上的其他常规内容。</p><p>在当前搜索引擎中可以获得的功能中，最受欢迎的是：</p><ul><li>全文搜索（通过简单的单词和短语或单词或短语的多种形式）</li><li>多字段搜索</li><li>高亮显示（在搜索框中输入的单词的高亮）</li><li>按同义词搜索</li><li>自动填充建议</li></ul><p><img src="https://ww1.sinaimg.cn/large/008j9bnIgy1gsqoqzo5umj30wu06kwhn.jpg" alt="Suggestions and highlighting on Bloomberg"></p><ul><li>多值属性搜索（原文：faceted search，译者改成多值属性或许会更准确）（属性计数。例如，电子商务网站使用构面告诉客户特定型号，大小，颜色和其他属性的项目数量）</li></ul><p><img src="https://ws1.sinaimg.cn/large/008j9bnIgy1gsqosfxpcyj30rg0jt7b6.jpg" alt="Faceted search on Boohoo"></p><ul><li>模糊搜索（错别字，拼写错误）</li><li>拼写更正</li><li>地理空间搜索（根据其纬度和经度搜索对象位置） 【GEO search】</li></ul><p><img src="https://ws1.sinaimg.cn/large/008j9bnIgy1gsqotjjdj0j30hr09eahu.jpg" alt="Geospatial search on TripAdvisor"></p><p>系统应该能够通过使用范围（价格，日期，大小等），排序（按受欢迎程度，日期，价格）和过滤（仅包括所需参数）来缩小搜索范围。</p><p>当我们谈论信息动态变化的网络应用程序（价格，描述细节，商品的可用性）时，近乎实时的更新是非常重要的; 例如，在电子商务或预订引擎中显示库存中可用的商品和服务。</p><p>除了上面列出的一般功能外，引擎还可以在查找用户最感兴趣的产品或信息时提供建议，以改善用户体验。</p><p><img src="https://ws1.sinaimg.cn/large/008j9bnIgy1gsqouvvpjvj30md09m0v2.jpg" alt="Recommendations by Amazon"></p><h2 id="究竟选择哪种技术？"><a href="#究竟选择哪种技术？" class="headerlink" title="究竟选择哪种技术？"></a>究竟选择哪种技术？</h2><p>当前大约有20个搜索引擎可供选择，但是，如果您正在为您的Web应用程序寻找可靠而有效的解决方案，我们建议您使用以下三种方法之一：Elasticsearch，Solr或Sphinx – 这是2018年最流行的三种引擎。</p><p>这三个都是开源搜索解决方案，得到了他们的贡献者社区的充分支持。它们都具有高性能，可扩展性和灵活性，且具有其特性。</p><p><img src="https://ws1.sinaimg.cn/large/008j9bnIgy1gsqovopchfj310y0e1wmy.jpg" alt="DB-engines ranking"></p><p>我们不会像Sphinx vs Solr，Solr vs Sphinx或Sphinx vs Elasticsearch那样进行比较，因为它们都是不错的竞争对手，具有几乎相同的性能，可扩展性和功能。但是它们中的每一个都具有特定的特性，可以对您的项目产生影响。现在，让我们来看看哪个选项对您的业务更有利。</p><p><img src="https://ws1.sinaimg.cn/large/008j9bnIgy1gsqowr36ouj30h603n0t8.jpg" alt="Elasticsearch"></p><p>Elasticsearch是2018年搜索引擎评级的绝对领导者，通过能够在任何环境中工作，证明了其真正“有弹性”的名称。它是一种开源技术，使用的是Apache Lucene库。</p><p>许多世界知名公司都将Elastic用于其应用程序。在这里你可以找到这样的名字  TripAdvisor, Shopify, Mozilla, Foursquare, Etsy, Github, SoundCloud, eBay, Yelp, and Netflix, 等等。</p><h2 id="ElasticSearch的优势"><a href="#ElasticSearch的优势" class="headerlink" title="ElasticSearch的优势"></a>ElasticSearch的优势</h2><p>1.近实时索引</p><p>Elasticsearch能够几乎立即（在不到1秒内）快速索引快速变化的数据。在数据库不断更新的项目中使用它是合适的。<br>例如，在优步，Elasticsearch实时汇总动态（激增）定价和供应定位的业务指标。它能够在高峰时间每秒处理超过1,000个查询。</p><p>2.高可扩展性<br>当数据库增长时，查找起来就变得更加困难。但是当您的数据库变大时，Elasticsearch会扩展，因此搜索速度不会降低。<br>Expedia的，最大的酒店和机票聚合之一，通过提供最高追求，每天1TB具有每秒300K的事件。在Elasticsearch的帮助下，他们成功地改善了客户的预订体验。</p><p>3.储存<br>ES不仅可以用作索引器，还可以用作数据存储器。尽管如此，我们不建议将其用作主存储，并且我们仍然将数据保存在主数据库中以获得更好的安全性和可靠性，仅使用ES来索引数据和存储日志。</p><p>例如， <a href="florida.com">Florida.com</a>，我们的客户之一和汇总佛罗里达度假村所有信息的应用程序，支持庞大的酒店，餐馆，活动，景点，体育，交易等数据库。使用Elasticsearch，我们的数据库中存储的数据可快速编入索引并可搜索用户立刻。</p><p><img src="https://ws1.sinaimg.cn/large/008j9bnIgy1gsqoxrw0xmj317s0o7ki7.jpg" alt="佛罗里达"></p><p>4.数据可视化<br>这是今天在ES中完美实现的时尚功能之一。Elastic Stack（ES，Logstash和Kibana插件的组合）是分析的绝佳工具。它允许实时监控应用程序上的流量（访问者总数，唯一访问者数量，IP地址，最常见的查询，大多数请求的页面，使用的设备和浏览器，按时间显示的流量日志等等） 。</p><p>此信息在仪表板中的彩色图表，地图和表格中可视化。这对于与分布式团队合作非常有帮助，因为每个人都可以立即查看最新信息，然后使用这些数据更好地了解您的受众并改进产品的内容和用户体验。</p><p>在ES的帮助下，The Guardian拥有一个强大的分析系统，每天能够处理4000万个文档，以创建内容消费的愿景。</p><p>在Netflix，在高峰时段有800万个事件和每秒24GB，ES用于视频查看活动，UI活动，错误日志，性能，诊断事件等事件的实时分析。</p><p><img src="https://ws1.sinaimg.cn/large/008j9bnIgy1gsqoy9rxh7j315o0n04eq.jpg" alt="kibana"></p><p>5.安全分析<br>Elastic Stack也是一款出色的安全分析工具。近实时日志分析和可视化使您可以识别安全威胁（Web服务器出现问题，链接断开，未经授权访问的尝试，攻击位置等）。您可以从此官方弹性<a href="https://www.elastic.co/videos/logstash-analytics-with-elastic-stack">视频</a>中了解更多信息。</p><p>通过迁移到ES，戴尔通过确保只有授权人员才能访问其群集来提高安全性。戴尔还将其服务器数量减少了25-30％。</p><p>6.机器学习<br>Elasticsearch可以受益于X-Pack商业插件提供的机器学习功能。机器学习算法专注于时间序列数据中的异常检测和异常检测。</p><ol start="7"><li>AMAZON ELASTICSEARCH SERVICE<br>Amazon Elasticsearch Service可以快速轻松地进行设置，并在云中运行和扩展Elasticsearch，而无需配置您自己的服务器。</li></ol><p>ElasticSearch的弱点</p><p>虽然Elastic目前排名第一，但它仍然是一项年轻的技术。并非所有想要的功能都是开箱即用的，许多功能需要通过自行扩展。例如，ES没有“您是不是意味着什么？”功能。</p><h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><p><img src="https://ws1.sinaimg.cn/large/008j9bnIgy1gsqp0hbpq6j309605kmxj.jpg" alt="Solr"></p><p>Solr是另一个基于Apache Lucene的搜索引擎，因此它与Elasticsearch有许多共同的特性。但是，他们在建筑方面仍然不同。</p><p>使用Solr的公司包括 Cnet, CitySearch, Bloomberg, Magento, Zappos, AOL, eTrade, Disney, Apple, NASA, MTV, 和其他人。</p><p>Solr的优势<br>1.多值属性搜索<br>Solr拥有非常棒的搜索功能，这使得该解决方案非常适合像Zappos这样的电子商务网站，这些网站使用Solr搜索和导航150,000种鞋子和其他产品。</p><p><img src="https://ww1.sinaimg.cn/large/008j9bnIgy1gsqp2dmv2ej30rl0oodsk.jpg" alt="Zappos"></p><p>2.丰富的功能集<br>Solr可以开箱即用，具有高度可配置性（甚至超过Elasticsearch）的丰富的全文搜索功能。Solr支持各种建议器实现，突出显示功能（在字段中输入的单词的可视指示）和拼写检查器/“你的意思是什么？”（在ES中不存在）。</p><p>在Greenice，我们在为澳大利亚客户开展项目时处理了Solr。他们的网站旨在交流小企业家之间的经验。搜索功能包括突出显示，建议和排序。</p><p><img src="https://ww1.sinaimg.cn/large/008j9bnIgy1gsqp2ya25lj30ru0fgq8v.jpg" alt="Greenice"></p><p>3.丰富的内容文档<br>Solr是少数可以阅读丰富内容文档的搜索引擎之一，包括PDF，Word，XML或纯文本。</p><p>这非常适合需要查看网站内大量PDF或Word文件的项目（包括合同，简历，学习材料，电子书等）。</p><p>4.数据可视化<br>Banana 是一种可视化工具（<a href="https://www.youtube.com/watch?v=cqV5lPM2VVE">Kibana的一个分支</a>）适用于Solr，允许管理员动态监控仪表板中的事件和日志。</p><p><img src="https://ww1.sinaimg.cn/large/008j9bnIgy1gsqp3qw50kj318g0sgdw9.jpg" alt="image.png"></p><p>5.机器学习<br>索尔与合作 <a href="https://www.techatbloomberg.com/blog/bloomberg-integrated-learning-rank-apache-solr/">彭博</a>，实施机器学习(<a href="https://lucene.apache.org/solr/guide/6_6/learning-to-rank.html">Learning-to-Rank plug-in</a>) 根据来自更复杂查询的分数，使用文档重新排名的概念。机器学习旨在为用户提供即时搜索最相关公司，人员和新闻的更好体验。</p><p>Solr的弱点</p><p>Solr不如Elasticsearch快，并且最适合静态数据（不需要频繁更改）。原因是缓存。在Solr中，缓存是全局的，这意味着，即使缓存中发生了最微小的变化，所有索引都需要刷新。这通常是一个耗时的过程。另一方面，在弹性中，刷新是由段组成的。</p><h2 id="Sphinx"><a href="#Sphinx" class="headerlink" title="Sphinx"></a>Sphinx</h2><p><img src="https://ww1.sinaimg.cn/large/008j9bnIgy1gsqpbd9gjaj30a003cdg1.jpg" alt="Sphinx"></p><p>Sphinx 在2018年的搜索引擎中排名第五，但它仍然是一种强大且流行的技术，在排名方面让位于Elasticsearch和Solr。<br>Sphinx用于如此着名的系统中 Joomla.org， CouchSurfing.org， Wikimapia.org， Tumblr.com， 以及数百种其他应用。</p><p>Sphinx的优势<br>1.强大而快速<br>Sphinx近年来不断发展，已经能够提供近乎实时的搜索。它的速度包括超过500个查询/秒对1,000,000个文档，最大的索引编号估计为250亿个文档。</p><p>Craigslist在Sphinx的帮助下，每天提供超过3亿次查询。它每月的页面浏览量超过500亿。</p><p>Infegy使用Sphinx为22亿以上的Twitter，Facebook和各种博客文章编制索引，以提供富有洞察力的社交媒体监控和分析查询。</p><p>2.多值属性搜索<br>Sphinx在分面搜索功能方面拥有丰富的经验。</p><p>优酷土豆（好歹看到了一个中国的应用^_^）是中国最大的视频网站，它使用Sphinx进行多值属性搜索，每月向超过4亿用户提供内容，每秒峰值量为15,000个查询。</p><p>在Greenice，我们最近使用Sphinx作为电子商务计算机硬件商店。我们对品牌，类型，用途，屏幕分辨率，矩阵，对角线，HDD容量，SSD容量等属性实施了多值属性搜索。</p><p><img src="https://ww1.sinaimg.cn/large/008j9bnIgy1gsqpbzxxy6j30rs0kgahk.jpg" alt="sphinx搜索"></p><p>没有什么是无用的<br>如果您需要常规搜索功能，并且不需要任何其他功能，如数据可视化和分析，请使用Sphinx。与使用大量内存的Elasticsearch不同，使用有限的计算资源索引和查询大量文档非常快速和强大。<br>其中一个例子是Boardreader，其中Sphinx在37台机器上索引多达160亿个文档。</p><p>Sphinx的弱点<br>Sphinx适用于结构化数据（预定义文本字段和非文本属性），但它不是处理非结构化数据（DOC，PDF，MP3等）的项目的最佳选择，因为它需要开发人员花费大量时间和努力配置。这与配置上的其他困难一起使得Sphinx的使用不如竞争对手。</p><h2 id="开源搜索比较"><a href="#开源搜索比较" class="headerlink" title="开源搜索比较"></a>开源搜索比较</h2><p>以下是Elasticsearch与Solr vs. Sphinx的简要比较：</p><table><thead><tr><th></th><th>Elasticsearch</th><th>Solr</th><th>Sphinx</th></tr></thead><tbody><tr><td>搜索功能的类型</td><td>1.全文<br>2.自动完成建议<br>3.分面<br>4.多场<br>5.同义词<br>6.模糊<br>7.地理空间</td><td>1.全文<br>2.自动完成建议<br>3.分面<br>4.多字段<br>5.同义词<br>6.模糊<br>7.突出显示<br>8.地理空间<br>9.拼写检查</td><td>1. 全文<br>2. 自动完成建议<br>3. 分面<br>4. 多字段<br>5. 同义词（称为字形）<br>6. 地理空间<br>7. 突出显示（称为片段）<br>8. 拼写检查（称为qsuggest）</td></tr><tr><td>实时索引</td><td>是</td><td>是</td><td>是</td></tr><tr><td>性能</td><td>高</td><td>高</td><td>高</td></tr><tr><td>可扩展性</td><td>高</td><td>高</td><td>高</td></tr><tr><td>数据方案</td><td>无架构*</td><td>是的，但是动态*</td><td>是</td></tr><tr><td>可以存储</td><td>是</td><td>是</td><td>没有</td></tr><tr><td>数据可视化</td><td>Elastic Stack  （ES，Kibana和Logstash）</td><td>允许    Banana插件允许</td><td>没有</td></tr><tr><td>机器学习</td><td>是</td><td>是</td><td>没有</td></tr></tbody></table><p>如何将此应用于您的业务<br>当您发现在网站中检索查询结果需要一段时间时，可能会对用户体验产生负面影响。</p><p>通过为您的数据库配备强大的搜索引擎，您的应用程序的性能将大幅提升。</p><p>当代搜索引擎提供复杂的功能，如建议，全文，分面，模糊搜索等，以获得更准确和相关的结果。</p><p>如您所见，Elasticsearch，Solr和Sphinx之间的差异很小。它们都实现了它们的主要目的 – 提供有效和快速的搜索。</p><p>在我们处理不同项目的过程中测试了许多搜索引擎，我们现在主要使用Elasticsearch，因为它已证明它对大多数项目具有最佳品质。它快速，灵活且易于使用，不仅提供快速和相关的搜索功能，而且可以单独作为存储手段。它非常适合在日志中搜索数据以快速识别应用程序的问题，并实时可视化Web应用程序中正在发生的所有事情。</p><p>如果您已经在Solr或Sphinx上有一个项目，那么将它转移到Elasticsearch是没有意义的。无论如何，最好依靠拥有最佳体验并且对其中一个搜索引擎感觉更舒适的开发人员。由于所有项目都是独立的，我们会仔细分析每个请求，以便为您的任务提供最合适的解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;译者按：本文是来自一家乌克兰技术公司的文章。该文章译者认为着重在应用上，而非单纯的性能对比。给自己的平台选择一个合适的搜索引擎比任何一个吹嘘技术强大的好。虽然最近一两年 ES发展飞速，但sphinx的简单易用性还是赢得很多机构公司的青睐，比如优酷土豆都是用sphinx。所以使用之前，务必先了解自己的业务诉求，再选择合适的搜索引擎，而非一昧跟风。翻译若有误请指正，谢谢查看！&lt;/p&gt;
&lt;p&gt;编译自：&lt;a href=&quot;https://greenice.net/elasticsearch-vs-solr-vs-sphinx-best-open-source-search-platform-comparison/&quot;&gt;ELASTICSEARCH VS. SOLR VS. SPHINX: BEST OPEN SOURCE SEARCH PLATFORM COMPARISON&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：Anna Klimenko&lt;/p&gt;
&lt;p&gt;从业务角度来看，您应该将高效的搜索引擎视为一种强大的工具，能够提高转换率并为网站所有者带来更多利润。如果您的网站搜索机制没有提供相关结果或搜索性能太低，用户将离开网站并转到其竞争对手。&lt;/p&gt;
&lt;p&gt;那么，什么是高效的搜索引擎？&lt;/p&gt;
&lt;p&gt;搜索的主要目的是检索与用户查询最相关的匹配，排除网站上的其他常规内容。&lt;/p&gt;
&lt;p&gt;在当前搜索引擎中可以获得的功能中，最受欢迎的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全文搜索（通过简单的单词和短语或单词或短语的多种形式）&lt;/li&gt;
&lt;li&gt;多字段搜索&lt;/li&gt;
&lt;li&gt;高亮显示（在搜索框中输入的单词的高亮）&lt;/li&gt;
&lt;li&gt;按同义词搜索&lt;/li&gt;
&lt;li&gt;自动填充建议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/008j9bnIgy1gsqoqzo5umj30wu06kwhn.jpg&quot; alt=&quot;Suggestions and highlighting on Bloomberg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多值属性搜索（原文：faceted search，译者改成多值属性或许会更准确）（属性计数。例如，电子商务网站使用构面告诉客户特定型号，大小，颜色和其他属性的项目数量）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker 深入浅出</title>
    <link href="http://blog.huixing.org/docker-head-first/"/>
    <id>http://blog.huixing.org/docker-head-first/</id>
    <published>2021-03-11T07:27:27.000Z</published>
    <updated>2021-03-26T06:13:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-架构原理及简单使用"><a href="#Docker-架构原理及简单使用" class="headerlink" title="Docker 架构原理及简单使用"></a>Docker 架构原理及简单使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="了解docker的前生LXC"><a href="#了解docker的前生LXC" class="headerlink" title="了解docker的前生LXC"></a>了解docker的前生LXC</h3><p>LXC为Linux Container的简写。可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。相当于C++中的NameSpace。容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。<br>与传统虚拟化技术相比，它的优势在于：</p><ol><li>与宿主机使用同一个内核，性能损耗小；</li><li>不需要指令级模拟；</li><li>不需要即时(Just-in-time)编译；</li><li>容器可以在CPU核心的本地运行指令，不需要任何专门的解释机制；</li><li>避免了准虚拟化和系统调用替换中的复杂性；</li><li>轻量级隔离，在隔离的同时还提供共享机制，以实现容器与宿主机的资源共享。</li></ol><p>总结：Linux Container是一种轻量级的虚拟化的手段。</p><p>Linux Container提供了在单一可控主机节点上支持多个相互隔离的server container同时执行的机制。Linux Container有点像chroot，提供了一个拥有自己进程和网络空间的虚拟环境，但又有别于虚拟机，因为lxc是一种操作系统层次上的资源的虚拟化。</p><h3 id="LXC与docker什么关系？"><a href="#LXC与docker什么关系？" class="headerlink" title="LXC与docker什么关系？"></a>LXC与docker什么关系？</h3><p>docker并不是LXC替代品，docker底层使用了LXC来实现，LXC将linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。</p><p>在LXC的基础之上，docker提供了一系列更强大的功能。</p><h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>docker是一个开源的应用容器引擎，基于go语言开发并遵循了apache2.0协议开源。</p><p>docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的linux服务器，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类iphone的app），并且容器开销极其低。</p><h3 id="为什么docker越来越受欢迎"><a href="#为什么docker越来越受欢迎" class="headerlink" title="为什么docker越来越受欢迎"></a>为什么docker越来越受欢迎</h3><p>容器化越来越受欢迎，因为容器是：</p><ul><li>灵活：即使是最复杂的应用也可以集装箱化。</li><li>轻量级：容器利用并共享主机内核。</li><li>可互换：您可以即时部署更新和升级。</li><li>便携式：您可以在本地构建，部署到云，并在任何地方运行。</li><li>可扩展：您可以增加并自动分发容器副本。</li><li>可堆叠：您可以垂直和即时堆叠服务。</li></ul><p>镜像和容器（contalners）</p><p>通过镜像启动一个容器，一个镜像是一个可执行的包，其中包括运行应用程序所需要的所有内容包含代码，运行时间，库、环境变量、和配置文件。</p><p>容器是镜像的运行实例，当被运行时有镜像状态和用户进程，可以使用docker ps 查看</p><p>容器和虚拟机</p><p>容器时在linux上本机运行，并与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，非常轻量</p><p>虚拟机运行的是一个完成的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多</p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog1ujsdmnj20k007qdi4.jpg" alt="容器和虚拟机架构图"></p><h3 id="docker版本"><a href="#docker版本" class="headerlink" title="docker版本"></a>docker版本</h3><ul><li>Docker Community Edition（CE）社区版</li><li>Enterprise Edition(EE) 商业版</li></ul><h3 id="docker和openstack的几项对比"><a href="#docker和openstack的几项对比" class="headerlink" title="docker和openstack的几项对比"></a>docker和openstack的几项对比</h3><table><thead><tr><th>类别</th><th>Docker</th><th>OpenStack</th></tr></thead><tbody><tr><td>部署难度</td><td>非常简单</td><td>组件多,部署复杂</td></tr><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>执行性能</td><td>和物理系统几乎一致</td><td>vm会占用一些资源</td></tr><tr><td>镜像体积</td><td>镜像MB级别</td><td>虚拟机镜像GB级别</td></tr><tr><td>管理效率</td><td>管理简单</td><td>组件相互依赖,管理复杂</td></tr><tr><td>隔离性</td><td>隔离性搞</td><td>彻底隔离</td></tr><tr><td>可管理性</td><td>单进程</td><td>完整的系统管理</td></tr><tr><td>网络连接</td><td>比较弱</td><td>借助neutron可灵活组件各类网络管理</td></tr></tbody></table><h3 id="容器在内核中支持2种重要技术"><a href="#容器在内核中支持2种重要技术" class="headerlink" title="容器在内核中支持2种重要技术"></a>容器在内核中支持2种重要技术</h3><p>docker本质就是宿主机的一个进程，docker是通过namespace实现资源隔离，通过cgroup实现资源限制，通过写时复制技术（copy-on-write）实现了高效的文件操作（类似虚拟机的磁盘比如分配500g并不是实际占用物理磁盘500g）</p><p><strong>namespaces 名称空间</strong><br><img src="http://ww1.sinaimg.cn/large/a3eed545ly1gog215fvqmj20f2041wej.jpg" alt="namespaces 名称空间"></p><p><strong>Control Group 控制组</strong></p><p>cgroup的特点是：　　　　　　　</p><p>cgroup的api以一个伪文件系统的实现方式，用户的程序可以通过文件系统实现cgroup的组件管理</p><p>cgroup的组件管理操作单元可以细粒度到线程级别，另外用户可以创建和销毁cgroup，从而实现资源载分配和再利用</p><p>所有资源管理的功能都以子系统的方式实现，接口统一子任务创建之初与其父任务处于同一个cgroup的控制组</p><p><strong>四大功能</strong>：　　　　　　　　</p><ul><li>资源限制：可以对任务使用的资源总额进行限制</li><li>优先级分配：通过分配的cpu时间片数量以及磁盘IO带宽大小，实际上相当于控制了任务运行优先级</li><li>资源统计：可以统计系统的资源使用量，如cpu时长，内存用量等</li><li>任务控制：cgroup可以对任务执行挂起、恢复等操作</li></ul><h3 id="了解docker三个重要概念"><a href="#了解docker三个重要概念" class="headerlink" title="了解docker三个重要概念"></a>了解docker三个重要概念</h3><ol><li><p>image镜像</p><p> docker镜像就是一个只读模板，比如，一个镜像可以包含一个完整的centos，里面仅安装apache或用户的其他应用，镜像可以用来创建docker容器，另外docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下周一个已经做好的镜像来直接使用</p></li><li><p>container容器</p><p> docker利用容器来运行应用，容器是从镜像创建的运行实例，它可以被启动，开始、停止、删除、每个容器都是互相隔离的，保证安全的平台，可以吧容器看做是要给简易版的linux环境（包括root用户权限、镜像空间、用户空间和网络空间等）和运行再其中的应用程序</p></li><li><p>repostory仓库</p><p> 仓库是集中存储镜像文件的沧桑，registry是仓库主从服务器，实际上参考注册服务器上存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）</p></li></ol><p>仓库分为两种，公有参考，和私有仓库，最大的公开仓库是docker Hub，存放了数量庞大的镜像供用户下周，国内的docker pool，这里仓库的概念与Git类似，registry可以理解为github这样的托管服务</p><h3 id="docker的主要用途"><a href="#docker的主要用途" class="headerlink" title="docker的主要用途"></a>docker的主要用途</h3><p>官方就是Bulid 、ship、run any app/any where，编译、装载、运行、任何app/在任意地放都能运行</p><p>就是实现了应用的封装、部署、运行的生命周期管理只要在glibc的环境下，都可以运行</p><p>运维生成环境中：docker化</p><p>发布服务不用担心服务器的运行环境，所有的服务器都是自动分配docker，自动部署，自动安装，自动运行</p><p>再不用担心其他服务引擎的磁盘问题，cpu问题，系统问题了</p><p>资源利用更出色</p><p>自动迁移，可以制作镜像，迁移使用自定义的镜像即可迁移，不会出现什么问题</p><p>管理更加方便了</p><h3 id="docker改变了什么"><a href="#docker改变了什么" class="headerlink" title="docker改变了什么"></a>docker改变了什么</h3><ol><li>面向产品：产品交付</li><li>面向开发：简化环境配置</li><li>面向测试：多版本测试</li><li>面向运维：环境一致性</li><li>面向架构：自动化扩容（微服务）</li></ol><h2 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h2><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog24dqkynj20nj0enmyo.jpg" alt="总体架构"></p><ul><li>distribution 负责与docker registry交互，上传洗澡镜像以及v2 registry 有关的源数据</li><li>registry负责docker registry有关的身份认证、镜像查找、镜像验证以及管理registry mirror等交互操作</li><li>image 负责与镜像源数据有关的存储、查找，镜像层的索引、查找以及镜像tar包有关的导入、导出操作</li><li>reference负责存储本地所有镜像的repository和tag名，并维护与镜像id之间的映射关系</li><li>layer模块负责与镜像层和容器层源数据有关的增删改查，并负责将镜像层的增删改查映射到实际存储镜像层文件的graphdriver模块</li><li>graghdriver是所有与容器镜像相关操作的执行者</li></ul><h3 id="docker架构1"><a href="#docker架构1" class="headerlink" title="docker架构1"></a>docker架构1</h3><p>如果觉得上面架构图比较乱可以看这个架构</p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog257ec3lj20rk0y3440.jpg" alt="docker架构1"></p><p>从上图不难看出，用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</p><p>而Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；而后Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。</p><p>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。</p><p>而libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。当执行完运行容器的命令后，一个实际的Docker容器就处于运行状态，该容器拥有独立的文件系统，独立并且安全的运行环境等。</p><h3 id="docker架构2"><a href="#docker架构2" class="headerlink" title="docker架构2"></a>docker架构2</h3><p>再来看看另外一个架构，这个个架构就简单清晰指明了server/client交互，容器和镜像、数据之间的一些联系</p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog25uxj7ij20j60b9q69.jpg" alt="docker架构2"></p><p>这个架构图更加清晰了架构</p><p>docker daemon就是docker的守护进程即server端，可以是远程的，也可以是本地的，这个不是C/S架构吗，客户端Docker client 是通过rest api进行通信</p><p>docker cli 用来管理容器和镜像，客户端提供一个只读镜像，然后通过镜像可以创建多个容器，这些容器可以只是一个RFS（Root file system根文件系统），也可以ishi一个包含了用户应用的RFS，容器再docker client中只是要给进程，两个进程之间互不可见</p><p>用户不能与server直接交互，但可以通过与容器这个桥梁来交互，由于是操作系统级别的虚拟技术，中间的损耗几乎可以不技</p><h2 id="docker架构2各个模块的功能"><a href="#docker架构2各个模块的功能" class="headerlink" title="docker架构2各个模块的功能"></a>docker架构2各个模块的功能</h2><p>主要的模块有:</p><ul><li>Docker Client</li><li>Docker Daemon</li><li>Docker Registry</li><li>Graph、Driver</li><li>Libcontainer</li><li>Docker container　</li></ul><ol><li><p>docker client</p><p> docker client 是docker架构中用户用来和docker daemon建立通信的客户端，用户使用的可执行文件为docker，通过docker命令行工具可以发起众多管理container的请求</p><p> docker client可以通过一下三宗方式和docker daemon建立通信：tcp://host:port;unix:path_to_socket;fd://socketfd。，docker client可以通过设置命令行flag参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性</p><p> docker client发送容器管理请求后，由docker daemon接受并处理请求，当docker client 接收到返回的请求相应并简单处理后，docker client 一次完整的生命周期就结束了，当需要继续发送容器管理请求时，用户必须再次通过docker可以执行文件创建docker client。</p></li><li><p>docker daemon</p><p> docker daemon 是docker架构中一个常驻在后台的系统进程，功能是：接收处理docker client发送的请求。该守护进程在后台启动一个server，server负载接受docker client发送的请求；接受请求后，server通过路由与分发调度，找到相应的handler来执行请求。</p><p> docker daemon启动所使用的可执行文件也为docker，与docker client启动所使用的可执行文件docker相同，在docker命令执行时，通过传入的参数来判别docker daemon与docker client。</p><p> docker daemon的架构可以分为：docker server、engine、job。daemon</p></li><li><p>docker server</p><p> docker server在docker架构中时专门服务于docker client的server，该server的功能时：接受并调度分发docker client发送的请求，架构图如下：</p><p> <img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog2etjt6qj20hd0d23zv.jpg" alt="docker client"></p><p> 在Docker的启动过程中，通过包gorilla/mux（golang的类库解析），创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。</p><p> 若Docker Client通过HTTP的形式访问Docker Daemon，创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。</p><p> 在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。</p><p> 需要注意的是：Docker Server的运行在Docker的启动过程中，是靠一个名为”serveapi”的job的运行来完成的。原则上，Docker Server的运行是众多job中的一个，但是为了强调Docker Server的重要性以及为后续job服务的重要特性，将该”serveapi”的job单独抽离出来分析，理解为Docker Server。</p></li><li><p>engine</p><p> Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。</p><p> 在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为”create”的job在运行时，执行的是daemon.ContainerCreate的handler。</p></li><li><p>job</p><p> 一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job，从Internet上下载一个文档，这是一个job；包括之前在Docker Server部分说过的，创建Server服务于HTTP的API，这也是一个job，等等。</p><p> Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</p></li><li><p>docker registry</p><p> Docker Registry是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。</p><p> 在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。</p><p> 其中，在Docker架构中，Docker可以使用公有的Docker Registry，即大家熟知的Docker Hub，如此一来，Docker获取容器镜像文件时，必须通过互联网访问Docker Hub；同时Docker也允许用户构建本地私有的Docker Registry，这样可以保证容器镜像的获取在内网完成。</p></li><li><p>Graph</p><p> Graph在Docker架构中扮演已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph存储着本地具有版本信息的文件系统镜像，另一方面也通过GraphDB记录着所有文件系统镜像彼此之间的关系。Graph的架构如下：<br> <img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog2ikt3usj20l10avabx.jpg" alt="Graph架构图"></p><p> 其中，GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。</p><p> 同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。</p></li><li><p>driver</p><p> Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。由于Docker运行的生命周期中，并非用户所有的操作都是针对Docker容器的管理，另外还有关于Docker运行信息的获取，Graph的存储与记录等。因此，为了将Docker容器的管理从Docker Daemon内部业务逻辑中区分开来，设计了Driver层驱动来接管所有这部分请求。</p><p> 在Docker Driver的实现中，可以分为以下三类驱动：graphdriver、networkdriver和execdriver。</p><p> graphdriver主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的rootfs时，graphdriver从本地镜像存储目录中获取指定的容器镜像。</p><p> 在graphdriver的初始化过程之前，有4种文件系统或类文件系统在其内部注册，它们分别是aufs、btrfs、vfs和devmapper。而Docker在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用driver的指定类型。而之后所有的graph操作，都使用该driver来执行。</p><p> graphdriver的架构如下：<br> <img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog2n8l0pfj20fj095gm6.jpg" alt="graphdriver架构图"><br> networkdriver的用途是完成Docker容器网络环境的配置，其中包括Docker启动时为Docker环境创建网桥；Docker容器创建时为其创建专属虚拟网卡设备；以及为Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。networkdriver的架构如下：<br> <img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog2nuwt2tj20gh0av3ze.jpg" alt="networkdriver架构图"><br> execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在execdriver的实现过程中，原先可以使用LXC驱动调用LXC的接口，来操纵容器的配置以及生命周期，而现在execdriver默认使用native驱动，不依赖于LXC。具体体现在Daemon启动过程中加载的ExecDriverflag参数，该参数在配置文件已经被设为”native”。这可以认为是Docker在1.2版本上一个很大的改变，或者说Docker实现跨平台的一个先兆。execdriver架构如下：<br> <img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog2tu7hkij20fd09cjry.jpg" alt="execdriver架构图"></p></li><li><p>libcontainer</p><p> libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。</p><p> 正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。libcontainer架构如下：<br> <img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog2vdwboqj20h0096wf5.jpg" alt="libcontainer架构图"></p><p> 另外，libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。又由于libcontainer使用Go这种跨平台的语言开发实现，且本身又可以被上层多种不同的编程语言访问，因此很难说，未来的Docker就一定会紧紧地和Linux捆绑在一起。而于此同时，Microsoft在其著名云计算平台Azure中，也添加了对Docker的支持，可见Docker的开放程度与业界的火热度。</p><p> 暂不谈Docker，由于libcontainer的功能以及其本身与系统的松耦合特性，很有可能会在其他以容器为原型的平台出现，同时也很有可能催生出云计算领域全新的项目。</p></li><li><p>docker container</p><p>Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。</p><p>Docker按照用户的需求与指令，订制相应的Docker容器：</p><p>用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统； 用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源； 用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境； 用户通过指定运行的命令，使得Docker容器执行指定的工作。<br><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog2wfz9oxj20ln0cjgmg.jpg" alt="docker container"></p></li></ol><h2 id="docker简单使用"><a href="#docker简单使用" class="headerlink" title="docker简单使用"></a>docker简单使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官方安装文档:<a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install docker -y </span><br><span class="line"></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：启动前应当设置源</p><p><code>vim /usr/lib/systemd/system/docker.service</code></p><p>这里设置阿里的，注册阿里云账户号每个用户都有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 ~]# vim /usr/lib/systemd/system/docker.service </span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=http://docs.docker.com</span><br><span class="line">After=network.target</span><br><span class="line">Wants=docker-storage-setup.service</span><br><span class="line">Requires=docker-cleanup.timer</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">NotifyAccess=main</span><br><span class="line">EnvironmentFile=-/run/containers/registries.conf</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/docker</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/docker-storage</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/docker-network</span><br><span class="line">Environment=GOTRACEBACK=crash</span><br><span class="line">Environment=DOCKER_HTTP_HOST_COMPAT=1</span><br><span class="line">Environment=PATH=/usr/libexec/docker:/usr/bin:/usr/sbin</span><br><span class="line">ExecStart=/usr/bin/dockerd-current --registry-mirror=https://rfcod7oz.mirror.aliyuncs.com \ #这个值可以登陆阿里云账号请参考下图</span><br><span class="line">          --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current \</span><br><span class="line">          --default-runtime=docker-runc \</span><br><span class="line">          --exec-opt native.cgroupdriver=systemd \</span><br><span class="line">          --userland-proxy-path=/usr/libexec/docker/docker-proxy-current \</span><br><span class="line">          --init-path=/usr/libexec/docker/docker-init-current \</span><br><span class="line">          --seccomp-profile=/etc/docker/seccomp.json \</span><br><span class="line">          $OPTIONS \</span><br><span class="line">          $DOCKER_STORAGE_OPTIONS \</span><br><span class="line">          $DOCKER_NETWORK_OPTIONS \</span><br><span class="line">          $ADD_REGISTRY \</span><br><span class="line">          $BLOCK_REGISTRY \</span><br><span class="line">          $INSECURE_REGISTRY \</span><br><span class="line">          $REGISTRIES</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line">LimitNPROC=1048576</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">Restart=on-abnormal</span><br><span class="line">KillMode=process</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gog32lik13j20ql0gedla.jpg" alt="阿里云界面图"></p><h3 id="docker版本查询"><a href="#docker版本查询" class="headerlink" title="docker版本查询"></a>docker版本查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.5</span><br><span class="line"> API version:       1.41</span><br><span class="line"> Go version:        go1.13.15</span><br><span class="line"> Git commit:        55c4c88</span><br><span class="line"> Built:             Tue Mar  2 20:33:55 2021</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      true</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          20.10.5</span><br><span class="line">  API version:      1.41 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.13.15</span><br><span class="line">  Git commit:       363e9a8</span><br><span class="line">  Built:            Tue Mar  2 20:32:17 2021</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.4.3</span><br><span class="line">  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.0-rc92</span><br><span class="line">  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br><span class="line">[root@local ~]# </span><br></pre></td></tr></table></figure><h3 id="搜索下载镜像"><a href="#搜索下载镜像" class="headerlink" title="搜索下载镜像"></a>搜索下载镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis　　　　　　　　　　#下载镜像</span><br><span class="line">docker search mysql　　　　　　　　　 #查看镜像</span><br><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><h3 id="查看已经下载的镜像"><a href="#查看已经下载的镜像" class="headerlink" title="查看已经下载的镜像"></a>查看已经下载的镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">redis        latest    f877e80bb9ef   8 days ago    105MB</span><br><span class="line">mysql        5.7.33    d54bd1054823   12 days ago   449MB</span><br></pre></td></tr></table></figure><h3 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h3><p><code>docker  save nginx &gt;/tmp/nginx.tar.gz</code></p><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p><code>docker rmi -f nginx</code></p><h3 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h3><p><code>docker load &lt;/tmp/nginx.tar.gz</code></p><h3 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h3><p><code>vim /usr/lib/systemd/system/docker.service</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target firewalld.service containerd.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=docker.socket containerd.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"># the default is not to use systemd for cgroups because the delegate issues still</span><br><span class="line"># exists and systemd currently does not support the cgroup feature set required</span><br><span class="line"># for containers run by docker</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"># Note that StartLimit* options were moved from &quot;Service&quot; to &quot;Unit&quot; in systemd 229.</span><br><span class="line"># Both the old, and new location are accepted by systemd 229 and up, so using the old location</span><br><span class="line"># to make them work for either version of systemd.</span><br><span class="line">StartLimitBurst=3</span><br><span class="line"></span><br><span class="line"># Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230.</span><br><span class="line"># Both the old, and new name are accepted by systemd 230 and up, so using the old name to make</span><br><span class="line"># this option work for either version of systemd.</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"></span><br><span class="line"># Having non-zero Limit*s causes performance problems due to accounting overhead</span><br><span class="line"># in the kernel. We recommend using cgroups to do container-local accounting.</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"></span><br><span class="line"># Comment TasksMax if your systemd version does not support it.</span><br><span class="line"># Only systemd 226 and above support this option.</span><br><span class="line">TasksMax=infinity</span><br><span class="line"></span><br><span class="line"># set delegate yes so that systemd does not reset the cgroups of docker containers</span><br><span class="line">Delegate=yes</span><br><span class="line"></span><br><span class="line"># kill only the docker process, not all processes in the cgroup</span><br><span class="line">KillMode=process</span><br><span class="line">OOMScoreAdjust=-500</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">~  </span><br></pre></td></tr></table></figure><p>如果更改存储目录就添加</p><p><code>--graph=/opt/docker</code></p><p>如果更改DNS</p><p>默认采用宿主机的dns</p><p><code>--dns=xxxx的方式指定</code></p><h3 id="运行一个容器-run"><a href="#运行一个容器-run" class="headerlink" title="运行一个容器-run"></a>运行一个容器-run</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker run -it redis sh   </span><br><span class="line"># cd ..</span><br><span class="line"># ls</span><br><span class="line">bin  boot  data  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"># exit</span><br><span class="line">[root@local ~]# </span><br></pre></td></tr></table></figure><p>后台运行（-d后台运行）（–name添加一个名字）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker run -it -d --name redis1 redis</span><br><span class="line">57c2f2e3f550caa022be4c1a1065d33d833580b6d4141beca138d82a9efd866e</span><br><span class="line">[root@local ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                 NAMES</span><br><span class="line">57c2f2e3f550   redis          &quot;docker-entrypoint.s…&quot;   12 seconds ago   Up 12 seconds   6379/tcp              redis1</span><br><span class="line">fa6d604f34b0   mysql:5.7.33   &quot;docker-entrypoint.s…&quot;   6 days ago       Up 6 days       3306/tcp, 33060/tcp   mysql5.7</span><br><span class="line">f1035f25b549   redis          &quot;docker-entrypoint.s…&quot;   6 days ago       Up 6 days       6379/tcp              redis</span><br><span class="line">[root@local ~]# </span><br></pre></td></tr></table></figure><p>还有一种-rm参数，ctrl+c后就删除，可以测试环境用，生成环境用的少</p><p><code>docker run -it  --rm --name redis2 redis</code></p><h3 id="如何进入容器"><a href="#如何进入容器" class="headerlink" title="如何进入容器"></a>如何进入容器</h3><p>三种方法，上面已经演示了一种</p><p>第一种，需要容器本身的pid及util-linux，不推荐，暂时不演示了</p><p>第二种，不分配bash终端的一种实施操作，不推荐</p><p>这种操作如果在开一个窗口也能看到操作的指令，所有人都能看到<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker attach redis</span><br><span class="line">ls</span><br><span class="line">ls</span><br><span class="line">^C1:signal-handler (1615455437) Received SIGINT scheduling shutdown...</span><br><span class="line">1:M 11 Mar 2021 09:37:17.600 # User requested shutdown...</span><br><span class="line">1:M 11 Mar 2021 09:37:17.600 * Saving the final RDB snapshot before exiting.</span><br><span class="line">1:M 11 Mar 2021 09:37:17.601 * DB saved on disk</span><br><span class="line">1:M 11 Mar 2021 09:37:17.601 # Redis is now ready to exit, bye bye...</span><br><span class="line">[root@local ~]# ^C</span><br><span class="line">[root@local ~]# docker attach redis</span><br><span class="line">You cannot attach to a stopped container, start it first</span><br><span class="line">[root@local ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED      STATUS      PORTS                 NAMES</span><br><span class="line">fa6d604f34b0   mysql:5.7.33   &quot;docker-entrypoint.s…&quot;   6 days ago   Up 6 days   3306/tcp, 33060/tcp   mysql5.7</span><br></pre></td></tr></table></figure></p><p>第三种：exec方式，终端时分开的，推荐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker run -it -d --name redis1 redis</span><br><span class="line">cf0cf2d3eff2f5a8da0016efe077dd5c91d25fdd09ec39b2ecd521f5b6bff74c</span><br><span class="line">[root@local ~]# docker exec -it redis1 sh </span><br><span class="line"># ls</span><br><span class="line"># cd ..</span><br><span class="line"># ls</span><br><span class="line">bin  boot  data  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"># exit</span><br><span class="line">[root@local ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                 NAMES</span><br><span class="line">cf0cf2d3eff2   redis          &quot;docker-entrypoint.s…&quot;   6 minutes ago   Up 6 minutes   6379/tcp              redis1</span><br><span class="line">fa6d604f34b0   mysql:5.7.33   &quot;docker-entrypoint.s…&quot;   6 days ago      Up 6 days      3306/tcp, 33060/tcp   mysql5.7</span><br><span class="line">[root@local ~]# </span><br></pre></td></tr></table></figure><h3 id="查看docker进程及删除容器"><a href="#查看docker进程及删除容器" class="headerlink" title="查看docker进程及删除容器"></a>查看docker进程及删除容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                 NAMES</span><br><span class="line">cf0cf2d3eff2   redis          &quot;docker-entrypoint.s…&quot;   6 minutes ago   Up 6 minutes   6379/tcp              redis1</span><br><span class="line">fa6d604f34b0   mysql:5.7.33   &quot;docker-entrypoint.s…&quot;   6 days ago      Up 6 days      3306/tcp, 33060/tcp   mysql5.7</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker ps -a </span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                      PORTS                 NAMES</span><br><span class="line">cf0cf2d3eff2   redis          &quot;docker-entrypoint.s…&quot;   9 minutes ago    Up 9 minutes                6379/tcp              redis1</span><br><span class="line">5ee132daeb4c   redis          &quot;docker-entrypoint.s…&quot;   20 minutes ago   Exited (0) 20 minutes ago                         stupefied_chatelet</span><br><span class="line">dc7f8b8d2e75   redis          &quot;docker-entrypoint.s…&quot;   21 minutes ago   Exited (0) 20 minutes ago                         exciting_moore</span><br><span class="line">ca35b108e1fd   redis          &quot;docker-entrypoint.s…&quot;   38 minutes ago   Exited (0) 37 minutes ago                         dazzling_wilbur</span><br><span class="line">7b634fd0ed15   redis          &quot;docker-entrypoint.s…&quot;   38 minutes ago   Exited (0) 38 minutes ago                         nostalgic_feistel</span><br><span class="line">fa6d604f34b0   mysql:5.7.33   &quot;docker-entrypoint.s…&quot;   6 days ago       Up 6 days                   3306/tcp, 33060/tcp   mysql5.7</span><br><span class="line">f1035f25b549   redis          &quot;docker-entrypoint.s…&quot;   6 days ago       Exited (0) 25 minutes ago                         redis</span><br></pre></td></tr></table></figure><h3 id="查看容器详细信息"><a href="#查看容器详细信息" class="headerlink" title="查看容器详细信息"></a>查看容器详细信息</h3><p>并不需要进入到容器里面</p><p>通过查看详细信息看到了刚才运行的nginx，宿主机curl ip地址访问一下运行情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker inspect redis1</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;cf0cf2d3eff2f5a8da0016efe077dd5c91d25fdd09ec39b2ecd521f5b6bff74c&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-03-11T09:52:25.27057006Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;docker-entrypoint.sh&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;redis-server&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 14094,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2021-03-11T09:52:25.557173161Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:f877e80bb9ef719f7d6e7faa3cde7e20b97dc6d774d46175adcc8442ec7236aa&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/cf0cf2d3eff2f5a8da0016efe077dd5c91d25fdd09ec39b2ecd521f5b6bff74c/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/cf0cf2d3eff2f5a8da0016efe077dd5c91d25fdd09ec39b2ecd521f5b6bff74c/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/cf0cf2d3eff2f5a8da0016efe077dd5c91d25fdd09ec39b2ecd521f5b6bff74c/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/cf0cf2d3eff2f5a8da0016efe077dd5c91d25fdd09ec39b2ecd521f5b6bff74c/cf0cf2d3eff2f5a8da0016efe077dd5c91d25fdd09ec39b2ecd521f5b6bff74c-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/redis1&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;CgroupnsMode&quot;: &quot;host&quot;,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;KernelMemory&quot;: 0,</span><br><span class="line">            &quot;KernelMemoryTCP&quot;: 0,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: null,</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/b0e04902fbfbca7b31445142b80d8b81910b7d47349eddc3b79f0ac3550baf88-init/diff:/var/lib/docker/overlay2/c8195a6dbb57677eae47daed1ed16f166301a6030ce90aca170f42705427b7b4/diff:/var/lib/docker/overlay2/c9538592b84c294ce9e2511296f4b74f8ebd48e8c197c66314a3b9caa6d81b80/diff:/var/lib/docker/overlay2/af1a27fcf6f367b3eee0dc7159ae8d000ebe9593ebb2e1daa38427e27c91e9fc/diff:/var/lib/docker/overlay2/1ac7b88145453c7ecd0a01b0bcebabb9733c2a1c61b611f0b3d72261450ff840/diff:/var/lib/docker/overlay2/88bc5c0a0d044d790d6575ef77ed0be038c9bef8fb6c3e9a43b3642e8eeeea60/diff:/var/lib/docker/overlay2/c38c6c85d32a3d8c20db57707f96551848a5b19373588b12964681153c241a57/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/b0e04902fbfbca7b31445142b80d8b81910b7d47349eddc3b79f0ac3550baf88/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/b0e04902fbfbca7b31445142b80d8b81910b7d47349eddc3b79f0ac3550baf88/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/b0e04902fbfbca7b31445142b80d8b81910b7d47349eddc3b79f0ac3550baf88/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;207eca442c7383941a1904df277bb6c660c004d2012fc823714e4b66fe0c9368&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/207eca442c7383941a1904df277bb6c660c004d2012fc823714e4b66fe0c9368/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/data&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;cf0cf2d3eff2&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;6379/tcp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Tty&quot;: true,</span><br><span class="line">            &quot;OpenStdin&quot;: true,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,</span><br><span class="line">                &quot;GOSU_VERSION=1.12&quot;,</span><br><span class="line">                &quot;REDIS_VERSION=6.2.1&quot;,</span><br><span class="line">                &quot;REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.2.1.tar.gz&quot;,</span><br><span class="line">                &quot;REDIS_DOWNLOAD_SHA=cd222505012cce20b25682fca931ec93bd21ae92cb4abfe742cf7b76aa907520&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;redis-server&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;redis&quot;,</span><br><span class="line">            &quot;Volumes&quot;: &#123;</span><br><span class="line">                &quot;/data&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;/data&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: [</span><br><span class="line">                &quot;docker-entrypoint.sh&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;f0d624e7b6a6725aaa92e339314db32854d031acd7742f619eb58ad9829807a4&quot;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;Ports&quot;: &#123;</span><br><span class="line">                &quot;6379/tcp&quot;: null</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/f0d624e7b6a6&quot;,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;abc67c99fadfdcd2b85a26dbc9c8544b97cb8dc591f191796996b1591cc525d2&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;8a8b46d2a60365d4e59517c0f49bfd1e49d789c22c6bc3c13555cc42399e14c4&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;abc67c99fadfdcd2b85a26dbc9c8544b97cb8dc591f191796996b1591cc525d2&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                    &quot;DriverOpts&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p><code>docker logs  -f redis1</code></p><p>-f  挂起这个终端，动态查看日志</p><h1 id="Docker-commit方法镜像制作"><a href="#Docker-commit方法镜像制作" class="headerlink" title="Docker commit方法镜像制作"></a>Docker commit方法镜像制作</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="下载一个centos镜像，进入容器，安装wget"><a href="#下载一个centos镜像，进入容器，安装wget" class="headerlink" title="下载一个centos镜像，进入容器，安装wget"></a>下载一个centos镜像，进入容器，安装wget</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br><span class="line">docker run -it centos bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker run -it centos bash</span><br><span class="line">[root@c98ecb53707d yum.repos.d]# yum install wget -y#安装wget，默认没有wget安装</span><br></pre></td></tr></table></figure><h3 id="安装软件源"><a href="#安装软件源" class="headerlink" title="安装软件源"></a>安装软件源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@c98ecb53707d home]# cd /etc/yum.repos.d/      </span><br><span class="line">[root@c98ecb53707d yum.repos.d]# ls</span><br><span class="line">CentOS-Linux-AppStream.repo  CentOS-Linux-ContinuousRelease.repo  CentOS-Linux-Devel.repo   CentOS-Linux-FastTrack.repo         CentOS-Linux-Media.repo  CentOS-Linux-PowerTools.repo</span><br><span class="line">CentOS-Linux-BaseOS.repo     CentOS-Linux-Debuginfo.repo          CentOS-Linux-Extras.repo  CentOS-Linux-HighAvailability.repo  CentOS-Linux-Plus.repo   CentOS-Linux-Sources.repo</span><br><span class="line">[root@c98ecb53707d yum.repos.d]# mkdir backup #备份文件夹</span><br><span class="line">[root@c98ecb53707d yum.repos.d]# mv C* /etc/yum.repos.d/backup/ #执行备份</span><br><span class="line">[root@c98ecb53707d yum.repos.d]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo #设置阿里云镜像</span><br><span class="line">[root@c98ecb53707d yum.repos.d]# cat /etc/redhat-release #查看发行版本</span><br><span class="line">CentOS Linux release 8.3.2011</span><br><span class="line">[root@c98ecb53707d yum.repos.d]# wget https://mirrors.aliyun.com/centos/8.3.2011/extras/x86_64/os/Packages/epel-release-8-8.el8.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>说明，下面制作镜像先用之前的nginx镜像做的副本，下面才是centos镜像</p><h3 id="使用docker-commit-来提交容器副本"><a href="#使用docker-commit-来提交容器副本" class="headerlink" title="使用docker commit 来提交容器副本"></a>使用docker commit 来提交容器副本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker ps -a #查看容器</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                        PORTS                 NAMES</span><br><span class="line">daed8dd73440   centos         &quot;bash&quot;                   49 seconds ago   Up 48 seconds                         nice_feynman</span><br><span class="line"></span><br><span class="line">[root@local ~]# docker commit -m &#x27;add nginx images&#x27; daed8dd73440  tanhao/my_nginx         # 提交容器</span><br><span class="line">sha256:c40cd4ab1240a10eec1e89146b719fe60fd6b5ff1010e298fc1cb71e15ae7724</span><br><span class="line">[root@local ~]# docker images # 查看</span><br><span class="line">REPOSITORY        TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">tanhao/my_nginx   latest    c40cd4ab1240   2 minutes ago   209MB</span><br><span class="line">[root@local ~]# docker run -it  --name centos-nginx tanhao/my_nginx  /bin/bash  # 运行提交后的容器</span><br></pre></td></tr></table></figure><h3 id="制作好的镜像可以上传官网"><a href="#制作好的镜像可以上传官网" class="headerlink" title="制作好的镜像可以上传官网"></a>制作好的镜像可以上传官网</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker login https:hub.docker.com</span><br><span class="line">docker tag c40cd4ab1240 docker.io/myname/mynginx　　　　　　#打标签</span><br><span class="line">docker push docker.io/myname/mynginx</span><br></pre></td></tr></table></figure><h1 id="Docker-Dockerfile创建镜像的方法（推荐docker-file这种方法）"><a href="#Docker-Dockerfile创建镜像的方法（推荐docker-file这种方法）" class="headerlink" title="Docker Dockerfile创建镜像的方法（推荐docker file这种方法）"></a>Docker Dockerfile创建镜像的方法（推荐docker file这种方法）</h1><h2 id="docker-file方法制作镜像"><a href="#docker-file方法制作镜像" class="headerlink" title="docker file方法制作镜像"></a>docker file方法制作镜像</h2><h3 id="什么是docker-file"><a href="#什么是docker-file" class="headerlink" title="什么是docker file"></a>什么是docker file</h3><p>用来全自动构建镜像文件，命名为Dockerfile</p><h3 id="Dockerfile-文件编写指令及语法"><a href="#Dockerfile-文件编写指令及语法" class="headerlink" title="Dockerfile 文件编写指令及语法"></a>Dockerfile 文件编写指令及语法</h3><p><a href="https://blog.huixing.org/introduction-to-docker-instructions/">https://blog.huixing.org/introduction-to-docker-instructions/</a></p><h3 id="实战编写"><a href="#实战编写" class="headerlink" title="实战编写"></a>实战编写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# vi Dockerfile </span><br><span class="line">#this is docker file for centos-nginx</span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER th  &lt;victor@docker.com&gt;</span><br><span class="line">RUN yum install wget -y</span><br><span class="line">RUN rpm -ivh https://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line">RUN yum install nginx -y</span><br><span class="line">ADD index.html /usr/share/nginx/html/index.html</span><br><span class="line">RUN echo &quot;daemon off;&quot;&gt;&gt;/etc/nginx/nginx.conf</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [&quot;nginx&quot;]</span><br></pre></td></tr></table></figure><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>语法<br><code>docker build [OPTIONS] PATH | URL | -</code></p><p>完整过程我就不贴了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker build -t tanhao/nginx1 .          </span><br><span class="line">Sending build context to Docker daemon  311.8kB</span><br><span class="line">Step 1/9 : FROM centos</span><br><span class="line"> ---&gt; 300e315adb2f</span><br><span class="line">Step 2/9 : MAINTAINER zxg  &lt;victor@docker.com&gt;</span><br><span class="line"> ---&gt; Running in e7547fa54cc6</span><br><span class="line">Removing intermediate container e7547fa54cc6</span><br><span class="line"> ---&gt; f192af41dbef</span><br><span class="line">Step 3/9 : RUN yum install wget -y</span><br><span class="line"></span><br><span class="line">[root@local ~]# docker images</span><br><span class="line">REPOSITORY      TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">tanhao/nginx1   latest    7f8119f7c460   12 seconds ago   368MB</span><br></pre></td></tr></table></figure><h3 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker run -d --name my_nginx1 tanhao/nginx1 #后台运行整个容器</span><br><span class="line">55cae2283e289bb8f2a30d354930ba0765c476c51bc6b89b1a99060177f7491d</span><br><span class="line">[root@local ~]# docker exec -it my_nginx1 bash #进入容器</span><br><span class="line">[root@55cae2283e28 /]# cat /usr/share/nginx/html/index.html #查看文件是否添加到容器</span><br><span class="line">hahahaha</span><br><span class="line">[root@55cae2283e28 /]# curl 127.0.0.1 #查看nginx是否正常</span><br><span class="line">hahahaha</span><br></pre></td></tr></table></figure><p>容器外查看一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@local ~]# docker inspect my_nginx1 |grep IPAddress</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">[root@local ~]# curl 172.17.0.3</span><br><span class="line">hahahaha</span><br></pre></td></tr></table></figure><h1 id="Docker私库的搭建及常用方法"><a href="#Docker私库的搭建及常用方法" class="headerlink" title="Docker私库的搭建及常用方法"></a>Docker私库的搭建及常用方法</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>私库的好处有几点</p><ol><li>节约带宽</li><li>可以自己定制系统</li><li>更加安全</li></ol><h2 id="搭建私库的两种方法"><a href="#搭建私库的两种方法" class="headerlink" title="搭建私库的两种方法"></a>搭建私库的两种方法</h2><ol><li><p>利用官方提供的工具docker-registry来配置私库</p><p>官方提供的镜像，注意这个工具是个镜像，直接下载并使用registry镜像启动docker实例就可以了</p></li><li><p>利用Harbor-Registry，来搭建私库</p><p> Harbor是一个用于存储Docker镜像的企业级Registry服务</p></li></ol><h2 id="通过官方docker-registry来配置私库"><a href="#通过官方docker-registry来配置私库" class="headerlink" title="通过官方docker-registry来配置私库"></a>通过官方docker-registry来配置私库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# docker pull registry# 拉取registry</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/registry</span><br><span class="line">e95f33c60a64: Pull complete </span><br><span class="line">4d7f2300f040: Pull complete </span><br><span class="line">35a7b7da3905: Pull complete </span><br><span class="line">d656466e1fe8: Pull complete </span><br><span class="line">b6cb731e4f93: Pull complete </span><br><span class="line">Digest: sha256:da946ca03fca0aade04a73aa94b54ff0dc614216bdd1d47585f97b4c1bdaa0e2</span><br><span class="line">Status: Downloaded newer image for registry:latest</span><br><span class="line">docker.io/library/registry:latest</span><br><span class="line">[root@localhost yum.repos.d]# docker images# 查看</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">registry     latest    5c4008a25e05   2 weeks ago   26.2MB</span><br><span class="line">[root@localhost ~]# docker run -d -v registry -p 5000:5000 --restart=always --name registry registry:latest# 创建registry容器</span><br><span class="line">[root@localhost yum.repos.d]# curl http://127.0.0.1:5000/v2/</span><br><span class="line">&#123;&#125;# 查看registry容器状态</span><br></pre></td></tr></table></figure><p>接着我们使用docker push命令来推送自己的镜像到本地注册中心.<br>推送过程可能会不成功即出现下面这种情况getsocket:connection refused.</p><h2 id="通过harbor-registry方式来配置私库"><a href="#通过harbor-registry方式来配置私库" class="headerlink" title="通过harbor-registry方式来配置私库"></a>通过harbor-registry方式来配置私库</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-架构原理及简单使用&quot;&gt;&lt;a href=&quot;#Docker-架构原理及简单使用&quot; class=&quot;headerlink&quot; title=&quot;Docker 架构原理及简单使用&quot;&gt;&lt;/a&gt;Docker 架构原理及简单使用&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;了解docker的前生LXC&quot;&gt;&lt;a href=&quot;#了解docker的前生LXC&quot; class=&quot;headerlink&quot; title=&quot;了解docker的前生LXC&quot;&gt;&lt;/a&gt;了解docker的前生LXC&lt;/h3&gt;&lt;p&gt;LXC为Linux Container的简写。可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。相当于C++中的NameSpace。容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。&lt;br&gt;与传统虚拟化技术相比，它的优势在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与宿主机使用同一个内核，性能损耗小；&lt;/li&gt;
&lt;li&gt;不需要指令级模拟；&lt;/li&gt;
&lt;li&gt;不需要即时(Just-in-time)编译；&lt;/li&gt;
&lt;li&gt;容器可以在CPU核心的本地运行指令，不需要任何专门的解释机制；&lt;/li&gt;
&lt;li&gt;避免了准虚拟化和系统调用替换中的复杂性；&lt;/li&gt;
&lt;li&gt;轻量级隔离，在隔离的同时还提供共享机制，以实现容器与宿主机的资源共享。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结：Linux Container是一种轻量级的虚拟化的手段。&lt;/p&gt;
&lt;p&gt;Linux Container提供了在单一可控主机节点上支持多个相互隔离的server container同时执行的机制。Linux Container有点像chroot，提供了一个拥有自己进程和网络空间的虚拟环境，但又有别于虚拟机，因为lxc是一种操作系统层次上的资源的虚拟化。&lt;/p&gt;
&lt;h3 id=&quot;LXC与docker什么关系？&quot;&gt;&lt;a href=&quot;#LXC与docker什么关系？&quot; class=&quot;headerlink&quot; title=&quot;LXC与docker什么关系？&quot;&gt;&lt;/a&gt;LXC与docker什么关系？&lt;/h3&gt;&lt;p&gt;docker并不是LXC替代品，docker底层使用了LXC来实现，LXC将linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。&lt;/p&gt;
&lt;p&gt;在LXC的基础之上，docker提供了一系列更强大的功能。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Safari 手机版下载提示 Mobile Safari download issue : The operation couldn’t be completed. (webkitblobresource error 1.)</title>
    <link href="http://blog.huixing.org/mobile-safari-download-issue-the-operation-couldn-t-be-completed-webkitblobr/"/>
    <id>http://blog.huixing.org/mobile-safari-download-issue-the-operation-couldn-t-be-completed-webkitblobr/</id>
    <published>2020-11-16T02:11:55.000Z</published>
    <updated>2020-11-16T02:48:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周开发一个功能使用使用Blob</p><p>Safari 手机版下载提示 Mobile Safari download issue : The operation couldn’t be completed. (webkitblobresource error 1.)</p><p>示例:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function downloadFile(content, filename) &#123;</span><br><span class="line">    var blob = new Blob([content])</span><br><span class="line">    var url = window.URL.createObjectURL(blob)</span><br><span class="line">    var a = document.createElement(&#x27;a&#x27;)</span><br><span class="line">    a.style.display = &#x27;none&#x27;;</span><br><span class="line">    a.href = url</span><br><span class="line">    a.download = filename</span><br><span class="line">    document.body.appendChild(a);</span><br><span class="line">    a.click()</span><br><span class="line">    window.URL.revokeObjectURL(url);</span><br><span class="line">    document.body.removeChild(a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>查询Blob支持 Safari 6以上版本<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob">https://developer.mozilla.org/en-US/docs/Web/API/Blob</a></p><p>Blob 浏览器兼容性图</p><p><img src="https://i.loli.net/2020/11/16/QgReSIDBvosVTay.png" alt="浏览器兼容性图"></p><p>如果要以编程方式将ancor标记作为解决方案注入DOM，请确保不要过早地清除它。所以延迟一秒清除解决.</p><p>解决示例:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function downloadFile(content, filename) &#123;</span><br><span class="line">    var blob = new Blob([content])</span><br><span class="line">    var url = window.URL.createObjectURL(blob)</span><br><span class="line">    var a = document.createElement(&#x27;a&#x27;)</span><br><span class="line">    a.style.display = &#x27;none&#x27;;</span><br><span class="line">    a.href = url</span><br><span class="line">    a.download = filename</span><br><span class="line">    document.body.appendChild(a);</span><br><span class="line">    a.click()</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        window.URL.revokeObjectURL(url);</span><br><span class="line">        document.body.removeChild(a);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周开发一个功能使用使用Blob&lt;/p&gt;
&lt;p&gt;Safari 手机版下载提示 Mobile Safari download issue : The operation couldn’t be completed. (webkitblobresource error 1.)&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP MSSQL error code 0x2746 - SQLSTATE[08001]</title>
    <link href="http://blog.huixing.org/PHP-MSSQL-error-code-0x2746-SQLSTATE-08001/"/>
    <id>http://blog.huixing.org/PHP-MSSQL-error-code-0x2746-SQLSTATE-08001/</id>
    <published>2020-08-08T06:36:36.000Z</published>
    <updated>2020-08-08T06:45:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Linux下使用PHP连接SqlServer出现以下错误:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLSTATE[08001]: [Microsoft][ODBC Driver 17 for SQL Server]TCP Provider: Error code 0x2746</span><br></pre></td></tr></table></figure><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p><a href="https://github.com/microsoft/msphpsql/issues/1021">https://github.com/microsoft/msphpsql/issues/1021</a></p><h2 id="修复参考思路"><a href="#修复参考思路" class="headerlink" title="修复参考思路"></a>修复参考思路</h2><p><a href="https://wiki.debian.org/ContinuousIntegration/TriagingTips/openssl-1.1.1">https://wiki.debian.org/ContinuousIntegration/TriagingTips/openssl-1.1.1</a></p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>将<code>/etc/ssl/openssl.cnf</code>配置<code>CipherString</code>改为<code>DEFAULT@SECLEVEL=1</code></p><p>原配置<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[system_default_sect]</span><br><span class="line">MinProtocol = TLSv1.2</span><br><span class="line">CipherString = DEFAULT@SECLEVEL=2</span><br></pre></td></tr></table></figure><br>改后配置<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[system_default_sect]</span><br><span class="line">MinProtocol = TLSv1.2</span><br><span class="line">CipherString = DEFAULT@SECLEVEL=1</span><br></pre></td></tr></table></figure></p><h2 id="通过命令解决"><a href="#通过命令解决" class="headerlink" title="通过命令解决"></a>通过命令解决</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -E &#x27;s/(CipherString\s*=\s*DEFAULT@SECLEVEL=)2/\11/&#x27; /etc/ssl/openssl.cnf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在Linux下使用PHP连接SqlServer出现以下错误:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SQLSTATE[08001]: [Microsoft][ODBC Driver 17 for SQL Server]TCP Provider: Error code 0x2746&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/msphpsql/issues/1021&quot;&gt;https://github.com/microsoft/msphpsql/issues/1021&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;修复参考思路&quot;&gt;&lt;a href=&quot;#修复参考思路&quot; class=&quot;headerlink&quot; title=&quot;修复参考思路&quot;&gt;&lt;/a&gt;修复参考思路&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://wiki.debian.org/ContinuousIntegration/TriagingTips/openssl-1.1.1&quot;&gt;https://wiki.debian.org/ContinuousIntegration/TriagingTips/openssl-1.1.1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;解决方式&quot;&gt;&lt;a href=&quot;#解决方式&quot; class=&quot;headerlink&quot; title=&quot;解决方式&quot;&gt;&lt;/a&gt;解决方式&lt;/h2&gt;&lt;p&gt;将&lt;code&gt;/etc/ssl/openssl.cnf&lt;/code&gt;配置&lt;code&gt;CipherString&lt;/code&gt;改为&lt;code&gt;DEFAULT@SECLEVEL=1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;原配置&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[system_default_sect]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MinProtocol = TLSv1.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CipherString = DEFAULT@SECLEVEL=2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;改后配置&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[system_default_sect]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MinProtocol = TLSv1.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CipherString = DEFAULT@SECLEVEL=1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;通过命令解决&quot;&gt;&lt;a href=&quot;#通过命令解决&quot; class=&quot;headerlink&quot; title=&quot;通过命令解决&quot;&gt;&lt;/a&gt;通过命令解决&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何做选择?</title>
    <link href="http://blog.huixing.org/how-to-make-a-choice/"/>
    <id>http://blog.huixing.org/how-to-make-a-choice/</id>
    <published>2020-06-14T10:57:05.000Z</published>
    <updated>2020-06-14T12:21:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先引用一下美国著名诗人 罗伯特·弗罗斯特的一首诗叫&lt;&lt;未选择的路&gt;&gt;</p><blockquote><p>金黄色的树林里，分出两条路。可是我不能同时涉足啊。我在那久久伫立，我向着其中一条路极目望去，直到它消失在丛林的深处。但是，我却选择了另外一条路，留下一条路，等改日再见。但是我知道，路径延续无尽头的，恐怕我难以再回返。也许多少年后，在某个地方，我将轻声叹息，把往事回顾，一片树林，分出两条路，而我选择了其中人迹更少的一条，从此决定了我一生的道路。 —— 罗伯特 弗罗斯特</p></blockquote><p>在我们人生当中经常会遇到两条路或者多条路的选择,然后你很清楚选了一条其他的就和你没有关系了,你将在也没有机会走了上它了,这就是人生最大的尴尬.</p><p>这种困境是每个人都会遇到的共同困境.</p><p>有历史记载至少有两个人,一个是春秋时期的杨朱,另一个是魏晋南北朝的阮籍.这两个人一看到有分岔的路,一条通往南一条通往北,不知道该如何选择,而后临歧路而痛哭.</p><p>当今社会,一个人光每天吃什么就要面对至少200多种选择.</p><p>老人们,经常拉着我们的手说:男怕入错行,女怕嫁错郎.这种选择才是真真的麻烦,它会随着我们的选择影响我们一生啊!</p><h2 id="终局思维"><a href="#终局思维" class="headerlink" title="终局思维"></a>终局思维</h2><p>很多人说我们做选择要把目光放的够长远,怎么样才算是放的够长远呢?</p><p>阿里巴巴公司参谋长曾鸣教授提出来的叫”终局思维”</p><p>什么叫终局思维?</p><p>我们不要漫无目的的想什么长远,我们要道达的那个终点站是什么?把它想清楚,然后倒推回来,决定你当下,此刻的那个选择.</p><p>很多时候我们找工作面对两种不同的工作,不知道该如何选择?是选择钱多的还是选择离家进的?都不对,我们应该考虑这两份工作那一份我愿意干一辈子.</p><p>从终局触发,更容易做正确的选择.</p><p>比如我创业决定要干一件事情,咱先不组件团队,写项目计划书,这些先不忙,我们先干一件事情.什么事情呢?</p><p>假设这件事情干成了,我们向外界骄傲的开新闻发布会,请问这新闻稿怎么写?</p><p>等你写出来的那个时候这件事情成了嘛,你会骄傲的向全社会宣布,我为这个社会做了什么贡献,我有什么创新,这新闻稿里都有呀.然后拿新闻稿的亮点回推到现在然后决定干不干.如果你觉得这是我们好像没有能力干,好了,这件事情不用干了.还有一种可能,新闻稿写出来你会发现没有什么亮点,对社会没有什么贡献,那这个项目为什么还要干呢?</p><p>有一句话说的好,幸福的家庭都是类似的,那为什么幸福的家庭都是类似的呢?成功的人物方法都差不多,为什么都差不多?你想过这个问题没有?</p><p>很简单,人的终局是差不多的.</p><p>澳大利亚有一名护士叫布罗妮·瓦尔，多年来一直从事舒缓疗法护理工作，照顾生命仅余12周的病人。她将病人弥留之际的顿悟记录在自己的博客中，名为《人在弥留之际的五大憾事》。你不要小看这边文章,它不是普通的鸡汤,它是每一个人最后路口的那个路标.据我所知,硅谷的很多著名投资人,每隔几周就会翻出来这边文章看一下,对照一下自己的现在.</p><p>这就是要那些站在终点站的人的思考.来校正自己当下的行动.</p><h2 id="指南针"><a href="#指南针" class="headerlink" title="指南针"></a>指南针</h2><p>不知道你们小时候上学的时候有没有一个困惑,说中国有四大发明,发明了指南针.指南针不就是指个南吗?它也没告诉我们如何走?</p><p>那为什么那些森林里的探险家,那些航海家,那些船长,他们都需要一个指南针呢?</p><p>他们为什么不要地图呢?指南针有什么用?</p><p>这一点,胡适先生举例一个很好的例子,有一个人在丛林中迷了路,那可是莽莽苍苍的原始森林啊,怎么走?答案是找到你的指南针.我身上没有带指南针啊,原始森林里什么才是你的指南针呢?</p><p>胡适先生说:当然是水源.如果你找到了一眼活泉水,活泉水可以喝,可以活的长久一些,深林里面的小动物也需要水源,所以一旦找到了水,你就能获得食物.所以你活下来的概率会更大.</p><p>假设这个原始森林里面有个人和你一样迷了路,他这个时候在找什么?他也在找水,所以你们就能协作,走出来的概率就会大很多.</p><p>还有最重要的一点,一眼泉水,它流出来就变成了小溪,小溪一定会汇入小河,小河一定会流向大江,大江一定会走向大海.你只要顺着这个水走,你绝不会走回头路.你一定走的出来,而且你想过一个情景没有,当你走出这片原始森林的时候,你成功了,你活下来了,但是你画的出这个原始森林的路线图吗?你能再次指导其他人走出来吗?还是没有地图,人生大多数时候是没有地图的,情况随时在变的.只要手里有这么个指南针,你就很容易走出来.</p><p>所以指南针比地图重要.</p><p>所以什么是指南针,指南针看起来非常单调和枯燥,都指向同一个方向,从来不变.</p><p>在人生的选择当中,我们感受到的是剧烈的变化.但是真相是不变的东西比变的要重要.</p><p>有一个著名的哲学家,笛卡尔法国人,我们都知道他发明了解析几何.笛卡尔这辈子有两个大的特点.<br>第一身体不好,第二家里比较有钱,这个人就获得了一种机缘,就是一辈子就没别的事干,天天躺床上,想事情,然后有一天,据说,他看见一只蜘蛛在他面前绕来绕去,他就在想我怎么判定这个蜘蛛的位置呢?它那么地变动不居,后来他突然就想明白了,我这个屋子有竖的墙缝,还有两个墙角的线.这三条线构成了一个坐标.我只要随时测量这蜘蛛距离这三条线的距离,我就能标定它的位置啊.这不就是解析几何吗.</p><p>你看,把握一个变动的东西,你需要一些不变的东西,这种指南针在我们生活中随处都是,它只有一个特点,它不变,它和你当下选择看似没有关系.</p><p>举个例子：如果你要选择一本书，那你不妨假设这样一个场景，假设你的女儿今天出门旅行，行李箱已经塞满了，你要不要把这本书再给她塞进去？虽然这本书挺沉的，但是这本书你让闺女一定要看。对女儿的爱就是你的指南针。</p><h2 id="金丝雀"><a href="#金丝雀" class="headerlink" title="金丝雀"></a>金丝雀</h2><p>过去煤矿里面没有什么仪器，能够把瓦斯的浓度给检测出来。于是，有一批聪明的煤矿工人发现，金丝雀对于瓦斯气体及其敏感。所以他们在矿井里，只要发现金丝雀晕倒了，就赶紧撤退。</p><p>这个方法告诉我们：<strong>有些选择不要光想我们该怎么选，还要想什么是我绝对不能触碰的底线。用最具体的东西来衡量你的底线，并把它表达出来。</strong></p><p>老邻居请未来的女婿喝酒，就对小伙子说：“我对你什么要求都没有，但是我对你就俩要求：第一，不能赌钱；第二，你们俩吵架吵得再生气，你不能打她。”</p><p>看起来赌钱输了一点钱或者打一巴掌也不能怎么样，但事后你一定还会再犯，如果一直持续下去，这个家庭肯定不幸福。所以，这两条是老邻居的金丝雀，这是你绝对不能触碰的底线。</p><p>把这个方法放到生活中，我们就能理解为什么：普通人投资，绝不要用杠杆，也就是绝不能借钱投资。因为你只要有一次，就算你这次赚到了，下次你会成习惯的。常在河边走，总有一次你会湿了鞋。不要有例外，不能放杠杆投资，对于一个普通人的投资者来说，这就是你的金丝雀。</p><h2 id="白衬衫"><a href="#白衬衫" class="headerlink" title="白衬衫"></a>白衬衫</h2><p>所谓“白衬衫”，就是让你做一件事减少选择。越少的选择，你得到的才越多，更多的选择你就糊涂了。很多选择不管你在上面花多少心思，其实效果都差不多。</p><p>这个世界永远存在两种力量，一种是试图把你的选择变得越来越多，还有一种试图把你的选择变得越来越少。你发现没有？凡是好的东西，他们都是把你的选择变少。比如说普通的餐馆，他的菜单就极长，可是如果你去高档餐馆，你会发现它的菜单相对短。</p><p>所以，在这个社会想要活得好，两条原则：<strong>第一，减少你的选择，把你的注意力资源省下来用在你最擅长的事情上；第二条，把那些不做的选择交给那些更加专业的人士，很多事情是不值得选的。</strong></p><p>那什么事情才是值得选的呢？<strong>只有一样东西，就是和什么人在一起！</strong></p><p>你在什么样的环境里，跟什么样的人在一起，你会受到他的巨大影响，这是对人生影响无比重大的事情。所以表面上看，我们做的是什么重大选择：上什么大学，选什么专业，进什么公司，和谁结婚……其实本质上都一样，你在选择我进入什么样的环境，跟什么样的人在一起，这是人生最大的变量。</p><p>有一段文字，是这么说的：人生很多重要的选择关头，上什么学校，选什么专业，进哪家公司，和谁过一辈子……这些重要的选择在真做选择的那一天，我们往往会觉得很平淡，在那天的日记上甚至都未必会把它写下来。但是，正是这样一些惊心动魄的选择，决定了我们的一生。</p><p><strong>人生是有一个定义的，你现在的人生其实就是你此前所有选择的总和。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先引用一下美国著名诗人 罗伯特·弗罗斯特的一首诗叫&amp;lt;&amp;lt;未选择的路&amp;gt;&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;金黄色的树林里，分出两条路。可是我不能同时涉足啊。我在那久久伫立，我向着其中一条路极目望去，直到它消失在丛林的深处。但是，我却选择了另外一条路，留下一条路，等改日再见。但是我知道，路径延续无尽头的，恐怕我难以再回返。也许多少年后，在某个地方，我将轻声叹息，把往事回顾，一片树林，分出两条路，而我选择了其中人迹更少的一条，从此决定了我一生的道路。 —— 罗伯特 弗罗斯特&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我们人生当中经常会遇到两条路或者多条路的选择,然后你很清楚选了一条其他的就和你没有关系了,你将在也没有机会走了上它了,这就是人生最大的尴尬.&lt;/p&gt;
&lt;p&gt;这种困境是每个人都会遇到的共同困境.&lt;/p&gt;
&lt;p&gt;有历史记载至少有两个人,一个是春秋时期的杨朱,另一个是魏晋南北朝的阮籍.这两个人一看到有分岔的路,一条通往南一条通往北,不知道该如何选择,而后临歧路而痛哭.&lt;/p&gt;
&lt;p&gt;当今社会,一个人光每天吃什么就要面对至少200多种选择.&lt;/p&gt;
&lt;p&gt;老人们,经常拉着我们的手说:男怕入错行,女怕嫁错郎.这种选择才是真真的麻烦,它会随着我们的选择影响我们一生啊!&lt;/p&gt;
&lt;h2 id=&quot;终局思维&quot;&gt;&lt;a href=&quot;#终局思维&quot; class=&quot;headerlink&quot; title=&quot;终局思维&quot;&gt;&lt;/a&gt;终局思维&lt;/h2&gt;&lt;p&gt;很多人说我们做选择要把目光放的够长远,怎么样才算是放的够长远呢?&lt;/p&gt;
&lt;p&gt;阿里巴巴公司参谋长曾鸣教授提出来的叫”终局思维”&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL GTID详解</title>
    <link href="http://blog.huixing.org/mysql-gtid/"/>
    <id>http://blog.huixing.org/mysql-gtid/</id>
    <published>2020-06-10T08:40:44.000Z</published>
    <updated>2021-03-11T10:45:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GTID介绍"><a href="#GTID介绍" class="headerlink" title="GTID介绍"></a>GTID介绍</h1><h2 id="GTID概念"><a href="#GTID概念" class="headerlink" title="GTID概念"></a>GTID概念</h2><p>GTID（ Global Transaction Identifier）全局事务标识，由主库上生成的与事务绑定的唯一标识，这个标识不仅在主库上是唯一的，在MySQL集群内也是唯一的。GTID是 MySQL 5.6 版本引入的一个有关于主从复制的重大改进，相对于之前版本基于Binlog文件+Position的主从复制，基于GTID的主从复制，数据一致性更高，主从数据复制更健壮，主从切换、故障切换不易出错，很少需要人为介入处理。</p><p>划重点:</p><ol><li>全局事务表示(Global Transaction ID)</li><li>GTID与事务一一对应,并且全局唯一ID.</li><li>一个GTID在一个服务器上执行一次.</li><li>MySQL 5.6.5开始支持GTID.</li></ol><h2 id="GTID特点"><a href="#GTID特点" class="headerlink" title="GTID特点"></a>GTID特点</h2><ol><li>事务提交产生GTID，GTID与事务及事务提交所在的节点绑定，GTID与事务一起写入Binlog，但是从库应用Binlog并不会生成新的GTID。</li><li>集群中的任何一个节点，根据其GTID值就可以知道哪些事务已经执行，哪些事务没有执行，如果发现某个GTID已执行，重复执行该GTID，将会被忽略，即同一个GTID只能被应用一次。</li><li>当一个连接执行一个特定GTID的事务，但是还没有提交，此时有另外一个连接也要执行相同GTID的事务，那么第二个连接的执行将会被阻塞，直到第一个事务提交或者回滚。如果第一个事务成功提交，第二个事务将会被忽略。如果第一个事务回滚，第二个事务正常执行。</li></ol><h3 id="GTID组成"><a href="#GTID组成" class="headerlink" title="GTID组成"></a>GTID组成</h3><p>GTID = server_uuid:transaction+id</p><p>查看server_uuid:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@a84d983d7d50:/var/lib/mysql# more auto.cnf </span><br><span class="line">[auto]</span><br><span class="line">server-uuid=59fd3bd6-a6da-11ea-91d7-0242ac110003</span><br></pre></td></tr></table></figure></p><h2 id="GTID和binlog的关系"><a href="#GTID和binlog的关系" class="headerlink" title="GTID和binlog的关系"></a>GTID和binlog的关系</h2><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfnalq0k0uj20do0btq4m.jpg" alt="GTID和binlog的关系"></p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfnapf7ij3j21mg0907dz.jpg" alt="GTID event 结构"></p><p>Previous_gtid_log_event 在每个binlog 头部都会有每次binlog rotate的时候存储在binlog头部Previous-GTIDs在binlog中只会存储在这台机器上执行过的所有binlog，不包括手动设置gtid_purged值。换句话说，如果你手动set global gtid_purged=xx； 那么xx是不会记录在Previous_gtid_log_event中的。</p><p>假设有4个binlog: bin.001,bin.002,bin.003,bin.004</p><ul><li>bin.001 : Previous-GTIDs=empty; binlog_event有: 1-40</li><li>bin.002 : Previous-GTIDs=1-40; binlog_event有: 41-80</li><li>bin.003 : Previous-GTIDs=1-80; binlog_event有: 81-120</li><li>bin.004 : Previous-GTIDs=1-120; binlog_event有: 121-160</li></ul><p><strong>GTID和Binlog之间的关系是怎么对应的呢? 如何才能找到GTID=? 对应的binlog文件呢？</strong></p><p>假设现在我们要找GTID=$A，那么MySQL的扫描顺序为:</p><ul><li>从最后一个binlog开始扫描（即: bin.004）</li><li>bin.004的Previous-GTIDs=1-120，如果$A=140 &gt; Previous-GTIDs,那么肯定在bin.004中</li><li>bin.004的Previous-GTIDs=1-120，如果$A=88 包含在Previous-GTIDs中,那么继续对比上一个binlog文件 bin.003,然后再循环前面2个步骤，直到找到为止.</li></ul><h2 id="GTID的复制协议"><a href="#GTID的复制协议" class="headerlink" title="GTID的复制协议"></a>GTID的复制协议</h2><ol><li>从服务器向主服务器发送已经执行过的GTID.</li><li>主服务器将所有其他GTID发送给从服务器.</li><li>同样的GTID不能被执行两次,如果有同样的GTID,会自动跳过.</li></ol><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfnbink7anj20gp0bjjv3.jpg" alt="COM_BINLOG_DUMP_GTID"></p><h2 id="传统复制与GTID对比"><a href="#传统复制与GTID对比" class="headerlink" title="传统复制与GTID对比"></a>传统复制与GTID对比</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;GTID介绍&quot;&gt;&lt;a href=&quot;#GTID介绍&quot; class=&quot;headerlink&quot; title=&quot;GTID介绍&quot;&gt;&lt;/a&gt;GTID介绍&lt;/h1&gt;&lt;h2 id=&quot;GTID概念&quot;&gt;&lt;a href=&quot;#GTID概念&quot; class=&quot;headerlink&quot; title=&quot;GTID概念&quot;&gt;&lt;/a&gt;GTID概念&lt;/h2&gt;&lt;p&gt;GTID（ Global Transaction Identifier）全局事务标识，由主库上生成的与事务绑定的唯一标识，这个标识不仅在主库上是唯一的，在MySQL集群内也是唯一的。GTID是 MySQL 5.6 版本引入的一个有关于主从复制的重大改进，相对于之前版本基于Binlog文件+Position的主从复制，基于GTID的主从复制，数据一致性更高，主从数据复制更健壮，主从切换、故障切换不易出错，很少需要人为介入处理。&lt;/p&gt;
&lt;p&gt;划重点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局事务表示(Global Transaction ID)&lt;/li&gt;
&lt;li&gt;GTID与事务一一对应,并且全局唯一ID.&lt;/li&gt;
&lt;li&gt;一个GTID在一个服务器上执行一次.&lt;/li&gt;
&lt;li&gt;MySQL 5.6.5开始支持GTID.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;GTID特点&quot;&gt;&lt;a href=&quot;#GTID特点&quot; class=&quot;headerlink&quot; title=&quot;GTID特点&quot;&gt;&lt;/a&gt;GTID特点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;事务提交产生GTID，GTID与事务及事务提交所在的节点绑定，GTID与事务一起写入Binlog，但是从库应用Binlog并不会生成新的GTID。&lt;/li&gt;
&lt;li&gt;集群中的任何一个节点，根据其GTID值就可以知道哪些事务已经执行，哪些事务没有执行，如果发现某个GTID已执行，重复执行该GTID，将会被忽略，即同一个GTID只能被应用一次。&lt;/li&gt;
&lt;li&gt;当一个连接执行一个特定GTID的事务，但是还没有提交，此时有另外一个连接也要执行相同GTID的事务，那么第二个连接的执行将会被阻塞，直到第一个事务提交或者回滚。如果第一个事务成功提交，第二个事务将会被忽略。如果第一个事务回滚，第二个事务正常执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;GTID组成&quot;&gt;&lt;a href=&quot;#GTID组成&quot; class=&quot;headerlink&quot; title=&quot;GTID组成&quot;&gt;&lt;/a&gt;GTID组成&lt;/h3&gt;&lt;p&gt;GTID = server_uuid:transaction+id&lt;/p&gt;
&lt;p&gt;查看server_uuid:&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;root@a84d983d7d50:/var/lib/mysql# more auto.cnf &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[auto]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server-uuid=59fd3bd6-a6da-11ea-91d7-0242ac110003&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL主从复制</title>
    <link href="http://blog.huixing.org/mysql-master-slave-replication/"/>
    <id>http://blog.huixing.org/mysql-master-slave-replication/</id>
    <published>2020-06-05T06:39:30.000Z</published>
    <updated>2020-06-10T07:58:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h1><p>MySQL中的主从复制是将数据从一端(通常称为Master,即主库)复制到另一端(通常称为Slave,即从库).</p><p>MySQL的复制特性操作很灵活,即可以实现整个服务级别的复制,也可以只复制某一个数据库,甚至某个数据库中的某个表对象;</p><ul><li>主从单向复制(即可以实现从A复制到B)</li><li>单主多从复制(B在复制到C,也可以实现A直接复制到B和C)</li><li>双主复制(甚至是A的数据复制给B,B的数据也复制回A)</li></ul><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfheym1grdj20hj07c3yp.jpg" alt="一主多从架构与双主双从架构"></p><p>服务器间复制数据有很多种解决方案,究竟哪种方案最适合,取决于使用的数据引擎和期望实现的复制需求.一般来说,可以将MySQL的复制特性应用在下来场景上:</p><ul><li>实时灾备,用于故障切换</li><li>读写分离,提供查询服务</li><li>备份</li><li>延时库</li></ul><h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><p>由于MySQL安装方式 网上很多教程 这里就不重复写了</p><ul><li>运行环境 CentOS 7.5 </li><li>数据库环境 MySQL 5.7.30</li></ul><h2 id="1-Master端启用二进制日志-binlog-指定mysql服务全局唯一server-id"><a href="#1-Master端启用二进制日志-binlog-指定mysql服务全局唯一server-id" class="headerlink" title="1. Master端启用二进制日志(binlog),指定mysql服务全局唯一server_id"></a>1. Master端启用二进制日志(binlog),指定mysql服务全局唯一server_id</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id,注意要唯一</span><br><span class="line">server-id=1</span><br><span class="line">## 开启二进制日志功能</span><br><span class="line">log-bin=mysql-bin</span><br></pre></td></tr></table></figure><h2 id="2-Slave端启用二进制日志-binlog-指定mysql服务全局唯一server-id-指定中继日志文件路径"><a href="#2-Slave端启用二进制日志-binlog-指定mysql服务全局唯一server-id-指定中继日志文件路径" class="headerlink" title="2. Slave端启用二进制日志(binlog),指定mysql服务全局唯一server_id,指定中继日志文件路径"></a>2. Slave端启用二进制日志(binlog),指定mysql服务全局唯一server_id,指定中继日志文件路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id,注意要唯一</span><br><span class="line">server-id=2 </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span><br><span class="line">log-bin=mysql-slave-bin   </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=edu-mysql-relay-bin </span><br></pre></td></tr></table></figure><h2 id="3-创建Slave同步专用账户"><a href="#3-创建Slave同步专用账户" class="headerlink" title="3. 创建Slave同步专用账户"></a>3. 创建Slave同步专用账户</h2><p>在Master数据库创建数据同步用户，授予用户 slave REPLICATION SLAVE权限和REPLICATION CLIENT权限，用于在主从库之间同步数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;root&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><h2 id="4-链接Master-主-和Slave-从"><a href="#4-链接Master-主-和Slave-从" class="headerlink" title="4. 链接Master(主)和Slave(从)"></a>4. 链接Master(主)和Slave(从)</h2><p>在Master进入mysql，执行<code>show master status</code>;</p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfhhepz9r4j20jt03gglj.jpg" alt="Master Status"></p><p>File和Position字段的值后面将会用到，在后面的操作完成之前，需要保证Master库不能做任何操作，否则将会引起状态变化，File和Position字段的值变化。</p><p>在Slave中进入mysql,执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&#x27;172.17.0.2&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;root&#x27;, master_port=3306, master_log_file=&#x27;mysql-bin.000003&#x27;, master_log_pos= 804, master_connect_retry=30;</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li>master_host：Master MySQL的地址，如果用Docker指的是容器的独立ip,可以通过<code>docker inspect --format=&#39;&#123; &#123;.NetworkSettings.IPAddress&#125;&#125;&#39;</code> 容器名称|容器id查询容器的ip</li><li>master_port：Master的端口号，指的是容器的端口号</li><li>master_user：用于数据同步的用户</li><li>master_password：用于同步的用户的密码</li><li>master_log_file：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值</li><li>master_log_pos：从哪个 Position 开始读，即上文中提到的 Position 字段的值</li><li>master_connect_retry：如果连接失败，重试的时间间隔，单位是秒，默认是60秒</li></ul><p>在Slave 中的mysql终端执行<code>show slave status \G;</code>用于查看主从同步状态。</p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfhgt59cbbj20fg0r975q.jpg" alt="Slave未同步状态"><br>正常情况下，SlaveIORunning 和 SlaveSQLRunning 都是No，因为我们还没有开启主从复制过程。使用start slave开启主从复制过程，然后再次查询主从同步状态<code>show slave status \G;</code>。<br><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfhgtjx15ij20j30s5gna.jpg" alt="Slave同步状态"><br>SlaveIORunning 和 SlaveSQLRunning 都是Yes，说明主从复制已经开启。此时可以测试数据同步是否成功。</p><p>我们再看一下线程:<br><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfhgkm7wxfj21jg09yjtp.jpg" alt="Master进程"><br><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfhgmbu1h4j21na0bswhn.jpg" alt="Slave进程"></p><h2 id="5-排错"><a href="#5-排错" class="headerlink" title="5. 排错"></a>5. 排错</h2><p>使用start slave开启主从复制过程后，如果SlaveIORunning一直是Connecting，则说明主从复制一直处于连接状态，这种情况一般是下面几种原因造成的，我们可以根据 Last_IO_Error提示予以排除。</p><ol><li>网络不通 检查ip,端口</li><li>密码不对 检查是否创建用于同步的用户和用户密码是否正确</li><li>pos不对 检查Master的 Position</li></ol><h2 id="6-测试主从复制"><a href="#6-测试主从复制" class="headerlink" title="6. 测试主从复制"></a>6. 测试主从复制</h2><p>测试主从复制方式就十分多了，最简单的是在Master创建一个数据库，然后检查Slave是否存在此数据库。</p><p>Master:</p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfhgouuvl3j208v06l3yh.jpg" alt="Master"></p><p>Slave:</p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfhgpkbolkj207605g0sm.jpg" alt="Slave"></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul><li>show processlist;–显示用户正在运行的线程</li><li>show slave status;–显示slave状态</li><li>show slave hosts;–显示slave地址信息</li><li>start slave;–开始slave同步</li><li>stop slave;–停止slave同步</li><li>start slave io_thread;–开始slave io线程</li><li>start slave sql_thrad;–开始slave sql线程</li><li>stop slave io_thread;–停止slave io线程</li><li>stop slave sql_thrad;–停止slave sql线程</li></ul><h1 id="复制关键因素及原理"><a href="#复制关键因素及原理" class="headerlink" title="复制关键因素及原理"></a>复制关键因素及原理</h1><h2 id="复制格式"><a href="#复制格式" class="headerlink" title="复制格式"></a>复制格式</h2><p>复制格式和二进制日志格式本质上是一个东西,只是在不同场景下称谓不同,都由系统变量binlog_format控制.</p><p>二进制日志格式:</p><ol><li>基于语句记录(Statement-Based Logging, SBL),对应的参数值为statement.二进制日志文件中保存的是执行过的SQL语句.</li><li>基于行格式记录(Row-Based Loging, RBL),对应的参数值为row.二进制日志文件中记录的是变更行的信息.</li><li>混合模式(Mixed-Based Loging. MBL),对应的参数值为mixed.在记录事件到二进制日志时,MySQL服务根据需要,动态修改日志记录的格式.</li></ol><p>复制格式:</p><ol><li>基于语句复制(Statement-Based Replication, SBR)</li><li>基于行复制(Row-Based Replication, RBR)</li><li>混合记录模式(Mixed-Based Replication. MBR)</li></ol><p>SBR优点:</p><ol><li>生成日志少.</li><li>可读性高 mysqlbinlog.<br>SBR缺点:</li><li>不严谨,如SQL语句包含new()等函数 复制到从库就会出现时间不一致.</li><li>执行insert select 语句时需要持有更多的锁(相比RBR)锁多相当于并发性低.</li><li>对于InnoDB引擎,insert语句使用AUTO_INCREMENT会阻塞其他insert语句.</li></ol><p>RBR优点:</p><ol><li>所有修改都能被安全的复制到Slave节点.</li><li>Master端执行修改操作时,仅需要极少的锁,可以获得更高的并发性.</li><li>Slave节点执行增删改时也仅需要有少量锁.<br>RBR缺点:</li><li>可能会生成更多的日志.</li><li>日志可读性减低 mysqlbinlog.</li><li>对于非事务存储引擎,比如MyISAM表对象,Slave节点应用insert操作时,使用RBR模式要比使用SBR模式持有更强的锁</li></ol><p>场景1:</p><p>有条复杂的SQL语句,在Master节点执行10分钟,最终成功修改了1一条记录.</p><ul><li>采用SBR模式,二进制日志中记录的事件就是这条SQL语句,那么,这个记录被复制到Slave节点后,也要执行10分钟.</li><li>采用RBR模式,不管Master节点执行了多长时间,最终变更记录只有一条,那么二进制日志中记录的事件就这一条记录的更新,日志被同步到Slave节点后,瞬间就会被执行完.</li></ul><p>场景2:</p><p>有一条简单的SQL语句,在Master节点执行时,要更新一千万条记录.</p><ul><li>采用RBR模式,这一千万条记录会生成较大的二进制日志文件,数据在网络传输过程就要消耗一定时间,Slave接收完数据,还要花费相当长的时间慢慢应用到库中.</li><li>采用SBR模式,二进制日志文件中就记录了该SQL语句,Slave节点可以迅速接收改语句,然后再执行,执行可能消耗一定时间,单总体时间开销还是要比RBR小.</li></ul><p><strong>看完上面两个场景,相信读者已经有自己的选择了.但是在生成环境中强烈建议使用RBR模式(基于行复制),因为稳定.稳定压倒一切</strong></p><p>查看binlog格式<code>show variables like &quot;binlog_format&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;binlog_format&quot;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="中继日志文件和状态文件"><a href="#中继日志文件和状态文件" class="headerlink" title="中继日志文件和状态文件"></a>中继日志文件和状态文件</h2><p>MySQL数据中有二进制日志文件,用于记录所有执行的变更事件,复制特性正是基于这类文件实现”复制”操作.Slaves节点中有两个线程,其中IO_THREAD线程用于接收和保存二进制日志,IO_THREAD将接收二进制日志就保存在本端的中继日志中.</p><p>通过<code>show variables like &quot;%relay%&quot;;</code>查看中继日志文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%relay%&quot;;</span><br><span class="line">+---------------------------+------------------------------------------+</span><br><span class="line">| Variable_name             | Value                                    |</span><br><span class="line">+---------------------------+------------------------------------------+</span><br><span class="line">| max_relay_log_size        | 0                                        |</span><br><span class="line">| relay_log                 | edu-mysql-relay-bin                      |</span><br><span class="line">| relay_log_basename        | /var/lib/mysql/edu-mysql-relay-bin       |</span><br><span class="line">| relay_log_index           | /var/lib/mysql/edu-mysql-relay-bin.index |</span><br><span class="line">| relay_log_info_file       | relay-log.info                           |</span><br><span class="line">| relay_log_info_repository | FILE                                     |</span><br><span class="line">| relay_log_purge           | ON                                       |</span><br><span class="line">| relay_log_recovery        | OFF                                      |</span><br><span class="line">| relay_log_space_limit     | 0                                        |</span><br><span class="line">| sync_relay_log            | 10000                                    |</span><br><span class="line">| sync_relay_log_info       | 10000                                    |</span><br><span class="line">+---------------------------+------------------------------------------+</span><br><span class="line">11 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><ul><li>relay_log_index 中继日志索引文件</li><li>relay_log_basename 中继日志文件保存路径</li><li>relay_log_info_file 中继日志状态</li><li>max_relay_log_size 中继日志最大值</li></ul><p>中继日志和binlog日志相同可以mysqlbinlog操作</p><p>Slaves节点会在瞒足下列条件时,触发创建新的中继日志文件:</p><ol><li>启动Slaves节点IO线程时</li><li>执行日志刷新命令 <code>flush logs</code></li><li>中继日志文件达到指定最大值时<ul><li>如果max_relay_log_size参数值大于0,则日志文件超过该值后即会重建</li><li>如果max_relay_log_size参数值等于0,则通过max_binlog_size确定单个中继日志文件最大值</li></ul></li></ol><p>通过<code>show variables like &quot;max_binlog_size&quot;;</code>查看binlog文件最大值<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;max_binlog_size&quot;; </span><br><span class="line">+-----------------+------------+</span><br><span class="line">| Variable_name   | Value      |</span><br><span class="line">+-----------------+------------+</span><br><span class="line">| max_binlog_size | 1073741824 |</span><br><span class="line">+-----------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>状态文件:<br>复制环境中Slave节点会创建两个状态文件:既master.info和relay-log.info,这两个文件默认保存在data目录,可以通过–master-info-file和–relay-log-info-file参数修改文件和保存路径.</p><p>master.info和relay-log.info均来自<code>show slave status</code>里面的信息刷新到这些文件中.</p><ul><li>IO_THREAD会读取master.info信息</li><li>SQL_THREAD会读取relay-log.info信息</li></ul><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfhm6k92p5j20ub0bmn27.jpg" alt="复制原理"></p><h1 id="高级应用技巧"><a href="#高级应用技巧" class="headerlink" title="高级应用技巧"></a>高级应用技巧</h1><h2 id="复制过滤规则"><a href="#复制过滤规则" class="headerlink" title="复制过滤规则"></a>复制过滤规则</h2><h3 id="Master端"><a href="#Master端" class="headerlink" title="Master端:"></a>Master端:</h3><ul><li><code>binlog-do-db</code> 指定对某数据库的操作事件被记录.</li><li><code>binlog-ignore-db</code> 指定对某数据库的操作事件不被记录</li><li><code>set sql_log_bin=0</code> 会话级别所做操作不被记录</li></ul><p><strong>在Master端进行复制过滤会导致主服务器上的二进制日志记录不完整,一旦主服务器崩溃将无法做到还原所有数据</strong></p><h3 id="Slave端"><a href="#Slave端" class="headerlink" title="Slave端:"></a>Slave端:</h3><p>Slave节点在接收日志时没有选择权,Master节点写过的日志它全部接收到本地,保存在中继日志文件中.但Slave节点在应用哪些数据库哪些表时具有选择器权限.MySQL提供了一系列参数用于Slave节点定义过滤规则.</p><ul><li><code>replicate-do-db=name</code> 执行name表</li><li><code>replicate-ignore-db=name</code> 忽略name表</li><li><code>replicate-do-table=name</code> 执行name库</li><li><code>replicate-ignore-table=name</code> 忽略name库</li><li><code>replicate-wild-do-table=foo%.bar%</code> 执行以foo开头的库以bar开头的表</li><li><code>replicate-wild-ignore-table=foo%.bar%</code> 忽略以foo开头的库以bar开头的表</li></ul><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>配置文件</p><p>按照上面列的<code>replicate-do-db=表名</code>即可</p><p>数据库配置</p><p>指定复制某一个或多个库<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STOP SLAVE SQL_THREAD; # 停止SQL线程</span><br><span class="line">CHANGE REPLICATION FILTER REPLICATE_DO_BD = (表名1,表名2)</span><br><span class="line">START SLAVE SQL_THREAD; # 启动SQL线程</span><br></pre></td></tr></table></figure><br>通过上面设置方式可以看出 <code>CHANGE REPLICATION FILTER</code> 加上上面列的选项即可实现配置</p><p>取消复制限制</p><p><code>CHANGE REPLICATION FILTER REPLICATE_DO_BD = ();</code>同上</p><p>切记一定要停止SQL线程后再设置</p><h2 id="半同步机制"><a href="#半同步机制" class="headerlink" title="半同步机制"></a>半同步机制</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MySQL在5.5版本之前,一直采用的是异步复制的方式.主库的事务执行不会管备库的同步进度,如果备库落后,主库不幸crash,那么就会导致数据丢失.</p><p>MySQL在5.5版本中引入了半同步复制,主库在答应客户端提交的事务钱需要保证至少一个从库收到并写到relay log中,但性能比较差.</p><p>MySQL在5.6版本中增强了半同步</p><p>MySQL在5.7版本比较完善(在5.7.2无损复制)</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>默认情况下,MySQL的复制是异步的,主库执行完Commit提交操作后,在主库写入binlog后即可成功返回给客户端,无需等待binlog传给从库.当在主库上写入一个事务并提交成功,而从库尚未得到主库的binlog时,主机宕机了,从而从库可能损失该事务,造成主从库的不一致.</p><p>为了解决这个问题,MySQL引入了半同步复制.半同步复制保证了主库上的每一个binlog都能可靠的复制到从库上,主库在每次事务提交时,并不及时反馈给前端用户,而是等待其中一个从库也接收到binlog并成功写入中继日志后,主库才返回给客户端.此时,至少有两份日志记录,一份在主库binlog上,另一方在至少一个从库的中继日志上,从而保证了数据的完整性.</p><h3 id="半同步复制机制的改进"><a href="#半同步复制机制的改进" class="headerlink" title="半同步复制机制的改进"></a>半同步复制机制的改进</h3><p>MySQL 5.7.2版本增加了<code>rpl_semi_sync_master_wait_point</code>参数,该参数有两个值:<code>AFTER_COMMIT</code>和<code>AFTER_SYNC</code>.</p><h4 id="AFTER-COMMIT-半同步复制-5-6默认该模式"><a href="#AFTER-COMMIT-半同步复制-5-6默认该模式" class="headerlink" title="AFTER_COMMIT 半同步复制(5.6默认该模式)"></a>AFTER_COMMIT 半同步复制(5.6默认该模式)</h4><p>Master将每个事务写入binlog(sync_binlog=1),传递到slave刷新到磁盘(sysnc_relay=1),同时主库提交事务.Master等待Slave反馈收到relay_log,只有收到ACK后Master才将commit ok结果反馈给客户端.<br><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfm18gfia3j20h40aqwfn.jpg" alt="After Commit"></p><p>在使用AFTER_COMMIT的模式下,客户端事务在存储引擎成提交后,在得到从库确认的过程中,主库宕机了.此时,既主库在等待Slave ACK的时候,虽然没有返回当前客户端,但是事务已经提交,其他客户端会读取到已提交事务.如果Slave端还没有读取到该事务的events,同时主库发生了crash,然后切换到备库.那么之前读取到的事务就不见了,出现幻读.<br><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfm18z3l64j20db0dtjsp.jpg" alt="出现幻读情况图"></p><h4 id="AFTER-SYNC-无损复制-5-7默认该模式-5-6没有该模式"><a href="#AFTER-SYNC-无损复制-5-7默认该模式-5-6没有该模式" class="headerlink" title="AFTER_SYNC 无损复制(5.7默认该模式,5.6没有该模式)"></a>AFTER_SYNC 无损复制(5.7默认该模式,5.6没有该模式)</h4><p>Master将每个事务写入binlog,传递到Slave刷新到磁盘(relay log).Master等待Slave反馈接收到relay log的ACK之后,再提交事务并且返回commit ok 结果给客户端.<br><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfm19bcfouj20h80akq43.jpg" alt="After Sync"></p><h3 id="半同步复制与无损复制的对比"><a href="#半同步复制与无损复制的对比" class="headerlink" title="半同步复制与无损复制的对比"></a>半同步复制与无损复制的对比</h3><ol><li>ACK的时间点不同:<ul><li>一个先engine commit后再接收ACK</li><li>一个在接收ACK后在engine commit</li></ul></li><li>主从数据一致性<ul><li>半同步复制意味着在Master节点上,这个刚刚提交的事务对数据库的修改,对其他事务是可见的.因此,如果在等待Slave ACK的时候crash了,那么会对其他事务出现幻读,数据丢失.</li><li>无损复制在write binlog完成后,就传输binlog,但还没有去写commit log,意味着当前这个事务对数据库的修改,其他事务也是不可以见的.因此,不会出现幻读,数据丢失的风险.</li></ul></li></ol><h2 id="半同步配置"><a href="#半同步配置" class="headerlink" title="半同步配置"></a>半同步配置</h2><ul><li><p>查看MySQL系统版本 <code>select version();</code></p></li><li><p>查看安装插件列表 <code>show plugins;</code></p></li></ul><h3 id="Master配置"><a href="#Master配置" class="headerlink" title="Master配置"></a>Master配置</h3><ul><li>安装 <code>install plugin rpl_semi_sync_master soname &#39;semisync_master.so&#39;;</code><br><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfkz1x7ujnj216e196qe7.jpg" alt="安装成功"></li><li>启动 <code>set global rpl_semi_sync_master_enabled=on;</code></li><li>查看 <code>show variables like &#39;%semi%&#39;;</code><br><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfkz2li4plj20sa0ditaf.jpg" alt="查看状态"><h3 id="Slave配置"><a href="#Slave配置" class="headerlink" title="Slave配置"></a>Slave配置</h3></li></ul><p>图和master配置基本一致 就不放图了</p><ul><li>安装 <code>install plugin rpl_semi_sync_slave soname &#39;semisync_slave.so&#39;;</code></li><li>启动 <code>set global rpl_semi_sync_slave_enabled=on;</code></li><li>查看 <code>show variables like &#39;%semi%&#39;;</code></li><li>重启 <code>stop slave;start slave;</code></li></ul><h3 id="卸载插件"><a href="#卸载插件" class="headerlink" title="卸载插件"></a>卸载插件</h3><p>Slave卸载 </p><ol><li><code>set global rpl_semi_sync_slave_enabled=off;</code> 关闭同步插件</li><li><code>stop slave;</code> 停止Slave同步</li><li><code>uninstall plugin rpl_semi_sync_slave;</code> 卸载插件</li><li><code>start slave;</code> 启动</li></ol><p>Master卸载 </p><ol><li><code>set global rpl_semi_sync_master_enabled=off;</code> 关闭同步插件</li><li><code>uninstall plugin rpl_semi_sync_master;</code> 卸载插件</li></ol><h3 id="关键参数说明"><a href="#关键参数说明" class="headerlink" title="关键参数说明"></a>关键参数说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%semi%&#x27;;</span><br><span class="line">+-------------------------------------------+------------+</span><br><span class="line">| Variable_name                             | Value      |</span><br><span class="line">+-------------------------------------------+------------+</span><br><span class="line">| rpl_semi_sync_master_enabled              | ON         |</span><br><span class="line">| rpl_semi_sync_master_timeout              | 10000      |</span><br><span class="line">| rpl_semi_sync_master_trace_level          | 32         |</span><br><span class="line">| rpl_semi_sync_master_wait_for_slave_count | 1          |</span><br><span class="line">| rpl_semi_sync_master_wait_no_slave        | ON         |</span><br><span class="line">| rpl_semi_sync_master_wait_point           | AFTER_SYNC |</span><br><span class="line">+-------------------------------------------+------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>rpl_semi_sync_master_enabled 设置为on表示开启了半同步功能</li><li>rpl_semi_sync_master_timeout 单位是毫秒,表示如果主库等待从库回复消息的时间超过该值,就会自动切换为异步复制模式</li><li>rpl_semi_sync_master_wait_no_slave 默认是on.表示Master每个事务提交后都要等待Slave的接收确认信号</li><li>rpl_semi_sync_master_wait_for_slave_count 它控制主库接收多少个从库写事务成功反馈,才返回成功给客户端</li><li>rpl_semi_sync_master_wait_point 默认值是AFTER_SYNC,含义是主库将每个事务写入binlog,并传递给从库,刷新到中继日志,主库开始等待从库的反馈,接收到从库的回复之后,在提交事务并且返回”commit ok”结果给客户端</li></ul><p><code>set global rpl_semi_sunc_master_wait_point=&#39;AFTER_COMMIT&#39;;</code> 设置同步模式</p><h2 id="手动主从切换"><a href="#手动主从切换" class="headerlink" title="手动主从切换"></a>手动主从切换</h2><h3 id="正常切换"><a href="#正常切换" class="headerlink" title="正常切换"></a>正常切换</h3><ol><li>对主库全库锁定 <code>flush tables with read lock;</code></li><li>在Master执行 <code>执行 show processlist;</code>查看State是否是Master has sent all binlog to slave; waiting for more updates判断是否发送完毕</li><li>在Slave执行 <code>执行 show processlist;</code>查看State是否是Slave has read all relay log; waiting for more updates判断是否同步完成</li><li>停止Slave IO线程 <code>stop slave io_thread;</code></li><li>将Slave提升为Master:<ul><li>停止Slave <code>stop slave;</code></li><li>删除所有的binlog日志文件,并将日志索引文件清空,重新开始所有新的日志文件.<code>reset master;</code></li><li>删除master.info文件和relay-log.info文件以及所有的relay log文件,并重新启用一个新的relay log文件.<code>reset slave;</code></li><li>相对于RESET SLAVE, RESET SLAVE ALL还会删除内存中的连接信息,包括slave账号信息 <code>reset slave all;</code></li></ul></li><li>查看Slave是否是只读模式:<code>show variables like &#39;read_only&#39;;</code><ul><li>只读模式需要修改my.cnf文件,注释read-only=1并重启mysql服务.</li><li>或者不重启使用命令关闭只读,但下次重启后失效:<code>set global read_only=off;</code></li></ul></li><li>将原来Master变为Slave<ul><li>在新的Master上创建同步用户<code>CREATE USER &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39;;GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#39;slave&#39;@&#39;%&#39;; flush privileges;</code></li><li>将新的Slave设置为只读模式<code>set global read_only=on;</code></li><li>将新的Slave上释放全局锁<code>unlock tables;</code></li><li>在新的Slave上重置binlog<code>reset master;</code></li><li>在新的Slave上配置连接信息<code>change master to master_host=&#39;172.17.0.2&#39;, master_user=&#39;slave&#39;, master_password=&#39;root&#39;, master_port=3306, master_log_file=&#39;mysql-bin.000003&#39;, master_log_pos= 804, master_connect_retry=30;</code></li><li>在新的Slave上开启<code>start slave;</code></li></ul></li></ol><h3 id="主机宕机切换"><a href="#主机宕机切换" class="headerlink" title="主机宕机切换"></a>主机宕机切换</h3><ol><li>停止slave<code>stop slave;</code></li><li>删除所有的binlog日志文件,并将日志索引文件清空,重新开始所有新的日志文件.<code>reset master;</code></li><li>删除内存中的连接信息,包括slave账号信息 <code>reset slave all;</code></li><li>查看Slave是否是只读模式:<code>show variables like &#39;read_only&#39;;</code><ul><li>只读模式需要修改my.cnf文件,注释read-only=1并重启mysql服务.</li><li>或者不重启使用命令关闭只读,但下次重启后失效:<code>set global read_only=off;</code></li></ul></li><li>查看新主机状态<code>show master status;</code></li><li>修改中间件的IP</li></ol><h2 id="主从延时分析及解决"><a href="#主从延时分析及解决" class="headerlink" title="主从延时分析及解决"></a>主从延时分析及解决</h2><h3 id="在master上删除一条记录-而slave上找不到"><a href="#在master上删除一条记录-而slave上找不到" class="headerlink" title="在master上删除一条记录,而slave上找不到."></a>在master上删除一条记录,而slave上找不到.</h3><h4 id="模拟故障场景"><a href="#模拟故障场景" class="headerlink" title="模拟故障场景:"></a>模拟故障场景:</h4><p>主库: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#建表</span><br><span class="line">CREATE TABLE t_dell (</span><br><span class="line">id INT NOT NULL auto_increment PRIMARY KEY,</span><br><span class="line">c1 VARCHAR ( 20 ));</span><br><span class="line">#插入一条数据</span><br><span class="line">INSERT INTO t_dell ( c1 ) VALUES ( &#x27;a&#x27; );</span><br></pre></td></tr></table></figure><p>从库:</p><p><code>DELETE FROM t_dell;</code></p><p>主库:</p><p><code>DELETE FROM t_dell;</code></p><p>接下来我们查看一下Slave的状态;<code>show slave status \G;</code><br><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfn1f3jzoaj217y18udo4.jpg" alt="错误图例1"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last_Errno: 1032</span><br><span class="line">Last_Error: Could not execute Delete_rows event on table test.t_dell; Can&#x27;t find record in &#x27;t_dell&#x27;, Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event&#x27;s master log mysql-slave-bin.000003, end_log_pos 1854</span><br></pre></td></tr></table></figure><br>通过上图我们可以看到 SQL线程已经停止,Last_Error已经出现报错提示.</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><p>由于master 要删除一条记录,而slave上找不到故此报错,这种情况主上都将其删除了,那么从库可以直接跳过.</p><p>操作命令:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">set global sql_slave_skip_counter=1;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><br>或者</p><p><code>slave-skip-errors = 1032;#在MySql配置文件中配置,一旦出现1032错误直接跳过,需要重启服务.</code></p><p>然后在查看同步状态就正常了.<code>show slave status \G;</code></p><h3 id="主键重复-在slave已经有该记录-又在master上插入了同一条记录"><a href="#主键重复-在slave已经有该记录-又在master上插入了同一条记录" class="headerlink" title="主键重复,在slave已经有该记录,又在master上插入了同一条记录."></a>主键重复,在slave已经有该记录,又在master上插入了同一条记录.</h3><h4 id="模拟故障场景-1"><a href="#模拟故障场景-1" class="headerlink" title="模拟故障场景:"></a>模拟故障场景:</h4><p>主库:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 建表</span><br><span class="line">CREATE TABLE t_key (</span><br><span class="line">id INT NOT NULL PRIMARY KEY,</span><br><span class="line">c1 VARCHAR ( 20 ));</span><br><span class="line"># 插入一条数据</span><br><span class="line">INSERT INTO t_key(id,c1) VALUES (1,&#x27;a&#x27;);</span><br><span class="line"># 设置以下操作事件不会被写入binlog</span><br><span class="line">set sql_log_bin=0;</span><br><span class="line"># 删除表</span><br><span class="line">delete from t_key;</span><br><span class="line"># 开启操作事件写入binlog</span><br><span class="line">set sql_log_bin=1;</span><br><span class="line"># 插入一条数据</span><br><span class="line">INSERT INTO t_key(id,c1) VALUES (1,&#x27;a&#x27;); </span><br></pre></td></tr></table></figure><p>从库:</p><p><code>show slave status \G;</code></p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfn24b5ohsj216219246w.jpg" alt="错误状态2"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last_Errno: 1062</span><br><span class="line">Last_Error: Could not execute Write_rows event on table test.t_key; Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;, Error_code: 1062; handler error HA_ERR_FOUND_DUPP_KEY; the event&#x27;s master log mysql-slave-bin.000003, end_log_pos 2583</span><br></pre></td></tr></table></figure></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h4><p>登录到从库,删除重复数据<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">delete from t_key where id=1;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></p><h3 id="在master上更新条记录-而slave上找不到-丢失了数据"><a href="#在master上更新条记录-而slave上找不到-丢失了数据" class="headerlink" title="在master上更新条记录,而slave上找不到,丢失了数据."></a>在master上更新条记录,而slave上找不到,丢失了数据.</h3><h4 id="模拟故障场景-2"><a href="#模拟故障场景-2" class="headerlink" title="模拟故障场景:"></a>模拟故障场景:</h4><p>主库:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 建表</span><br><span class="line">CREATE TABLE t_upd (</span><br><span class="line">id INT NOT NULL PRIMARY KEY,</span><br><span class="line">c1 VARCHAR ( 20 ),</span><br><span class="line">c2 VARCHAR ( 20 ));</span><br><span class="line"># 插入两条数据</span><br><span class="line">INSERT INTO t_upd ( id, c1, c2 ) VALUES</span><br><span class="line">( 1, &#x27;a1&#x27;, &#x27;a2&#x27; ),</span><br><span class="line">( 2, &#x27;b1&#x27;, &#x27;b2&#x27; );</span><br></pre></td></tr></table></figure></p><p>从库:</p><p><code>DELETE FROM t_upd WHERE id = 1;</code></p><p>主库:</p><p><code>UPDATE t_upd SET c1 = &#39;aa&#39; WHERE id = 1;</code><br><img src="http://ww1.sinaimg.cn/large/a3eed545ly1gfn5irci9aj217g19mwmx.jpg" alt="错误状态3"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last_Errno: 1032</span><br><span class="line">Last_Error: Could not execute Update_rows event on table test.t_upd; Can&#x27;t find record in &#x27;t_upd&#x27;, Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event&#x27;s master log mysql-slave-bin.000003, end_log_pos 3368</span><br></pre></td></tr></table></figure></p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法:"></a>解决方法:</h4><p>在master上,用mysqlbinlog分析下出错的binlog日志在3368行是什么语句?</p><p><code>mysqlbinlog --no-defaults --base64-output=DECODE-ROWS -v -v mysql-slave-bin.000003 | grep -A 20 &#39;end_log_pos 3368&#39;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@c950e5d85a10:/var/lib/mysql# mysqlbinlog --no-defaults --base64-output=DECODE-ROWS -v -v mysql-slave-bin.000003 | grep -A 20 &#x27;end_log_pos 3368&#x27;</span><br><span class="line">#200610  5:53:43 server id 2  end_log_pos 3368 CRC32 0x10aef7b4         Update_rows: table id 120 flags: STMT_END_F</span><br><span class="line">### UPDATE `test`.`t_upd`</span><br><span class="line">### WHERE</span><br><span class="line">###   @1=1 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=&#x27;a1&#x27; /* VARSTRING(80) meta=80 nullable=1 is_null=0 */</span><br><span class="line">###   @3=&#x27;a2&#x27; /* VARSTRING(80) meta=80 nullable=1 is_null=0 */</span><br><span class="line">### SET</span><br><span class="line">###   @1=1 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=&#x27;aa&#x27; /* VARSTRING(80) meta=80 nullable=1 is_null=0 */</span><br><span class="line">###   @3=&#x27;a2&#x27; /* VARSTRING(80) meta=80 nullable=1 is_null=0 */</span><br><span class="line"># at 3368</span><br><span class="line">#200610  5:53:43 server id 2  end_log_pos 3399 CRC32 0xffe1af2f         Xid = 215</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;AUTOMATIC&#x27; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure><p>通过binlog日志可以看出来正在执行update语句,然后我们在slave插入缺失的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">INSERT INTO t_upd(id,c1,c2) VALUES (1,&#x27;aa&#x27;,&#x27;a2&#x27;);</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><h3 id="slave的中继日志relay-bin损坏"><a href="#slave的中继日志relay-bin损坏" class="headerlink" title="slave的中继日志relay-bin损坏"></a>slave的中继日志relay-bin损坏</h3><h4 id="模拟故障场景-3"><a href="#模拟故障场景-3" class="headerlink" title="模拟故障场景:"></a>模拟故障场景:</h4><p>从库:<br>停止sql线程<code>stop slave sql_thread;</code><br>主库:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush logs;</span><br><span class="line">INSERT INTO t_key(id,c1) VALUES (1,&#x27;a&#x27;);</span><br></pre></td></tr></table></figure></p><p>从库:<br>删除中继日志,模拟中继日志损坏.<br><code>start slave sql_thread;</code></p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gfn8ev58s2j20yo182n4a.jpg" alt="错误状态4"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last_Errno: 1593</span><br><span class="line">Last_Error: Error initializing relay log position: Could not open log file</span><br></pre></td></tr></table></figure></p><h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法:"></a>解决方法:</h4><p>确认同步的binlog和pos点:</p><ul><li>Slave_IO_Running 接收Master的binlog信息</li><li><p>Master_Log_File / Read_Master_Log_Pos 显示当前读取的Master节点binlog文件和位置.</p></li><li><p>Slave_SQL_Running 执行写操作</p></li><li>Relay_Log_File / Relay_Log_Pos 显示当前节点Slave节点正在处理的中继日志文件和位置.</li><li>Relay_Master_Log_File / Exec_Master_Log_Pos 显示当前Slave节点正在处理的中继日志文件和位置</li></ul><p>重新同步:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stop slave</span><br><span class="line"># 重新通过Master_Log_File文件信息,在Exec_Master_Log_Pos节点处开始生成中继日志文件</span><br><span class="line">CHANGE MASTER TO master_log_file = &#x27;mysql-slave-bin.000003&#x27;,</span><br><span class="line">Master_log_pos = 3399;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://my-replication-life.blogspot.com/2013/09/loss-less-semi-synchronous-replication.html">http://my-replication-life.blogspot.com/2013/09/loss-less-semi-synchronous-replication.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;复制概述&quot;&gt;&lt;a href=&quot;#复制概述&quot; class=&quot;headerlink&quot; title=&quot;复制概述&quot;&gt;&lt;/a&gt;复制概述&lt;/h1&gt;&lt;p&gt;MySQL中的主从复制是将数据从一端(通常称为Master,即主库)复制到另一端(通常称为Slave,即从库).&lt;/p&gt;
&lt;p&gt;MySQL的复制特性操作很灵活,即可以实现整个服务级别的复制,也可以只复制某一个数据库,甚至某个数据库中的某个表对象;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从单向复制(即可以实现从A复制到B)&lt;/li&gt;
&lt;li&gt;单主多从复制(B在复制到C,也可以实现A直接复制到B和C)&lt;/li&gt;
&lt;li&gt;双主复制(甚至是A的数据复制给B,B的数据也复制回A)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/a3eed545ly1gfheym1grdj20hj07c3yp.jpg&quot; alt=&quot;一主多从架构与双主双从架构&quot;&gt;&lt;/p&gt;
&lt;p&gt;服务器间复制数据有很多种解决方案,究竟哪种方案最适合,取决于使用的数据引擎和期望实现的复制需求.一般来说,可以将MySQL的复制特性应用在下来场景上:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实时灾备,用于故障切换&lt;/li&gt;
&lt;li&gt;读写分离,提供查询服务&lt;/li&gt;
&lt;li&gt;备份&lt;/li&gt;
&lt;li&gt;延时库&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;搭建环境&quot;&gt;&lt;a href=&quot;#搭建环境&quot; class=&quot;headerlink&quot; title=&quot;搭建环境&quot;&gt;&lt;/a&gt;搭建环境&lt;/h1&gt;&lt;p&gt;由于MySQL安装方式 网上很多教程 这里就不重复写了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行环境 CentOS 7.5 &lt;/li&gt;
&lt;li&gt;数据库环境 MySQL 5.7.30&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程-socket编程</title>
    <link href="http://blog.huixing.org/linux-socket/"/>
    <id>http://blog.huixing.org/linux-socket/</id>
    <published>2020-03-03T11:55:16.000Z</published>
    <updated>2020-03-03T12:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><h3 id="套接字概念"><a href="#套接字概念" class="headerlink" title="套接字概念"></a>套接字概念</h3><p>Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。</p><p>既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p><p>套接字的内核实现较为复杂，不宜在学习初期深入学习。</p><p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p><p>套接字通信原理如下图所示：</p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gcgzl1euvlj20eb04l0sx.jpg" alt="套接字通信原理"></p><p><strong>在网络通信中，套接字一定是成对出现的。</strong> 一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。</p><p>TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket API。本章的主要内容是socket API，主要介绍TCP协议的函数接口，最后介绍UDP协议和UNIX Domain Socket的函数接口。</p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gcgzm7ibxhj2099084q3s.jpg" alt="网络编程接口"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><p>我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。</p><p>TCP/IP协议规定，<strong>网络数据流应采用大端字节序</strong>，即低地址高字节。例如上一节的UDP段格式，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。</p><p>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做<strong>网络字节序和主机字节序的转换。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">uint32_t htonl(uint32_t hostlong);</span><br><span class="line">uint16_t htons(uint16_t hostshort);</span><br><span class="line">uint32_t ntohl(uint32_t netlong);</span><br><span class="line">uint16_t ntohs(uint16_t netshort);</span><br></pre></td></tr></table></figure><p>h表示host，n表示network，l表示32位长整数，s表示16位短整数。</p><p>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</p><h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h3><p>早期函数(不建议使用)</p><ul><li>只能处理IPv4的ip地址</li><li>不可重入函数</li><li><p>注意参数是struct in_addr</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int inet_aton(const char *cp, struct in_addr *inp);</span><br><span class="line">in_addr_t inet_addr(const char *cp);</span><br><span class="line">char *inet_ntoa(struct in_addr in);</span><br></pre></td></tr></table></figure><p>推荐使用</p></li><li><p>支持IPv4和IPv6</p></li><li>可重入函数</li><li>其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr。因此函数接口是void *addrptr。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int inet_pton(int af, const char *src, void *dst);</span><br><span class="line">const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</span><br></pre></td></tr></table></figure><h3 id="sockaddr数据结构"><a href="#sockaddr数据结构" class="headerlink" title="sockaddr数据结构"></a>sockaddr数据结构</h3><p><code>strcut sockaddr</code> 很多网络编程函数诞生早于IPv4协议，那时候都使用的是<code>sockaddr</code>结构体,为了向前兼容，现在<code>sockaddr</code>退化成了<code>（void *）</code>的作用，传递一个地址给函数，至于这个函数是<code>sockaddr_in</code>还是<code>sockaddr_in6</code>，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p><p><img src="http://ww1.sinaimg.cn/large/a3eed545ly1gcgzwn5sddj208n07uwev.jpg" alt="sockaddr数据结构"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr &#123;</span><br><span class="line">sa_family_t sa_family; /* address family, AF_xxx */</span><br><span class="line">char sa_data[14];/* 14 bytes of protocol address */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>sudo grep -r &quot;struct sockaddr_in &#123;&quot;</code> /usr 命令可查看到struct sockaddr_in结构体的定义。一般其默认的存储位置：/usr/include/linux/in.h 文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">__kernel_sa_family_t sin_family; /* Address family */  地址结构类型</span><br><span class="line">__be16 sin_port; /* Port number */端口号</span><br><span class="line">struct in_addr sin_addr;/* Internet address */IP地址</span><br><span class="line">/* Pad to size of `struct sockaddr&#x27;. */</span><br><span class="line">unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) -</span><br><span class="line">sizeof(unsigned short int) - sizeof(struct in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct in_addr &#123;/* Internet address. */</span><br><span class="line">__be32 s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in6 &#123;</span><br><span class="line">unsigned short int sin6_family; /* AF_INET6 */</span><br><span class="line">__be16 sin6_port; /* Transport layer port # */</span><br><span class="line">__be32 sin6_flowinfo; /* IPv6 flow information */</span><br><span class="line">struct in6_addr sin6_addr;/* IPv6 address */</span><br><span class="line">__u32 sin6_scope_id; /* scope id (new in RFC2553) */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct in6_addr &#123;</span><br><span class="line">union &#123;</span><br><span class="line">__u8 u6_addr8[16];</span><br><span class="line">__be16 u6_addr16[8];</span><br><span class="line">__be32 u6_addr32[4];</span><br><span class="line">&#125; in6_u;</span><br><span class="line">#define s6_addr in6_u.u6_addr8</span><br><span class="line">#define s6_addr16 in6_u.u6_addr16</span><br><span class="line">#define s6_addr32 in6_u.u6_addr32</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define UNIX_PATH_MAX 108</span><br><span class="line">struct sockaddr_un &#123;</span><br><span class="line">__kernel_sa_family_t sun_family; /* AF_UNIX */</span><br><span class="line">char sun_path[UNIX_PATH_MAX]; /* pathname */</span><br></pre></td></tr></table></figure><p>IPv4和IPv6的地址格式定义在<code>netinet/in.h</code>中，IPv4地址用<code>sockaddr_in</code>结构体表示，包括16位端口号和32位IP地址，IPv6地址用<code>sockaddr_in6</code>结构体表示，包括16位端口号、128位IP地址和一些控制字段。UNIX Domain Socket的地址格式定义在<code>sys/un.h</code>中，用<code>sock-addr_un</code>结构体表示。各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度（并不是所有UNIX的实现都有长度字段，如Linux就没有），后16位表示地址类型。IPv4、IPv6和Unix Domain Socket的地址类型分别定义为常数<code>AF_INET</code>、<code>AF_INET6</code>、<code>AF_UNIX</code>。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如<code>bind</code>、<code>accept</code>、<code>connect</code>等函数，这些函数的参数应该设计成<code>void *</code>类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有<code>void *</code>类型，因此这些函数的参数都用<code>struct sockaddr *</code>类型表示，在传递参数之前要强制类型转换一下，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">bind(listen_fd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));/* initialize servaddr */</span><br></pre></td></tr></table></figure><h2 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h2><h3 id="socket模型创建流程图"><a href="#socket模型创建流程图" class="headerlink" title="socket模型创建流程图"></a>socket模型创建流程图</h3><p><img src="http://ww1.sinaimg.cn/large/a3eed545ly1gch01r4qx0j208z094q3r.jpg" alt="socket API"></p><h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">domain:</span><br><span class="line">AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</span><br><span class="line">AF_INET6 与上面类似，不过是来用IPv6的地址</span><br><span class="line">AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</span><br><span class="line">type:</span><br><span class="line">SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</span><br><span class="line">SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</span><br><span class="line">SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</span><br><span class="line">SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</span><br><span class="line">SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</span><br><span class="line">protocol:</span><br><span class="line">传0 表示使用默认协议。</span><br><span class="line">返回值：</span><br><span class="line">成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。</p><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">sockfd：</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">构造出IP地址加端口号</span><br><span class="line">addrlen:</span><br><span class="line">sizeof(addr)长度</span><br><span class="line">返回值：</span><br><span class="line">成功返回0，失败返回-1, 设置errno</span><br></pre></td></tr></table></figure><p>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。</p><p>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。</p><p>如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(6666);</span><br></pre></td></tr></table></figure></p><p>首先将整个结构体清零，然后设置地址类型为AF_INET，<strong>网络地址为INADDR_ANY，这个宏表示本地的任意IP地址，</strong>因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666。</p><h3 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">sockfd:</span><br><span class="line">socket文件描述符</span><br><span class="line">backlog:</span><br><span class="line">排队建立3次握手队列和刚刚建立3次握手队列的链接数和</span><br></pre></td></tr></table></figure><p>查看系统默认backlog <code>cat /proc/sys/net/ipv4/tcp_max_syn_backlog</code></p><p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</p><h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">传出参数，返回链接客户端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</span><br></pre></td></tr></table></figure><p>三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。</p><p>我们的服务器程序结构是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">cliaddr_len = sizeof(cliaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">n = read(connfd, buf, MAXLINE);</span><br><span class="line">......</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1。</p><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">传入参数，指定服务器端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">传入参数,传入sizeof(addr)大小</span><br><span class="line">返回值：</span><br><span class="line">成功返回0，失败返回-1，设置errno</span><br></pre></td></tr></table></figure><p>客户端需要调用connect()连接服务器，connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址。connect()成功返回0，出错返回-1。</p><h2 id="C-S模型-TCP"><a href="#C-S模型-TCP" class="headerlink" title="C/S模型-TCP"></a>C/S模型-TCP</h2><p>下图是基于TCP协议的客户端/服务器程序的一般流程：<br><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gch0uaw8uyj20ci0amjso.jpg" alt="TCP协议通讯流程"></p><p>服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应答一个ACK段，服务器收到后从accept()返回。</p><p>数据传输的过程：</p><p>建立连接后，TCP协议提供全双工的通信服务，但是一般的客户端/服务器程序的流程是由客户端主动发起请求，服务器被动处理请求，一问一答的方式。因此，服务器从accept()返回后立刻调用read()，读socket就像读管道一样，如果没有数据到达就阻塞等待，这时客户端调用write()发送请求给服务器，服务器收到后从read()返回，对客户端的请求进行处理，在此期间客户端调用read()阻塞等待服务器的应答，服务器调用write()将处理结果发回给客户端，再次调用read()阻塞等待下一条请求，客户端收到后从read()返回，发送下一条请求，如此循环下去。</p><p>如果客户端没有更多的请求了，就调用close()关闭连接，就像写端关闭的管道一样，服务器的read()返回0，这样服务器就知道客户端关闭了连接，也调用close()关闭连接。注意，任何一方调用close()后，连接的两个传输方向都关闭，不能再发送数据了。如果一方调用shutdown()则连接处于半关闭状态，仍可接收对方发来的数据。<br>在学习socket API时要注意应用程序和TCP协议层是如何交互的： 应用程序调用某个socket函数时TCP协议层完成什么动作，比如调用connect()会发出SYN段 应用程序如何知道TCP协议层的状态变化，比如从某个阻塞的socket函数返回就表明TCP协议收到了某些段，再比如read()返回0就表明收到了FIN段</p><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><p>下面通过最简单的客户端/服务器程序的实例来学习socket API。</p><p>server.c的作用是从客户端读字符，然后将每个字符转换为大写并回送给客户端。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 80</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">struct sockaddr_in servaddr, cliaddr;</span><br><span class="line">socklen_t cliaddr_len;</span><br><span class="line">int listenfd, connfd;</span><br><span class="line">char buf[MAXLINE];</span><br><span class="line">char str[INET_ADDRSTRLEN];</span><br><span class="line">int i, n;</span><br><span class="line"></span><br><span class="line">listenfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br><span class="line">listen(listenfd, 20);</span><br><span class="line"></span><br><span class="line">printf(&quot;Accepting connections ...\n&quot;);</span><br><span class="line">while (1) &#123;</span><br><span class="line">cliaddr_len = sizeof(cliaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">n = read(connfd, buf, MAXLINE);</span><br><span class="line">printf(&quot;received from %s at PORT %d\n&quot;,</span><br><span class="line">inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),</span><br><span class="line">ntohs(cliaddr.sin_port));</span><br><span class="line">for (i = 0; i &lt; n; i++)</span><br><span class="line">buf[i] = toupper(buf[i]);</span><br><span class="line">write(connfd, buf, n);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><p>client.c的作用是从命令行参数中获得一个字符串发给服务器，然后接收服务器返回的字符串并打印。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">char buf[MAXLINE];</span><br><span class="line">int sockfd, n;</span><br><span class="line">char *str;</span><br><span class="line"></span><br><span class="line">if (argc != 2) &#123;</span><br><span class="line">fputs(&quot;usage: ./client message\n&quot;, stderr);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">str = argv[1];</span><br><span class="line"></span><br><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">write(sockfd, str, strlen(str));</span><br><span class="line"></span><br><span class="line">n = read(sockfd, buf, MAXLINE);</span><br><span class="line">printf(&quot;Response from server:\n&quot;);</span><br><span class="line">write(STDOUT_FILENO, buf, n);</span><br><span class="line">close(sockfd);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于客户端不需要固定的端口号，因此不必调用bind()，客户端的端口号由内核自动分配。注意，客户端不是不允许调用bind()，只是没有必要调用bind()固定一个端口号，服务器也不是必须调用bind()，但如果服务器不调用bind()，内核会自动给服务器分配监听端口，每次启动服务器时端口号都不一样，客户端要连接服务器就会遇到麻烦。</p><p>客户端和服务器启动后可以使用netstat命令查看链接情况：<br><code>netstat -apn|grep 6666</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Socket编程&quot;&gt;&lt;a href=&quot;#Socket编程&quot; class=&quot;headerlink&quot; title=&quot;Socket编程&quot;&gt;&lt;/a&gt;Socket编程&lt;/h2&gt;&lt;h3 id=&quot;套接字概念&quot;&gt;&lt;a href=&quot;#套接字概念&quot; class=&quot;headerlink&quot; title=&quot;套接字概念&quot;&gt;&lt;/a&gt;套接字概念&lt;/h3&gt;&lt;p&gt;Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。&lt;/p&gt;
&lt;p&gt;既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。&lt;/p&gt;
&lt;p&gt;套接字的内核实现较为复杂，不宜在学习初期深入学习。&lt;/p&gt;
&lt;p&gt;在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。&lt;/p&gt;
&lt;p&gt;套接字通信原理如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/a3eed545ly1gcgzl1euvlj20eb04l0sx.jpg&quot; alt=&quot;套接字通信原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在网络通信中，套接字一定是成对出现的。&lt;/strong&gt; 一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。&lt;/p&gt;
&lt;p&gt;TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket API。本章的主要内容是socket API，主要介绍TCP协议的函数接口，最后介绍UDP协议和UNIX Domain Socket的函数接口。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程-线程同步</title>
    <link href="http://blog.huixing.org/linux-system-programming-thread-synchronization/"/>
    <id>http://blog.huixing.org/linux-system-programming-thread-synchronization/</id>
    <published>2020-02-29T04:03:09.000Z</published>
    <updated>2020-02-29T05:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a>同步概念</h2><p>所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等…</p><p>而，编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次序运行。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>同步即协同步调，按预定的先后次序运行。</p><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p><p>举例1：    银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000</p><p>举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续    从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。</p><p>产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。</p><p>“同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p><p>因此，所有“<strong>多个控制流，共同操作一个共享资源</strong>”的情况，都需要同步。</p><h2 id="数据混乱原因"><a href="#数据混乱原因" class="headerlink" title="数据混乱原因"></a>数据混乱原因</h2><p>据混乱原因：</p><ol><li>资源共享（独享资源则不会）    </li><li>调度随机（意味着数据访问会出现竞争）    </li><li>线程间缺乏必要的同步机制。</li></ol><p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</p><p>所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p><h2 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h2><p>Linux中提供一把互斥锁mutex（也称之为互斥量）。</p><p>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p><p>资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gcd55qns9jj205z04aaa1.jpg" alt="加锁图例"></p><p>但，应注意：同一时刻，只能有一个线程持有该锁。</p><p>当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</p><p>所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。</p><p>因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。</p><h3 id="主要应用函数"><a href="#主要应用函数" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><p>pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。</p><p>pthread_mutex_t mutex; 变量mutex只有两种取值1、0。</p><h4 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a>pthread_mutex_init函数</h4><p>初始化一个互斥锁(互斥量) —&gt; 初值可看作1<br><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></p><ul><li>参1：传出参数，调用时应传 &amp;mutex<br>  restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</li><li>参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性</li></ul><p>静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;<br>动态初始化：局部变量应采用动态初始化。e.g.  pthread_mutex_init(&amp;mutex, NULL)</p><h4 id="pthread-mutex-destroy函数"><a href="#pthread-mutex-destroy函数" class="headerlink" title="pthread_mutex_destroy函数"></a>pthread_mutex_destroy函数</h4><p>销毁一个互斥锁<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p><h4 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a>pthread_mutex_lock函数</h4><p>加锁。可理解为将mutex–（或-1）<code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></p><h4 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a>pthread_mutex_unlock函数</h4><p>解锁。可理解为将mutex ++（或+1）<code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></p><h4 id="pthread-mutex-trylock函数"><a href="#pthread-mutex-trylock函数" class="headerlink" title="pthread_mutex_trylock函数"></a>pthread_mutex_trylock函数</h4><p>尝试加锁<code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p><p>以上5个函数的返回值都是：成功返回0， 失败返回错误号。</p><h2 id="加锁与解锁"><a href="#加锁与解锁" class="headerlink" title="加锁与解锁"></a>加锁与解锁</h2><h3 id="lock与unlock"><a href="#lock与unlock" class="headerlink" title="lock与unlock"></a>lock与unlock</h3><p>lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</p><p>unlock主动解锁函数，<strong>同时将阻塞在该锁上的所有线程全部唤醒</strong>，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</p><p>例如：T1 T2 T3 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2 T3 T4均被唤醒，并自动再次尝试加锁。</p><p>可假想mutex锁 init成功初值为1。    lock 功能是将mutex–。    unlock将mutex++</p><h3 id="lock与trylock"><a href="#lock与trylock" class="headerlink" title="lock与trylock"></a>lock与trylock</h3><p>lock加锁失败会阻塞，等待锁释放。</p><p>trylock加锁失败直接返回错误号（如：EBUSY），不阻塞。</p><h2 id="加锁步骤测试"><a href="#加锁步骤测试" class="headerlink" title="加锁步骤测试"></a>加锁步骤测试</h2><p>看如下程序：该程序是非常典型的，由于共享、竞争而没有加任何同步机制，导致产生于时间有关的错误<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;hello &quot;);</span><br><span class="line">        sleep(rand() % 3);/*模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误*/</span><br><span class="line">        printf(&quot;world\n&quot;);</span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;HELLO &quot;);</span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">        printf(&quot;WORLD\n&quot;);</span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost code]# ./test</span><br><span class="line">HELLO WORLD</span><br><span class="line">HELLO WORLD</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello HELLO world</span><br><span class="line">hello WORLD</span><br><span class="line">HELLO world</span><br><span class="line">hello WORLD</span><br><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure><br>加锁后的程序:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);   //mutex--</span><br><span class="line">        printf(&quot;hello &quot;);</span><br><span class="line">        sleep(rand() % 3);/*模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误*/</span><br><span class="line">        printf(&quot;world\n&quot;);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);   //mutex--</span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    int flag = 5;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, NULL);  //mutex = 1</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">    while (flag--) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);   //mutex--</span><br><span class="line">        printf(&quot;HELLO &quot;);</span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">        printf(&quot;WORLD\n&quot;);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex); //mutex++</span><br><span class="line"></span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost code]# ./test                      </span><br><span class="line">HELLO WORLD</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">HELLO WORLD</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>结论：在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ol><li>线程试图对同一个互斥量A加锁两次。</li><li>线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁</li></ol><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>与互斥量类似，但读写锁允许更高的并行性。其特性为：写独占，读共享。</p><h3 id="读写锁状态"><a href="#读写锁状态" class="headerlink" title="读写锁状态"></a>读写锁状态</h3><p>一把读写锁具备三种状态：</p><ol><li>读模式下加锁状态 (读锁)</li><li>写模式下加锁状态 (写锁)</li><li>不加锁状态</li></ol><h3 id="读写锁特性"><a href="#读写锁特性" class="headerlink" title="读写锁特性"></a>读写锁特性</h3><ol><li>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</li><li>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li><li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高</li></ol><p>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。<strong>写独占、读共享</strong>。</p><p>读写锁非常适合于对数据结构读的次数远大于写的情况。</p><h3 id="主要应用函数-1"><a href="#主要应用函数-1" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><h4 id="pthread-rwlock-init函数"><a href="#pthread-rwlock-init函数" class="headerlink" title="pthread_rwlock_init函数"></a>pthread_rwlock_init函数</h4><p>初始化一把读写锁<code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code><br>参2：attr表读写锁属性，通常使用默认属性，传NULL即可。</p><h4 id="pthread-rwlock-destroy函数"><a href="#pthread-rwlock-destroy函数" class="headerlink" title="pthread_rwlock_destroy函数"></a>pthread_rwlock_destroy函数</h4><p>销毁一把读写锁<code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></p><h4 id="pthread-rwlock-rdlock函数"><a href="#pthread-rwlock-rdlock函数" class="headerlink" title="pthread_rwlock_rdlock函数"></a>pthread_rwlock_rdlock函数</h4><p>以读方式请求读写锁。（常简称为：请求读锁）<code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></p><h4 id="pthread-rwlock-wrlock函数"><a href="#pthread-rwlock-wrlock函数" class="headerlink" title="pthread_rwlock_wrlock函数"></a>pthread_rwlock_wrlock函数</h4><p>以写方式请求读写锁。（常简称为：请求写锁）<code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></p><h4 id="pthread-rwlock-unlock函数"><a href="#pthread-rwlock-unlock函数" class="headerlink" title="pthread_rwlock_unlock函数"></a>pthread_rwlock_unlock函数</h4><p>解锁<code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></p><h4 id="pthread-rwlock-tryrdlock函数"><a href="#pthread-rwlock-tryrdlock函数" class="headerlink" title="pthread_rwlock_tryrdlock函数"></a>pthread_rwlock_tryrdlock函数</h4><p>非阻塞以读方式请求读写锁（非阻塞请求读锁）<code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></p><h4 id="pthread-rwlock-trywrlock函数"><a href="#pthread-rwlock-trywrlock函数" class="headerlink" title="pthread_rwlock_trywrlock函数"></a>pthread_rwlock_trywrlock函数</h4><p>非阻塞以写方式请求读写锁（非阻塞请求写锁）<code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>同时有多个线程对同一全局数据读、写操作。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int counter;</span><br><span class="line">pthread_rwlock_t rwlock;</span><br><span class="line"></span><br><span class="line">/* 3个线程不定时写同一全局资源，5个线程不定时读同一全局资源 */</span><br><span class="line">void *th_write(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int t, i = (int)arg;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        t = counter;</span><br><span class="line">        usleep(1000);</span><br><span class="line">        printf(&quot;=======write %d: %lu: counter=%d ++counter=%d\n&quot;, i, pthread_self(), t, ++counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(10000);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">void *th_read(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i = (int)arg;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        printf(&quot;----------------------------read %d: %lu: %d\n&quot;, i, pthread_self(), counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(2000);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    pthread_t tid[8];</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, NULL);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 3; i++)</span><br><span class="line">        pthread_create(&amp;tid[i], NULL, th_write, (void *)i);</span><br><span class="line">    for (i = 0; i &lt; 5; i++)</span><br><span class="line">        pthread_create(&amp;tid[i+3], NULL, th_read, (void *)i);</span><br><span class="line">    for (i = 0; i &lt; 8; i++)</span><br><span class="line">        pthread_join(tid[i], NULL);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</p><h3 id="主要应用函数-2"><a href="#主要应用函数-2" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><h4 id="pthread-cond-init函数"><a href="#pthread-cond-init函数" class="headerlink" title="pthread_cond_init函数"></a>pthread_cond_init函数</h4><p>初始化一个条件变量<code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code><br>参2：attr表条件变量属性，通常为默认值，传NULL即可<br>也可以使用静态初始化的方法，初始化条件变量：<br><code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></p><h4 id="pthread-cond-destroy函数"><a href="#pthread-cond-destroy函数" class="headerlink" title="pthread_cond_destroy函数"></a>pthread_cond_destroy函数</h4><p>销毁一个条件变量<code>int pthread_cond_destroy(pthread_cond_t *cond);</code></p><h4 id="pthread-cond-wait函数"><a href="#pthread-cond-wait函数" class="headerlink" title="pthread_cond_wait函数"></a>pthread_cond_wait函数</h4><p>阻塞等待一个条件变量<code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code><br>函数作用：<br>阻塞等待条件变量cond（参1）满足<br>释放已掌握的互斥锁（解锁互斥量）相当于<code>pthread_mutex_unlock(&amp;mutex);</code><br> 1.2.两步为一个原子操作。<br>当被唤醒，<code>pthread_cond_wait</code>函数返回时，解除阻塞并重新申请获取互斥锁<code>pthread_mutex_lock(&amp;mutex);</code></p><h4 id="pthread-cond-timedwait函数"><a href="#pthread-cond-timedwait函数" class="headerlink" title="pthread_cond_timedwait函数"></a>pthread_cond_timedwait函数</h4><p>限时等待一个条件变量<br><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></p><p>参3：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct timespec &#123;</span><br><span class="line">time_t tv_sec;/* seconds */ 秒</span><br><span class="line">long   tv_nsec;/* nanosecondes*/ 纳秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>形参abstime：绝对时间。</p><p>如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。    <code>struct timespec t = &#123;1, 0&#125;;sem_timedwait(&amp;sem, &amp;t);</code> 这样只能定时到 1970年1月1日  00:00:01秒(早已经过去)<br>正确用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time_t cur = time(NULL);// 获取当前时间。</span><br><span class="line">struct timespec t;//定义timespec 结构体变量t</span><br><span class="line">t.tv_sec = cur+1; //定时1秒</span><br><span class="line">pthread_cond_timedwait (&amp;cond, &amp;t); //传参</span><br></pre></td></tr></table></figure><br>参APUE.11.6线程同步条件变量小节</p><p>在讲解setitimer函数时我们还提到另外一种时间类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct timeval &#123;</span><br><span class="line">     time_t      tv_sec;  /* seconds */ 秒</span><br><span class="line">     suseconds_t tv_usec; /* microseconds */ 微秒</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="pthread-cond-signal函数"><a href="#pthread-cond-signal函数" class="headerlink" title="pthread_cond_signal函数"></a>pthread_cond_signal函数</h4><p>唤醒至少一个阻塞在条件变量上的线程<code>int pthread_cond_signal(pthread_cond_t *cond);</code></p><h4 id="pthread-cond-broadcast函数"><a href="#pthread-cond-broadcast函数" class="headerlink" title="pthread_cond_broadcast函数"></a>pthread_cond_broadcast函数</h4><p>唤醒全部阻塞在条件变量上的线程<code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></p><h3 id="生产者消费者条件变量模型"><a href="#生产者消费者条件变量模型" class="headerlink" title="生产者消费者条件变量模型"></a>生产者消费者条件变量模型</h3><p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">struct msg &#123;</span><br><span class="line">    struct msg *next;</span><br><span class="line">    int num;</span><br><span class="line">&#125;;</span><br><span class="line">struct msg *head;</span><br><span class="line"></span><br><span class="line">pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">void *consumer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    struct msg *mp;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        while (head == NULL) &#123;           //头指针为空,说明没有节点    可以为if吗</span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        mp = head;      </span><br><span class="line">        head = mp-&gt;next;    //模拟消费掉一个产品</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">        printf(&quot;-Consume ---%d\n&quot;, mp-&gt;num);</span><br><span class="line">        free(mp);</span><br><span class="line">        sleep(rand() % 5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void *producer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    struct msg *mp;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        mp = malloc(sizeof(struct msg));</span><br><span class="line">        mp-&gt;num = rand() % 1000 + 1;        //模拟生产一个产品</span><br><span class="line">        printf(&quot;-Produce ---%d\n&quot;, mp-&gt;num);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        mp-&gt;next = head;</span><br><span class="line">        head = mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">        pthread_cond_signal(&amp;has_product);  //将等待在该条件变量上的一个线程唤醒</span><br><span class="line">        sleep(rand() % 5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t pid, cid;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">    pthread_create(&amp;cid, NULL, consumer, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_join(pid, NULL);</span><br><span class="line">    pthread_join(cid, NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量的优点"><a href="#条件变量的优点" class="headerlink" title="条件变量的优点"></a>条件变量的优点</h3><p>相较于mutex而言，条件变量可以减少竞争。</p><p>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>进化版的互斥锁（1 –&gt; N）</p><p>由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。</p><p>信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p><h3 id="主要应用函数-3"><a href="#主要应用函数-3" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><p>信号量基本操作：<br>sem_wait:</p><ol><li>信号量大于0，则信号量–类比pthread_mutex_lock）</li><li>信号量等于0，造成线程阻塞</li></ol><p>sem_post：将信号量++，同时唤醒阻塞在信号量上的线程（类比pthread_mutex_unlock）<br>但，由于sem_t的实现对用户隐藏，所以所谓的++、–操作只能通过函数来实现，而不能直接++、–符号。</p><p>信号量的初值，决定了占用信号量的线程的个数。</p><h4 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a>sem_init函数</h4><p>初始化一个信号量<code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></p><ul><li>参1：sem信号量    </li><li>参2：pshared取0用于线程间；取非0用于进程间    </li><li>参3：value指定信号量初值</li></ul><h4 id="sem-destroy函数"><a href="#sem-destroy函数" class="headerlink" title="sem_destroy函数"></a>sem_destroy函数</h4><p>销毁一个信号量<code>int sem_destroy(sem_t *sem);</code></p><h4 id="sem-wait函数"><a href="#sem-wait函数" class="headerlink" title="sem_wait函数"></a>sem_wait函数</h4><p>给信号量加锁 –<code>int sem_wait(sem_t *sem);</code></p><h4 id="sem-post函数"><a href="#sem-post函数" class="headerlink" title="sem_post函数"></a>sem_post函数</h4><p>给信号量解锁 ++<code>int sem_post(sem_t *sem);</code>    </p><h4 id="sem-trywait函数"><a href="#sem-trywait函数" class="headerlink" title="sem_trywait函数"></a>sem_trywait函数</h4><p>尝试对信号量加锁 –    (与sem_wait的区别类比lock和trylock)<code>int sem_trywait(sem_t *sem);</code></p><h4 id="sem-timedwait函数"><a href="#sem-timedwait函数" class="headerlink" title="sem_timedwait函数"></a>sem_timedwait函数</h4><p>限时尝试对信号量加锁 – <code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code><br>参2：abs_timeout采用的是绝对时间。<br>定时1秒：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time_t cur = time(NULL); //获取当前时间。</span><br><span class="line">struct timespec t;//定义timespec 结构体变量t</span><br><span class="line">t.tv_sec = cur+1; //定时1秒</span><br><span class="line">sem_timedwait(&amp;sem, &amp;t); //传参</span><br></pre></td></tr></table></figure></p><h3 id="生产者消费者信号量模型"><a href="#生产者消费者信号量模型" class="headerlink" title="生产者消费者信号量模型"></a>生产者消费者信号量模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">#define NUM 5               </span><br><span class="line"></span><br><span class="line">int queue[NUM];                                     //全局数组实现环形队列</span><br><span class="line">sem_t blank_number, product_number;                 //空格子信号量, 产品信号量</span><br><span class="line">void *producer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        sem_wait(&amp;blank_number);                    //生产者将空格子数--,为0则阻塞等待</span><br><span class="line">        queue[i] = rand() % 1000 + 1;               //生产一个产品</span><br><span class="line">        printf(&quot;----Produce---%d\n&quot;, queue[i]);        </span><br><span class="line">        sem_post(&amp;product_number);                  //将产品数++</span><br><span class="line"></span><br><span class="line">        i = (i+1) % NUM;                            //借助下标实现环形</span><br><span class="line">        sleep(rand()%1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *consumer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        sem_wait(&amp;product_number);                  //消费者将产品数--,为0则阻塞等待</span><br><span class="line">        printf(&quot;-Consume---%d       %lu\n&quot;, queue[i], pthread_self());</span><br><span class="line">        queue[i] = 0;                               //消费一个产品 </span><br><span class="line">        sem_post(&amp;blank_number);                    //消费掉以后,将空格子数++</span><br><span class="line"></span><br><span class="line">        i = (i+1) % NUM;</span><br><span class="line">        sleep(rand()%1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t pid, cid;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;blank_number, 0, NUM);                //初始化空格子信号量为5</span><br><span class="line">    sem_init(&amp;product_number, 0, 0);                //产品数为0</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;cid, NULL, consumer, NULL);</span><br><span class="line">    pthread_create(&amp;cid, NULL, consumer, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_join(pid, NULL);</span><br><span class="line">    pthread_join(cid, NULL);</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h2><h3 id="互斥量mutex-1"><a href="#互斥量mutex-1" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h3><p>进程间也可以使用互斥锁，来达到同步的目的。但应在pthread_mutex_init初始化之前，修改其属性为进程间共享。mutex的属性修改函数主要有以下几个。</p><h3 id="主要应用函数-4"><a href="#主要应用函数-4" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><ul><li>pthread_mutexattr_t mattr 类型：        用于定义mutex锁的【属性】</li><li>pthread_mutexattr_init函数：            初始化一个mutex属性对象</li><li>int pthread_mutexattr_init(pthread_mutexattr_t *attr);</li><li>pthread_mutexattr_destroy函数：        销毁mutex属性对象 (而非销毁锁)</li><li>int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);</li><li>pthread_mutexattr_setpshared函数：    修改mutex属性。</li><li>int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);</li></ul><p>参2：pshared取值：<br>    线程锁：PTHREAD_PROCESS_PRIVATE (mutex的默认属性即为线程锁，进程间私有)<br>    进程锁：PTHREAD_PROCESS_SHARED</p><h3 id="进程间mutex示例"><a href="#进程间mutex示例" class="headerlink" title="进程间mutex示例"></a>进程间mutex示例</h3><p>进程间使用mutex来实现同步<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">struct mt &#123;</span><br><span class="line">    int num;</span><br><span class="line">    pthread_mutex_t mutex;</span><br><span class="line">    pthread_mutexattr_t mutexattr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int fd, i;</span><br><span class="line">    struct mt *mm;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;mt_test&quot;, O_CREAT | O_RDWR, 0777);</span><br><span class="line">    ftruncate(fd, sizeof(*mm));</span><br><span class="line">    mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">    close(fd);</span><br><span class="line">    unlink(&quot;mt_test&quot;);</span><br><span class="line">    //mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);</span><br><span class="line">    memset(mm, 0, sizeof(*mm));</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_init(&amp;mm-&gt;mutexattr);                                  //初始化mutex属性对象</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;mm-&gt;mutexattr, PTHREAD_PROCESS_SHARED);    //修改属性为进程间共享</span><br><span class="line">    pthread_mutex_init(&amp;mm-&gt;mutex, &amp;mm-&gt;mutexattr);                          //初始化一把mutex琐</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            (mm-&gt;num)++;</span><br><span class="line">            printf(&quot;-child----num++   %d\n&quot;, mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">        for ( i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            sleep(1);</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            mm-&gt;num += 2;</span><br><span class="line">            printf(&quot;-parent---num+=2  %d\n&quot;, mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_destroy(&amp;mm-&gt;mutexattr);          //销毁mutex属性对象</span><br><span class="line">    pthread_mutex_destroy(&amp;mm-&gt;mutex);                //销毁mutex</span><br><span class="line">    munmap(mm,sizeof(*mm));                          //释放映射区</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h3><p>借助 fcntl函数来实现锁机制。    操作文件的进程没有获得锁时，可以打开，但无法执行read、write操作。</p><p>fcntl函数：    获取、设置文件访问控制属性。<code>int fcntl(int fd, int cmd, ... /* arg */ );</code></p><p>参2：</p><ul><li>F_SETLK (struct flock *)    设置文件锁（trylock）</li><li>F_SETLKW (struct flock *) 设置文件锁（lock）W –&gt; wait</li><li>F_GETLK (struct flock *)    获取文件锁</li></ul><p>参3：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct flock &#123;</span><br><span class="line">    ...</span><br><span class="line">    short l_type;    锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK</span><br><span class="line">    short l_whence;  偏移位置：SEEK_SET、SEEK_CUR、SEEK_END </span><br><span class="line">    off_t l_start;   起始偏移：</span><br><span class="line">    off_t l_len;     长度：0表示整个文件加锁</span><br><span class="line">    pid_t l_pid;     持有该锁的进程ID：(F_GETLK only)</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="进程间文件锁示例"><a href="#进程间文件锁示例" class="headerlink" title="进程间文件锁示例"></a>进程间文件锁示例</h3><p>多个进程对加锁文件进行访问<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str); exit(1);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    struct flock f_lock;</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf(&quot;./a.out filename\n&quot;); exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    if ((fd = open(argv[1], O_RDWR)) &lt; 0)</span><br><span class="line">        sys_err(&quot;open&quot;);</span><br><span class="line"></span><br><span class="line">    //f_lock.l_type = F_WRLCK;        /*选用写琐*/</span><br><span class="line">    f_lock.l_type = F_RDLCK;          /*选用读琐*/ </span><br><span class="line"></span><br><span class="line">    f_lock.l_whence = SEEK_SET;</span><br><span class="line">    f_lock.l_start = 0;</span><br><span class="line">    f_lock.l_len = 0;               /* 0表示整个文件加锁 */</span><br><span class="line"></span><br><span class="line">    fcntl(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line">    printf(&quot;get flock\n&quot;);</span><br><span class="line">    sleep(10);</span><br><span class="line"></span><br><span class="line">    f_lock.l_type = F_UNLCK;</span><br><span class="line">    fcntl(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line">    printf(&quot;un flock\n&quot;);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>依然遵循“读共享、写独占”特性。但！如若进程不加锁直接操作文件，依然可访问成功，但数据势必会出现混乱。</p><p>多线程中，可以使用文件锁吗？</p><p>多线程间共享文件描述符，而给文件加锁，是通过修改文件描述符所指向的文件结构体中的成员变量来实现的。因此，多线程中无法使用文件锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同步概念&quot;&gt;&lt;a href=&quot;#同步概念&quot; class=&quot;headerlink&quot; title=&quot;同步概念&quot;&gt;&lt;/a&gt;同步概念&lt;/h2&gt;&lt;p&gt;所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等…&lt;/p&gt;
&lt;p&gt;而，编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次序运行。&lt;/p&gt;
&lt;h2 id=&quot;线程同步&quot;&gt;&lt;a href=&quot;#线程同步&quot; class=&quot;headerlink&quot; title=&quot;线程同步&quot;&gt;&lt;/a&gt;线程同步&lt;/h2&gt;&lt;p&gt;同步即协同步调，按预定的先后次序运行。&lt;/p&gt;
&lt;p&gt;线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。&lt;/p&gt;
&lt;p&gt;举例1：    银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000&lt;/p&gt;
&lt;p&gt;举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续    从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。&lt;/p&gt;
&lt;p&gt;产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。&lt;/p&gt;
&lt;p&gt;“同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程-信号</title>
    <link href="http://blog.huixing.org/linux-signal/"/>
    <id>http://blog.huixing.org/linux-signal/</id>
    <published>2020-02-26T03:44:04.000Z</published>
    <updated>2020-02-29T06:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h2><p>信号其实我们也见过，当我们在shell上写出一个死循环退不出来的时候，只需要一个组合键，ctrl+c,就可以解决了，这就是一个信号，但是真正的过程并不是那么简单的。</p><ol><li><p>当用户按下这一对组合键时，这个键盘输入会产生一个硬件中断，如果CPU正在执行这个进程的代码时，则该进程的用户代码先暂停执行，用户从用户态切换到内核态处理硬件中断</p></li><li><p>终端驱动程序将这一对组合键翻译成一个SIGINT(ctrl+c)信号记在该进程的PCB中（也就是发送了一个SIGINT信号给该进程）</p></li><li><p>当某个时刻要从内核态回到该进程的用户·空间代码继续执行之前，首先处理PCB中的信号，发现有一个SIGINT信号需要处理，而这个信号的默认处理方式是终止进程，所以直接终止进程，不再返回用户空间执行代码。</p></li><li><p>shell可以同时运行一个前台进程和多个后台进程，只有前台进程才能收到ctrl+c这种组合键产生的信号</p></li><li><p>前台进程在 运行过程中用户可以随时按下ctrl+c产生一个信号也就是说前台进程的用户空间代码执行到任意一个时刻都可能接收到SIGINT信号而终止，所以信号对于进程的控制流来说是异步的。</p></li></ol><p><strong>注意：ctrl+c只能终止前台进程。一个命令可以加&amp;可以将进程放在后台执行，这样shell就不必等待进程结束就可以接收新的命令，启动新的进程</strong></p><h2 id="信号介绍"><a href="#信号介绍" class="headerlink" title="信号介绍"></a>信号介绍</h2><p>在bash上执行命令kill -l便可看到系统定义的所有信号<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line">1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL</span><br><span class="line">5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE</span><br><span class="line">9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2</span><br><span class="line">13) SIGPIPE     14) SIGALRM     15) SIGTERM     17) SIGCHLD</span><br><span class="line">18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN</span><br><span class="line">22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO</span><br><span class="line">30) SIGPWR      31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1</span><br><span class="line">36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4  39) SIGRTMIN+5</span><br><span class="line">40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8  43) SIGRTMIN+9</span><br><span class="line">44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13</span><br><span class="line">52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9</span><br><span class="line">56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6  59) SIGRTMAX-5</span><br><span class="line">60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2  63) SIGRTMAX-1</span><br><span class="line">64) SIGRTMAX</span><br></pre></td></tr></table></figure><br>列表中，编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)，编号为32 ~ 63的信号是后来扩充的，称做可靠信号(实时信号)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。</p><p>每个信号都有一个编号和一个宏定义名称，这些宏定义都可以在signal.h中找到，在man手册中还可以找到各种信号的详细信息</p><p><code>man 7 signal</code></p><p>下面我们对编号小于SIGRTMIN的信号进行讨论。</p><h3 id="SIGHUP"><a href="#SIGHUP" class="headerlink" title="SIGHUP"></a>SIGHUP</h3><p>1) SIGHUP<br>本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。</p><p>登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录，wget也能继续下载。</p><p>此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</p><h3 id="SIGINT"><a href="#SIGINT" class="headerlink" title="SIGINT"></a>SIGINT</h3><p>2) SIGINT<br>程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。</p><h3 id="SIGQUIT"><a href="#SIGQUIT" class="headerlink" title="SIGQUIT"></a>SIGQUIT</h3><p>3) SIGQUIT<br>和SIGINT类似, 但由QUIT字符(通常是Ctrl-/)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。</p><h3 id="SIGILL"><a href="#SIGILL" class="headerlink" title="SIGILL"></a>SIGILL</h3><p>4) SIGILL<br>执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。</p><h3 id="SIGTRAP"><a href="#SIGTRAP" class="headerlink" title="SIGTRAP"></a>SIGTRAP</h3><p>5) SIGTRAP<br>由断点指令或其它trap指令产生. 由debugger使用。</p><h3 id="SIGABRT"><a href="#SIGABRT" class="headerlink" title="SIGABRT"></a>SIGABRT</h3><p>6) SIGABRT<br>调用abort函数生成的信号。</p><h3 id="SIGBUS"><a href="#SIGBUS" class="headerlink" title="SIGBUS"></a>SIGBUS</h3><p>7) SIGBUS<br>非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。</p><h3 id="SIGFPE"><a href="#SIGFPE" class="headerlink" title="SIGFPE"></a>SIGFPE</h3><p>8) SIGFPE<br>在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。</p><h3 id="SIGKILL"><a href="#SIGKILL" class="headerlink" title="SIGKILL"></a>SIGKILL</h3><p>9) SIGKILL<br>用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。</p><h3 id="SIGUSR1"><a href="#SIGUSR1" class="headerlink" title="SIGUSR1"></a>SIGUSR1</h3><p>10) SIGUSR1<br>留给用户使用</p><h3 id="SIGSEGV"><a href="#SIGSEGV" class="headerlink" title="SIGSEGV"></a>SIGSEGV</h3><p>11) SIGSEGV<br>试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.</p><h3 id="SIGUSR2"><a href="#SIGUSR2" class="headerlink" title="SIGUSR2"></a>SIGUSR2</h3><p>12) SIGUSR2<br>留给用户使用</p><h3 id="SIGPIPE"><a href="#SIGPIPE" class="headerlink" title="SIGPIPE"></a>SIGPIPE</h3><p>13) SIGPIPE<br>管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。</p><h3 id="SIGALRM"><a href="#SIGALRM" class="headerlink" title="SIGALRM"></a>SIGALRM</h3><p>14) SIGALRM<br>时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号.</p><h3 id="SIGTERM"><a href="#SIGTERM" class="headerlink" title="SIGTERM"></a>SIGTERM</h3><p>15) SIGTERM<br>程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。</p><h3 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h3><p>17) SIGCHLD<br>子进程结束时, 父进程会收到这个信号。</p><p>如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程来接管)。</p><h3 id="SIGCONT"><a href="#SIGCONT" class="headerlink" title="SIGCONT"></a>SIGCONT</h3><p>18) SIGCONT<br>让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符</p><h3 id="SIGSTOP"><a href="#SIGSTOP" class="headerlink" title="SIGSTOP"></a>SIGSTOP</h3><p>19) SIGSTOP<br>停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略.</p><h3 id="SIGTSTP"><a href="#SIGTSTP" class="headerlink" title="SIGTSTP"></a>SIGTSTP</h3><p>20) SIGTSTP<br>停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号</p><h3 id="SIGTTIN"><a href="#SIGTTIN" class="headerlink" title="SIGTTIN"></a>SIGTTIN</h3><p>21) SIGTTIN<br>当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行.</p><h3 id="SIGTTOU"><a href="#SIGTTOU" class="headerlink" title="SIGTTOU"></a>SIGTTOU</h3><p>22) SIGTTOU<br>类似于SIGTTIN, 但在写终端(或修改终端模式)时收到.</p><h3 id="SIGURG"><a href="#SIGURG" class="headerlink" title="SIGURG"></a>SIGURG</h3><p>23) SIGURG<br>有”紧急”数据或out-of-band数据到达socket时产生.</p><h3 id="SIGXCPU"><a href="#SIGXCPU" class="headerlink" title="SIGXCPU"></a>SIGXCPU</h3><p>24) SIGXCPU<br>超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。</p><h3 id="SIGXFSZ"><a href="#SIGXFSZ" class="headerlink" title="SIGXFSZ"></a>SIGXFSZ</h3><p>25) SIGXFSZ<br>当进程企图扩大文件以至于超过文件大小资源限制。</p><h3 id="SIGVTALRM"><a href="#SIGVTALRM" class="headerlink" title="SIGVTALRM"></a>SIGVTALRM</h3><p>26) SIGVTALRM<br>虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.</p><h3 id="SIGPROF"><a href="#SIGPROF" class="headerlink" title="SIGPROF"></a>SIGPROF</h3><p>27) SIGPROF<br>类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间.</p><h3 id="SIGWINCH"><a href="#SIGWINCH" class="headerlink" title="SIGWINCH"></a>SIGWINCH</h3><p>28) SIGWINCH<br>窗口大小改变时发出.</p><h3 id="SIGIO"><a href="#SIGIO" class="headerlink" title="SIGIO"></a>SIGIO</h3><p>29) SIGIO<br>文件描述符准备就绪, 可以开始进行输入/输出操作.</p><h3 id="SIGPWR"><a href="#SIGPWR" class="headerlink" title="SIGPWR"></a>SIGPWR</h3><p>30) SIGPWR<br>Power failure</p><h3 id="SIGSYS"><a href="#SIGSYS" class="headerlink" title="SIGSYS"></a>SIGSYS</h3><p>31) SIGSYS<br>非法的系统调用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在以上列出的信号中，程序不可捕获、阻塞或忽略的信号有：SIGKILL,SIGSTOP<br>不能恢复至默认动作的信号有：SIGILL,SIGTRAP<br>默认会导致进程流产的信号有：SIGABRT,SIGBUS,SIGFPE,SIGILL,SIGIOT,SIGQUIT,SIGSEGV,SIGTRAP,SIGXCPU,SIGXFSZ<br>默认会导致进程退出的信号有：SIGALRM,SIGHUP,SIGINT,SIGKILL,SIGPIPE,SIGPOLL,SIGPROF,SIGSYS,SIGTERM,SIGUSR1,SIGUSR2,SIGVTALRM<br>默认会导致进程停止的信号有：SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU<br>默认进程忽略的信号有：SIGCHLD,SIGPWR,SIGURG,SIGWINCH</p><p>此外，SIGIO在SVR4是退出，在4.3BSD中是忽略；SIGCONT在进程挂起时是继续，否则是忽略，不能被阻塞。 </p><h2 id="产生信号的方式"><a href="#产生信号的方式" class="headerlink" title="产生信号的方式"></a>产生信号的方式</h2><ol><li><p>通过键盘的组合键产生，比如ctrl+c产生SIGINT信号，ctrl+\产生SIGQUIT信号，ctrl+z产生SIGTSTP信号</p></li><li><p>硬件异常产生信号，这些条件由硬件检测并通知内核，然后内核向进程发送适当的信号，比如执行了除以零的指令，进程访问了非法内存地址，cpu的运算单元都会产生异常，内核将这个异常解释成一个个信号发送给进程</p></li><li><p>一个进程调用kill(2)函数可以发送信号给另一个进程。可以用kill(1)发送信号给某一个进程kill(1)也是用kill(2)实现的如果不清楚指定信号则发送SIGTERM信号，该信号的默认处理动作是终止进程，当内核检测到软件条件发生时也可以通过信号通知进程例如闹钟超时，会产生SIGALRM信号，向读端已经关闭的管道文件写数据时产生SIGPIPE信号，如果不想按照默认动作处理信号，用户可以调用sigaction（2）函数告诉内核如何处理某种信号</p></li><li><p>软件条件产生</p></li></ol><h2 id="信号常见处理方式"><a href="#信号常见处理方式" class="headerlink" title="信号常见处理方式"></a>信号常见处理方式</h2><ol><li><p>忽略该信号</p></li><li><p>执行信号的默认处理动作</p></li><li><p>提供一个信号处理函数，要求内核在处理信号时切换到用户态执行这个处理函数，这种方式称为捕捉一个异常</p></li></ol><h2 id="信号产生具体过程"><a href="#信号产生具体过程" class="headerlink" title="信号产生具体过程"></a>信号产生具体过程</h2><h3 id="通过终端按键来产生信号"><a href="#通过终端按键来产生信号" class="headerlink" title="通过终端按键来产生信号"></a>通过终端按键来产生信号</h3><p>SIGINT (ctrl+c)的默认处理动作是终止进程，SIGQUIT(trl+/)的默认处理动作是终止进程并Core Dump,我们在Linux环境下来验证一下，先来了解一下什么是<a href="https://baike.baidu.com/item/%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8">Core Dump</a>.</p><p>当一个进程要异常终止时，可以选择把进程的用户空间内存数据全部保存在磁盘上，文件名通常是core，这叫做<a href="https://baike.baidu.com/item/%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8">Core Dump</a>。进程异常终止通常是因为有BUG，比如非法访问内存导致段错误，事后可以用调试器检查core文件以查清楚错误原因，这叫做事后调试，一个进程允许产生多大的core文件取决于进程的Resource Limit（这个信息保存在PCB中），默认是不允许改变这个限制，允许产生core文件。首先用ulimit命令来改变shell进程的Resource Limit，允许core文件最大为1024k</p><p><code>ulimit -c 1024</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux ~]# ulimit -c 1024</span><br><span class="line">[root@centos-linux ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 1024</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 7240</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 7240</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>test.c 举例一个死循环程序:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    printf(&quot;get pid = %d \n&quot;,getpid());</span><br><span class="line">    while (1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>编译并执行程序：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux code]# gcc -o test test.c</span><br><span class="line">[root@centos-linux code]# ./test </span><br><span class="line">get pid = 10427 </span><br><span class="line">^\Quit (core dumped)</span><br><span class="line">[root@centos-linux code]# </span><br></pre></td></tr></table></figure><br>看到的现象是先打印出pid然后一直在死循环，按下组合键ctrl+\后退出并提示core dumped</p><p>test程序也会core  dump的原因是我们先修改了shell的Resource Limit值，而test进程是由shell产生的所以test进程的PCB也是由shell复制而来，所以test进程和shell就具有相同的Resource Limit值，所以就会产生core dump了。</p><p>我们使用ls目录查看一下目录多出来的文件:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux code]# ls</span><br><span class="line">core.10427  test  test.c</span><br></pre></td></tr></table></figure></p><p>我们来使用core文件,通过gdb调试.<code>core-file core.10427</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux code]# gdb test</span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-115.el7</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /root/code/test...(no debugging symbols found)...done.   </span><br><span class="line">(gdb) core-file core.10427 </span><br><span class="line">[New LWP 10427]</span><br><span class="line">Core was generated by `./test&#x27;.</span><br><span class="line">Program terminated with signal 3, Quit.</span><br><span class="line">#0  0x0000000000400597 in main ()</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-292.el7.x86_64</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><h3 id="调用系统函数来向进程发信号"><a href="#调用系统函数来向进程发信号" class="headerlink" title="调用系统函数来向进程发信号"></a>调用系统函数来向进程发信号</h3><p>首先在后台运行一个死循环程序，然后用kill 命令给它发信号<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux code]# ./test &amp;           </span><br><span class="line">[1] 10549</span><br><span class="line">[root@centos-linux code]# get pid = 10549 </span><br><span class="line"></span><br><span class="line">[root@centos-linux code]# kill -SIGSEGV 10549</span><br><span class="line">[root@centos-linux code]# ls</span><br><span class="line">core.10427  core.10549  test  test.c</span><br><span class="line">[1]+  Segmentation fault      (core dumped) ./test</span><br></pre></td></tr></table></figure></p><p>说明：我们之所以要多按一次回车，是因为10549进程终止掉之前已经回到了shell提示符等待用户输入下一条命令，shell不希望错误信息和用户命令混在一起，所以先等用户输入后再显示</p><p>指定发送某种信号的kill命令可以有多种，上面的命令还可以写成kill -11 10549，11是信号SIGSEGV信号的编号。以往遇到的段错误都是由非法内存访问引起的，而这个程序本来也没错误，给它发送一个SIGSEGV信号也能引起段错误</p><p>kill命令是由kill函数实现的，kill函数可以给一个指定的进程发送指定的信号，raise函数可以给当前进程发送指定的信号（自己给自己发信号）</p><h3 id="软件条件产生的信号"><a href="#软件条件产生的信号" class="headerlink" title="软件条件产生的信号"></a>软件条件产生的信号</h3><p>软件条件产生的信号我们已经见过一种，就在我们学习进程间通信的时候，信号SIGPIPE就被我们介绍过，我们在这里不再多加介绍，我们接下来要介绍一种有趣的信号和产生这种信号的函数，我们可以想想，有一种声音我们每个人最不想听到的一种声音是什么，当然是每天的闹钟声了，我们介绍的这个信号就和现实中的闹钟很像，今天要介绍的信号就是SIGALRM信号，以及产生这种信号的函数alarm.</p><h4 id="alarm（设置信号传送闹钟）"><a href="#alarm（设置信号传送闹钟）" class="headerlink" title="alarm（设置信号传送闹钟）"></a>alarm（设置信号传送闹钟）</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;unistd.h&gt;</code></td></tr><tr><td>定义函数</td><td>unsigned int alarm(unsigned int seconds);</td></tr><tr><td>函数说明</td><td>alarm()用来设置信号SIGALRM在经过参数seconds指定的秒数后传送给目前的进程。如果参数seconds 为0，则之前设置的闹钟会被取消，并将剩下的时间返回。</td></tr><tr><td>返回值</td><td>返回之前闹钟的剩余秒数，如果之前未设闹钟则返回0。</td></tr></tbody></table><p>范例:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int count = 1;</span><br><span class="line">    alarm(1);</span><br><span class="line">    for (;1;count++) &#123;</span><br><span class="line">        printf(&quot;count is %d\n&quot;,count);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果(由于执行结果太长我就贴最后重要部分,详细的结果可以自己试验):<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count is 184693</span><br><span class="line">count is 184694</span><br><span class="line">count is 184695Alarm clock</span><br><span class="line">[root@centos-linux code]# </span><br></pre></td></tr></table></figure><br>代码中设置一个闹钟和一个计数器，在闹钟响前，count一直++，并输出count值直到闹钟响，接收到SIGALRM信号才结束进程</p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;sys/types.h&gt; #include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td>int kill(pid_t pid,int sig);</td></tr><tr><td>函数说明</td><td>kill()可以用来送参数sig指定的信号给参数pid指定的进程。参数pid有几种情况:pid&gt;0 将信号传给进程识别码为pid 的进程。pid=0 将信号传给和目前进程相同进程组的所有进程pid=-1 将信号广播传送给系统内所有的进程pid&lt;0 将信号传给进程组识别码为pid绝对值的所有进程,参数sig代表的信号编号可参考上面信号介绍</td></tr><tr><td>返回值</td><td>执行成功则返回0，如果有错误则返回-1。</td></tr><tr><td>错误代码</td><td>EINVAL 参数sig 不合法 ESRCH 参数pid 所指定的进程或进程组不存在 EPERM 权限不够无法传送信号给指定进程</td></tr></tbody></table><h4 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;sys/types.h&gt; #include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td>int raise(int sig);</td></tr><tr><td>函数说明</td><td>用于向进程自身发送信号。</td></tr><tr><td>返回值</td><td>成功返回0，失败返回-1。</td></tr></tbody></table><h4 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td>int abort(void);</td></tr><tr><td>函数说明</td><td>中止程序执行，直接从调用的地方跳出。</td></tr><tr><td>返回值</td><td>该函数不返回任何值。</td></tr></tbody></table><h2 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h2><p>实际执行信号的动作叫做信号递达</p><p>信号从产生到递达过程中的状态叫做信号未决，</p><p>进程可以选择阻塞某个信号</p><p>被阻塞的信号将处于未决状态，直到进程解除对信号的阻塞，才执行递达的动作</p><p>注意：阻塞和忽略是不同的，只要信号被阻塞就不会被递达，而忽略是在递达之后所选择的一种处理动作</p><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gc9why2s0ej20f9050t8s.jpg" alt="信号在内核中的表示示意图"><br>上图来源: Linux C编程一站式学习 第33章信号</p><p>解释说明：每个信号都有两个标志位分别表示阻塞和未决，还有一个函数指针表示处理动作，信号产生时，内核在进程控制块中设置该信号的未决标志，直到信号递达才会清除该标志。如果进程解除对某信号的阻塞之前该信号产生过很多次，将如何处理？</p><p>OPSIX.1允许递达该信号一次或多次。Linux是这样实现的，常规信号在递达之前产生多次只记一次，而实时信号在递达之前产生多次可以依次放在一个队列里。在这里，不讨论实时信号。</p><h3 id="sigset-t"><a href="#sigset-t" class="headerlink" title="sigset_t"></a>sigset_t</h3><p>由上图可知每个信号都只有一个bit的未决状态，不是0就是1，阻塞标志也是一样。因此阻塞和未决可以用相同的数据类型sigset_t来存储,sigset_t称为信号集，这个类型可以用来表示信号的有效和无效状态，阻塞信号集也叫作当前进程的信号屏蔽字，这里的屏蔽应理解为阻塞而不是忽略。</p><h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><p>以下就是我们常用的信号集操作函数:</p><h4 id="sigemptyset-初始化信号集"><a href="#sigemptyset-初始化信号集" class="headerlink" title="sigemptyset (初始化信号集)"></a>sigemptyset (初始化信号集)</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td><code>int sigemptyset(sigset_t *set);</code></td></tr><tr><td>函数说明</td><td>sigemptyset()用来将参数set信号集初始化并清空。</td></tr><tr><td>返回值</td><td>执行成功则返回0，如果有错误则返回-1。</td></tr><tr><td>错误代码</td><td>EFAULT 参数set指针地址无法存取</td></tr></tbody></table><h4 id="sigfillset（将所有信号加入至信号集）"><a href="#sigfillset（将所有信号加入至信号集）" class="headerlink" title="sigfillset（将所有信号加入至信号集）"></a>sigfillset（将所有信号加入至信号集）</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td><code>int sigfillset(sigset_t * set);</code></td></tr><tr><td>函数说明</td><td>sigfillset()用来将参数set信号集初始化，然后把所有的信号加入到此信号集里。</td></tr><tr><td>返回值</td><td>执行成功则返回0，如果有错误则返回-1。</td></tr><tr><td>附加说明</td><td>EFAULT 参数set指针地址无法存取</td></tr></tbody></table><h4 id="sigaddset（增加一个信号至信号集）"><a href="#sigaddset（增加一个信号至信号集）" class="headerlink" title="sigaddset（增加一个信号至信号集）"></a>sigaddset（增加一个信号至信号集）</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td><code>int sigaddset(sigset_t *set,int signum);</code></td></tr><tr><td>函数说明</td><td>sigaddset()用来将参数signum 代表的信号加入至参数set 信号集里。</td></tr><tr><td>返回值</td><td>执行成功则返回0，如果有错误则返回-1。</td></tr><tr><td>错误代码</td><td>EFAULT 参数set指针地址无法存取 EINVAL 参数signum非合法的信号编号</td></tr></tbody></table><h4 id="sigdelset（从信号集里删除一个信号）"><a href="#sigdelset（从信号集里删除一个信号）" class="headerlink" title="sigdelset（从信号集里删除一个信号）"></a>sigdelset（从信号集里删除一个信号）</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td><code>int sigdelset(sigset_t * set,int signum);</code></td></tr><tr><td>函数说明</td><td>sigdelset()用来将参数signum代表的信号从参数set信号集里删除。</td></tr><tr><td>返回值</td><td>执行成功则返回0，如果有错误则返回-1。</td></tr><tr><td>错误代码</td><td>EFAULT 参数set指针地址无法存取 EINVAL 参数signum非合法的信号编号</td></tr></tbody></table><h4 id="sigismember（测试某个信号是否已加入至信号集里）"><a href="#sigismember（测试某个信号是否已加入至信号集里）" class="headerlink" title="sigismember（测试某个信号是否已加入至信号集里）"></a>sigismember（测试某个信号是否已加入至信号集里）</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td><code>int sigismember(const sigset_t *set,int signum);</code></td></tr><tr><td>函数说明</td><td>sigismember()用来测试参数signum 代表的信号是否已加入至参数set信号集里。如果信号集里已有该信号则返回1，否则返回0。</td></tr><tr><td>返回值</td><td>信号集已有该信号则返回1，没有则返回0。如果有错误则返回-1。</td></tr><tr><td>错误代码</td><td>EFAULT 参数set指针地址无法存取 EINVAL 参数signum 非合法的信号编号</td></tr></tbody></table><h4 id="sigprocmask（查询或设置信号遮罩）"><a href="#sigprocmask（查询或设置信号遮罩）" class="headerlink" title="sigprocmask（查询或设置信号遮罩）"></a>sigprocmask（查询或设置信号遮罩）</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td><code>int sigprocmask(int how,const sigset_t *set,sigset_t * oldset);</code></td></tr><tr><td>函数说明</td><td>sigprocmask()可以用来改变目前的信号遮罩，其操作依参数how来决定<br>SIG_BLOCK 新的信号遮罩由目前的信号遮罩和参数set 指定的信号遮罩作联集<br>SIG_UNBLOCK 将目前的信号遮罩删除掉参数set指定的信号遮罩<br>SIG_SETMASK 将目前的信号遮罩设成参数set指定的信号遮罩。<br>如果参数oldset不是NULL指针，那么目前的信号遮罩会由此指针返回。</td></tr><tr><td>返回值</td><td>执行成功则返回0，如果有错误则返回-1。</td></tr><tr><td>错误代码</td><td>EFAULT 参数set，oldset指针地址无法存取。EINTR 此调用被中断</td></tr></tbody></table><p>注意：在使用sigset_t类型的变量之前一定要用sigemptyset函数和sigfillset函数初始化是信号集处于确定的状态，初始化之后就可以使用sigaddset函数和sigdelset函数在该信号集中增加或者删除有效信号。</p><h4 id="sigpending（查询被搁置的信号）"><a href="#sigpending（查询被搁置的信号）" class="headerlink" title="sigpending（查询被搁置的信号）"></a>sigpending（查询被搁置的信号）</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td><code>int sigpending(sigset_t *set);</code></td></tr><tr><td>函数说明</td><td>sigpending()会将被搁置的信号集合由参数set指针返回。</td></tr><tr><td>返回值执</td><td>行成功则返回0，如果有错误则返回-1。</td></tr><tr><td>错误代码</td><td>EFAULT 参数set指针地址无法存取 EINTR 此调用被中断。</td></tr></tbody></table><h4 id="案例-打印当前未决信号集"><a href="#案例-打印当前未决信号集" class="headerlink" title="案例(打印当前未决信号集)"></a>案例(打印当前未决信号集)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int showsigset(sigset_t *sigset)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (;i &lt;= 32;i++) &#123;</span><br><span class="line">        if (sigismember(sigset, i))&#123;</span><br><span class="line">            printf(&quot;%d&quot;, 1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;%d&quot;, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    sigset_t s,p;</span><br><span class="line">    sigemptyset(&amp;s);</span><br><span class="line">    sigaddset(&amp;s,SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;s,NULL);</span><br><span class="line">    while (1)&#123;</span><br><span class="line">        sigpending(&amp;p);</span><br><span class="line">        showsigset(&amp;p);</span><br><span class="line">        sleep(2);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux code]# ./test            </span><br><span class="line">10000000000000000000000000000000</span><br><span class="line">10000000000000000000000000000000</span><br><span class="line">^\Quit (core dumped)</span><br><span class="line">[root@centos-linux code]# </span><br></pre></td></tr></table></figure></p><h2 id="捕捉信号"><a href="#捕捉信号" class="headerlink" title="捕捉信号"></a>捕捉信号</h2><p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gca1j7mvxzj20dw0bs0vj.jpg" alt="捕捉信号"></p><h3 id="内核如何实现信号的捕捉呢？"><a href="#内核如何实现信号的捕捉呢？" class="headerlink" title="内核如何实现信号的捕捉呢？"></a>内核如何实现信号的捕捉呢？</h3><ol><li>首先在用户正常执行主控制流程由于中断，异常或系统调用而直接进入内核态进行处理处理这种异常，</li><li>内核处理完异常就准备返回用户态了，在这之前会看当前进程有没有可以抵达的信号，如果有就对可递达的信号进行处理，</li><li>如果信号的处理函数是用户自定义的就返回用户态去执行用户自定义的信号处理函数</li><li>信号处理函数执行完之后，会调用一个特殊的系统调用函数sigreturn而再一次进入内核态，执行这个系统调用</li><li>这个系统调用完成之后，就会返回主控制流程被中断的地方继续执行下面的代码</li><li>执行主控制流程的时候如果再次遇到异常、中断或系统调用就继续回到1，继续执行下面的流程</li></ol><h3 id="捕捉信号的函数"><a href="#捕捉信号的函数" class="headerlink" title="捕捉信号的函数"></a>捕捉信号的函数</h3><h4 id="sigaction（查询或设置信号处理方式）"><a href="#sigaction（查询或设置信号处理方式）" class="headerlink" title="sigaction（查询或设置信号处理方式）"></a>sigaction（查询或设置信号处理方式）</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td><code>int sigaction(int signum,const struct sigaction *act ,struct sigaction *oldact);</code></td></tr><tr><td>函数说明</td><td>sigaction()会依参数signum指定的信号编号来设置该信号的处理函数。参数signum可以指定SIGKILL和SIGSTOP以外的所有信号。</td></tr><tr><td>返回值</td><td>执行成功则返回0，如果有错误则返回-1。</td></tr><tr><td>错误代码</td><td>EINVAL 参数signum 不合法， 或是企图拦截SIGKILL/SIGSTOPSIGKILL信号 EFAULT 参数act，oldact指针地址无法存取。EINTR 此调用被中断</td></tr></tbody></table><p>如参数结构sigaction定义如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction</span><br><span class="line">&#123;</span><br><span class="line">void (*sa_handler) (int);</span><br><span class="line">sigset_t sa_mask;</span><br><span class="line">int sa_flags;</span><br><span class="line">void (*sa_restorer) (void);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>sa_handler此参数和signal()的参数handler相同，代表新的信号处理函数，其他意义请参考signal()。</li><li>sa_mask 用来设置在处理该信号时暂时将sa_mask 指定的信号搁置。</li><li>sa_restorer 此参数没有使用。</li><li>sa_flags 用来设置信号处理的其他相关操作，下列的数值可用。<br>OR 运算（|）组合<br>A_NOCLDSTOP : 如果参数signum为SIGCHLD，则当子进程暂停时并不会通知父进程<br>SA_ONESHOT/SA_RESETHAND:当调用新的信号处理函数前，将此信号处理方式改为系统预设的方式。<br>SA_RESTART:被信号中断的系统调用会自行重启<br>SA_NOMASK/SA_NODEFER:在处理此信号未结束前不理会此信号的再次到来。<br>如果参数oldact不是NULL指针，则原来的信号处理方式会由此结构sigaction 返回。</li></ul><h4 id="pause（让进程暂停直到信号出现）"><a href="#pause（让进程暂停直到信号出现）" class="headerlink" title="pause（让进程暂停直到信号出现）"></a>pause（让进程暂停直到信号出现）</h4><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;unistd.h&gt;</code></td></tr><tr><td>定义函数</td><td><code>int pause(void);</code></td></tr><tr><td>函数说明</td><td>pause()会令目前的进程暂停（进入睡眠状态），直到被信号(signal)所中断。</td></tr><tr><td>返回值</td><td>只返回-1。</td></tr><tr><td>错误代码</td><td>EINTR 有信号到达中断了此函数。</td></tr></tbody></table><h4 id="案例-完成自己的sleep函数"><a href="#案例-完成自己的sleep函数" class="headerlink" title="案例(完成自己的sleep函数)"></a>案例(完成自己的sleep函数)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void sig_alrm(int signo)&#123;</span><br><span class="line">    printf(&quot;signo = %d\n&quot;,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int mysleep(unsigned int nsecs)&#123;</span><br><span class="line">    struct sigaction new,old;</span><br><span class="line">    unsigned int unslept = 0;</span><br><span class="line">    new.sa_handler = sig_alrm;</span><br><span class="line">    // 首先进程初始化,以保证信号有一个确定的状态</span><br><span class="line">    sigemptyset(&amp;new.sa_mask);</span><br><span class="line">    new.sa_flags = 0;</span><br><span class="line">    // 注册信号处理函数</span><br><span class="line">    sigaction(SIGALRM,&amp;new,&amp;old);</span><br><span class="line">    // 设定一个闹钟</span><br><span class="line">    alarm(nsecs);</span><br><span class="line">    // 将进程挂起</span><br><span class="line">    pause();</span><br><span class="line">    // 清空闹钟</span><br><span class="line">    unslept = alarm(0);</span><br><span class="line">    // 信号继续执行默认动作</span><br><span class="line">    sigaction(SIGALRM,&amp;old,NULL);</span><br><span class="line">    return unslept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    while (1)&#123;</span><br><span class="line">        mysleep(5);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        printf(&quot;已经过了5秒咯\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux code]# gcc -o test test.c</span><br><span class="line">[root@centos-linux code]# ./test            </span><br><span class="line">signo = 14</span><br><span class="line">已经过了5秒咯</span><br><span class="line">signo = 14</span><br><span class="line">已经过了5秒咯</span><br></pre></td></tr></table></figure></p><h2 id="竞态条件与sigsuspend函数"><a href="#竞态条件与sigsuspend函数" class="headerlink" title="竞态条件与sigsuspend函数"></a>竞态条件与sigsuspend函数</h2><p>我们再来考虑一下以前写的mysleep函数，我们使用alarm函数设定闹钟之后调用pause函数进行等待，可是SIGALRM信号已经处理完了还在等什么呢？</p><p>出现这个问题的根本原因是系统运行的时序并不像我们写程序时想得那样，虽然alarm函数设定闹钟后，后面紧跟的是pause函数，但是不能保证pause函数一定会在nsecs秒之内被调用。由于异步事件在任何时候都可能发生（异步指出现更高优先级的进程），如果我们写程序的时候考虑不周，就有可能会产生时序问题而导致错误，这就叫做竞态条件。</p><p>解决这种问题一般有两种思路，一种是在调用pause之前屏蔽SIGALRM信号使它不能提前递达就好了</p><p>我们将代码执行过程分为四步</p><ol><li>屏蔽SIGALRM信号</li><li>alarm(nsecs)设定闹钟</li><li>解除屏蔽</li><li>pause();</li></ol><p>这样的话SIGALRM信号也可能在解除屏蔽和调用pause之间的时间间隔内递达</p><p>我们又可以设想将解除信号屏蔽放在pause()函数调用之后，执行过程就变为：</p><ol><li>屏蔽SIGALRM信号</li><li>alarm(nsecs)设置闹钟</li><li>pause();</li><li>解除屏蔽</li></ol><p>这样更不行还没有解除屏蔽就调用pause，pause根本不可能等到SIGALRM信号，经过这两步的分析我，我们最想得到的就是将解除屏蔽和等待放在一起，让他们中间不要间断的执行，也就是这两条代码的执行是原子的。sigsuspend函数的功能就是这个</p><p>对时序要求严格的都应该调用sigsuspend函数而不是pause</p><h3 id="sigsuspend-屏蔽新的信号，原来屏蔽的信号失效"><a href="#sigsuspend-屏蔽新的信号，原来屏蔽的信号失效" class="headerlink" title="sigsuspend (屏蔽新的信号，原来屏蔽的信号失效)"></a>sigsuspend (屏蔽新的信号，原来屏蔽的信号失效)</h3><table><thead><tr><th>描述</th><th>内容</th></tr></thead><tbody><tr><td>表头文件</td><td><code>#include&lt;signal.h&gt;</code></td></tr><tr><td>定义函数</td><td><code>int sigsuspend(const sigset_t *mask);</code></td></tr><tr><td>函数说明</td><td>进程执行到sigsuspend时，sigsuspend并不会立刻返回，进程处于TASK_INTERRUPTIBLE状态并立刻放弃CPU，等待UNBLOCK（mask之外的）信号的唤醒。进程在接收到UNBLOCK（mask之外）信号后，调用处理函数，然后还原信号集，sigsuspend返回，进程恢复执行。</td></tr><tr><td>返回值</td><td>sigsuspend返回后将恢复调用之前的的信号掩码。信号处理函数完成后，进程将继续执行。该系统调用始终返回-1，并将errno设置为EINTR.</td></tr></tbody></table><h2 id="SIGCHILD信号"><a href="#SIGCHILD信号" class="headerlink" title="SIGCHILD信号"></a>SIGCHILD信号</h2><p>前面我们知道清除僵尸进程的方法就是使用wait和waitpid函数父进程可以阻塞等待子进程结束，也可以非阻塞的查询是否有子进程需要被清理（轮询）,第一种方式父进程阻塞就不能做其他事情了，第二种，父进程不断去询问，代码实现比较复杂</p><p>其实子进程在终止时会给父进程发一个SIGCHILD信号，默认处理动作是忽略，用户可以自定义SIGCHILD的处理函数，这样父进程就可以专心处理自己的事情，不用关心子进程了，子进程退出时会通知父进程，父进程在信号处理函数中调用wait来处理子进程就可以了    </p><p>补充：想不产生僵尸进程还有另外一种方法：父进程调用sigaction将SIGCHILD处理动作置为SIG_IGN这样fork出的子进程在终止时会自动清理掉也不会通知父进程系统默认的忽略和用户自定义的忽略一般是没有区别的，但这是一个特例，对于Linux可以用，在其他unix系统上不一定能用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信号概念&quot;&gt;&lt;a href=&quot;#信号概念&quot; class=&quot;headerlink&quot; title=&quot;信号概念&quot;&gt;&lt;/a&gt;信号概念&lt;/h2&gt;&lt;p&gt;信号其实我们也见过，当我们在shell上写出一个死循环退不出来的时候，只需要一个组合键，ctrl+c,就可以解决了，这就是一个信号，但是真正的过程并不是那么简单的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当用户按下这一对组合键时，这个键盘输入会产生一个硬件中断，如果CPU正在执行这个进程的代码时，则该进程的用户代码先暂停执行，用户从用户态切换到内核态处理硬件中断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;终端驱动程序将这一对组合键翻译成一个SIGINT(ctrl+c)信号记在该进程的PCB中（也就是发送了一个SIGINT信号给该进程）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当某个时刻要从内核态回到该进程的用户·空间代码继续执行之前，首先处理PCB中的信号，发现有一个SIGINT信号需要处理，而这个信号的默认处理方式是终止进程，所以直接终止进程，不再返回用户空间执行代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;shell可以同时运行一个前台进程和多个后台进程，只有前台进程才能收到ctrl+c这种组合键产生的信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前台进程在 运行过程中用户可以随时按下ctrl+c产生一个信号也就是说前台进程的用户空间代码执行到任意一个时刻都可能接收到SIGINT信号而终止，所以信号对于进程的控制流来说是异步的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：ctrl+c只能终止前台进程。一个命令可以加&amp;amp;可以将进程放在后台执行，这样shell就不必等待进程结束就可以接收新的命令，启动新的进程&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;信号介绍&quot;&gt;&lt;a href=&quot;#信号介绍&quot; class=&quot;headerlink&quot; title=&quot;信号介绍&quot;&gt;&lt;/a&gt;信号介绍&lt;/h2&gt;&lt;p&gt;在bash上执行命令kill -l便可看到系统定义的所有信号&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ kill -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13) SIGPIPE     14) SIGALRM     15) SIGTERM     17) SIGCHLD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30) SIGPWR      31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4  39) SIGRTMIN+5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8  43) SIGRTMIN+9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6  59) SIGRTMAX-5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2  63) SIGRTMAX-1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64) SIGRTMAX&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;列表中，编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)，编号为32 ~ 63的信号是后来扩充的，称做可靠信号(实时信号)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。&lt;/p&gt;
&lt;p&gt;每个信号都有一个编号和一个宏定义名称，这些宏定义都可以在signal.h中找到，在man手册中还可以找到各种信号的详细信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man 7 signal&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面我们对编号小于SIGRTMIN的信号进行讨论。&lt;/p&gt;
&lt;h3 id=&quot;SIGHUP&quot;&gt;&lt;a href=&quot;#SIGHUP&quot; class=&quot;headerlink&quot; title=&quot;SIGHUP&quot;&gt;&lt;/a&gt;SIGHUP&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程-进程回收 </title>
    <link href="http://blog.huixing.org/linux-process-recycl/"/>
    <id>http://blog.huixing.org/linux-process-recycl/</id>
    <published>2020-02-15T14:06:26.000Z</published>
    <updated>2020-02-29T06:15:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>父进程先于子进程结束，则子进程称为孤儿进程，子进程的父进程成为  init 进程，称 init 进程领养进程孤儿进程，init 进程称为孤儿院。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建失败</span></span><br><span class="line">    <span class="keyword">if</span>( pid == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the parent process. My PID is %d.\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------parent going to die------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;This is the child process. My PID is: %d. My PPID is: %d.\n&quot;</span>,getpid(),getppid());</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tanhao@MacBook-Pro test % gcc pro.c </span><br><span class="line">tanhao@MacBook-Pro test % ./a.out  </span><br><span class="line">This is the parent process. My PID is 46491.</span><br><span class="line">This is the child process. My PID is: 46492. My PPID is: 46491.</span><br><span class="line">This is the child process. My PID is: 46492. My PPID is: 46491.</span><br><span class="line">This is the child process. My PID is: 46492. My PPID is: 46491.</span><br><span class="line">--------------parent going to die------------------</span><br><span class="line">tanhao@MacBook-Pro test % This is the child process. My PID is: 46492. My PPID is: 1.</span><br><span class="line">This is the child process. My PID is: 46492. My PPID is: 1.</span><br><span class="line">This is the child process. My PID is: 46492. My PPID is: 1.</span><br></pre></td></tr></table></figure><br>从上面运行结果可以看出来父进程退出后子进程自动被init进程领养ppid为1</p><p>此时程序中的打印信息会一直进行打印，即使你按下 ctrl+c   也不会退出正在执行的程序 ./a.out；此时需要使用 ps -ef ，查看正在打印的程序信息；然后使用 kill -9  + 进程ID（./a.out 的进程ID）</p><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程。</p><p><strong>注意：僵尸进程是不能使用 kill 命令清除掉的。因为 kill 命令只是用来终止进程的，而僵尸进程已经终止。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the parent process. My PID is %d.\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">for</span>(; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the child process. My PID is: %d. My PPID is: %d.\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tanhao@MacBook-Pro test % ./a.out  </span><br><span class="line">This is the parent process. My PID is 46503.</span><br><span class="line">This is the child process. My PID is: 46504. My PPID is: 46503.</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tanhao@MacBook-Pro test % ps aux|grep &quot;a.out&quot;</span><br><span class="line">tanhao           46506   0.0  0.0  4277536    708 s005  S+   10:32下午   0:00.00 grep a.out</span><br><span class="line">tanhao           46504   0.0  0.0        0      0 s000  Z+   10:32下午   0:00.00 (a.out)</span><br><span class="line">tanhao           46503   0.0  0.0  4268180    696 s000  S+   10:32下午   0:00.00 ./a.out</span><br></pre></td></tr></table></figure><p>这里的Z+ 就是僵尸进程(zoom)</p><h2 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait 函数"></a>wait 函数</h2><p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的 PCB 还保留着，内核在其中保留了一些信息。如果是正常终止，则保存退出状态；如果是异常终，则保存着导致该进程终止的信号是哪一个。这个进程的父进程可以调用 wait 或 waitpid 获取这些信息 ，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在 Shell 中用特殊变量 $? 查看，因为 Shell 是它的父进程，当它终止时 Shell 调用 wait 或者 waitpid 得到它的退出状态同时彻底清除掉这个进程。</p><p>父进程调用 wait 函数可以回收子进程终止信息。该函数有三个功能：</p><ol><li>阻塞等待子进程退出</li><li>回收子进程残留资源</li><li>获取子进程结束状态</li></ol><p><code>pid_t wait(int *status);  成功：返回清理掉的子进程 ID；  失败：-1（没有子进程)</code></p><p><strong>当进程终止时，操作系统的隐式回收机制会：</strong></p><ol><li>关闭所有文件描述符</li><li>释放用户空间分配的内存。内核的 PCB 仍存在。其中保存该进程的退出状态。（正常终止—-&gt;退出值；异常终止——-&gt;终止信号）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid,wpid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pid == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        execl(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child,my parent pid = %d,going to sleep 10s\n&quot;</span>,getppid());</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------child die------------------\n&quot;</span>);</span><br><span class="line"><span class="comment">//exit(76);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 回收子进程，避免出现僵尸进程</span></span><br><span class="line"></span><br><span class="line">        wpid = wait(&amp;status);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( wpid == <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;wait error:&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常退出</span></span><br><span class="line">        <span class="keyword">if</span>( WIFEXITED(status) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常退出</span></span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d\n&quot;</span>,WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am parent,my pid = %d,my son = %d\n&quot;</span>,getpid(),pid);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tanhao@MacBook-Pro test % gcc pro.c</span><br><span class="line">tanhao@MacBook-Pro test % ./a.out  </span><br><span class="line">I am child,my parent pid = 46553,going to sleep 10s</span><br><span class="line">-------------child die------------------</span><br><span class="line">child exit with 100</span><br><span class="line">I am parent,my pid = 46553,my son = 46555</span><br><span class="line">I am parent,my pid = 46553,my son = 46555</span><br><span class="line">I am parent,my pid = 46553,my son = 46555</span><br><span class="line">I am parent,my pid = 46553,my son = 46555</span><br></pre></td></tr></table></figure></p><p>由上面运行结果我们可以看出,<code>wait</code>是阻塞等待子进程退出.子进程退出后,才执行<code>printf(&quot;I am parent,my pid = %d,my son = %d\n&quot;,getpid(),pid);</code></p><h2 id="回收结果"><a href="#回收结果" class="headerlink" title="回收结果"></a>回收结果</h2><p>回收结果可使用<code>wait</code>或者<code>waitpid</code> 函数传出参数 status 来保存进程的退出状态，借助宏函数来进一步判断进程终止的具体原因，宏函数可分为如下六种</p><ul><li>WIFEXITED(status)如果子进程正常结束则为非0值。</li><li>WEXITSTATUS(status)取得子进程exit()返回的结束代码，一般会先用WIFEXITED 来判断是否正常结束才能使用此宏。</li><li>WIFSIGNALED(status)如果子进程是因为信号而结束则此宏值为真</li><li>WTERMSIG(status)取得子进程因信号而中止的信号代码，一般会先用WIFSIGNALED 来判断后才使用此宏。</li><li>WIFSTOPPED(status)如果子进程处于暂停执行情况则此宏值为真。一般只有使用WUNTRACED 时才会有此情况。</li><li>WSTOPSIG(status)取得引发子进程暂停的信号代码，一般会先用WIFSTOPPED 来判断后才使用此宏。</li></ul><h2 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid 函数"></a>waitpid 函数</h2><p>作用同 wait ，但可指定 pid 进程清理，可以不阻塞。</p><p><code>pid_t waitpid(pid_t pid, int *status, int options);</code></p><p><strong>函数说明</strong></p><p>waitpid()会暂时停止目前进程的执行，直到有信号来到或子进程结束。</p><p>如果在调用wait()时子进程已经结束，则wait()会立即返回子进程结束状态值。</p><p>子进程的结束状态值会由参数status返回，而子进程的进程识别码也会一快返回。</p><p>如果不在意结束状态值，则参数status可以设成NULL。</p><p><strong>参数pid</strong></p><p>为欲等待的子进程识别码，其他数值意义如下:</p><ul><li>pid &lt; -1 等待进程组识别码为pid绝对值的任何子进程。</li><li>pid = -1 等待任何子进程，相当于wait()。</li><li>pid = 0 等待进程组识别码与目前进程相同的任何子进程。</li><li>pid &gt; 0 等待任何子进程识别码为pid的子进程。</li></ul><p><strong>参数option</strong></p><ul><li><p>可以为0 或下面的OR 组合</p><ul><li><p>WNOHANG 如果没有任何已经结束的子进程则马上返回，不予以等待。</p></li><li><p>WUNTRACED 如果子进程进入暂停执行情况则马上返回，但结束状态不予以理会。子进程的结束状态返回后存于status.</p></li></ul></li></ul><p><strong>返回值</strong></p><p>如果执行成功则返回子进程识别码(PID)，如果有错误发生则返回-1。失败原因存于errno中。</p><p><strong>注意</strong></p><p>一次 wait 或者 waitpid 调用只能清理一个子进程，清理若干个子进程应该使用循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>, i;   <span class="comment">// 默认创建 5 个子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> p, q;</span><br><span class="line">    <span class="keyword">pid_t</span> wid;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">        n = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">// 出口1  父进程专用出口</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = fork();</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">// 出口 2 子进程出口，i 不自增</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等子进程创建完毕后开始运行</span></span><br><span class="line">    <span class="keyword">if</span> (n == i) &#123;</span><br><span class="line">        sleep(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent ,pid = %d, gpid = %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        <span class="comment">// while(wait(NULL));</span></span><br><span class="line">        <span class="comment">// wait(NULL);</span></span><br><span class="line">        <span class="comment">//  waitpid(q,NULL,0);  // 回收 4 儿子的资源， 此时 waitpid 的作用等价于 wait 函数 阻塞版</span></span><br><span class="line">        <span class="comment">//  while(waitpid(-1,NULL,0));   // 回收所有子进程  == wait(NULL);</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            wid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recyc wid = %d\n&quot;</span>, wid);</span><br><span class="line">            <span class="keyword">if</span> (wid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if wid == 0 说明子进程正在运行</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (n &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait finish\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am %dth child,pid = %d,gpid = %d\n&quot;</span>, i + <span class="number">1</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tanhao@MacBook-Pro test % ./a.out  </span><br><span class="line">I am 1th child,pid = 46663,gpid = 46662</span><br><span class="line">I am 2th child,pid = 46664,gpid = 46662</span><br><span class="line">I am 3th child,pid = 46665,gpid = 46662</span><br><span class="line">I am 4th child,pid = 46666,gpid = 46662</span><br><span class="line">I am 5th child,pid = 46667,gpid = 46662</span><br><span class="line">I am parent ,pid = 46662, gpid = 24409</span><br><span class="line">wid = 46667</span><br><span class="line">wid = 46666</span><br><span class="line">wid = 46665</span><br><span class="line">wid = 46664</span><br><span class="line">wid = 46663</span><br><span class="line">wait finish</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    需求:</span></span><br><span class="line"><span class="comment">         父进程 fork 3 个子进程，三个子进程 一个调用 ps 命令，一个调用自定义程序1（正常），一个调用自定义程序1（会出错误）。</span></span><br><span class="line"><span class="comment">         父进程会使用 waitpid 对子进程进行回收。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">3</span>,i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">pid_t</span> wid;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;n;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="keyword">if</span>( pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( pid == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am %d child,pid = %d,ppid = %d\n\n&quot;</span>,i+<span class="number">1</span>,getpid(),getppid());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对第一个子进程执行 ps 操作</span></span><br><span class="line">    <span class="keyword">if</span>( i== <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am %d child,pid = %d,ppid = %d\n\n&quot;</span>,i+<span class="number">1</span>,getpid(),getppid());</span><br><span class="line"></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;-ef&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 对第二子进程 执行自定义程序1 (正常)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( i==<span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am %d child,pid = %d,ppid = %d\n\n&quot;</span>,i+<span class="number">1</span>,getpid(),getppid());</span><br><span class="line"></span><br><span class="line">        execl(<span class="string">&quot;main&quot;</span>,<span class="string">&quot;main&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对第三子进程 执行自定义程序2 (错误)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( i==<span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am %d child,pid = %d,ppid = %d\n\n&quot;</span>,i+<span class="number">1</span>,getpid(),getppid());</span><br><span class="line"></span><br><span class="line">        execl(<span class="string">&quot;abnor&quot;</span>,<span class="string">&quot;abnor&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程回收子进程资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意：这里不能使用阻塞版本的 waitpid,而要使用非阻塞版的 waitpid ，不然程序组塞住了。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            wid=waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">            <span class="keyword">if</span>( wid &gt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span>( i &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; wait finnaly!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个运行结果有点多,这里就不贴了自己可以试试</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;孤儿进程&quot;&gt;&lt;a href=&quot;#孤儿进程&quot; class=&quot;headerlink&quot; title=&quot;孤儿进程&quot;&gt;&lt;/a&gt;孤儿进程&lt;/h2&gt;&lt;p&gt;父进程先于子进程结束，则子进程称为孤儿进程，子进程的父进程成为  init 进程，称 init 进程领养进程孤儿进程，init 进程称为孤儿院。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pid_t&lt;/span&gt; pid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pid = fork();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建失败&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( pid == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        perror(&lt;span class=&quot;string&quot;&gt;&amp;quot;fork&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 父进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( pid &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;This is the parent process. My PID is %d.\n&amp;quot;&lt;/span&gt;,getpid());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sleep(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;--------------parent going to die------------------\n&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 子进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;This is the child process. My PID is: %d. My PPID is: %d.\n&amp;quot;&lt;/span&gt;,getpid(),getppid());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果:&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tanhao@MacBook-Pro test % gcc pro.c &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tanhao@MacBook-Pro test % ./a.out  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This is the parent process. My PID is 46491.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This is the child process. My PID is: 46492. My PPID is: 46491.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This is the child process. My PID is: 46492. My PPID is: 46491.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This is the child process. My PID is: 46492. My PPID is: 46491.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--------------parent going to die------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tanhao@MacBook-Pro test % This is the child process. My PID is: 46492. My PPID is: 1.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This is the child process. My PID is: 46492. My PPID is: 1.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This is the child process. My PID is: 46492. My PPID is: 1.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;从上面运行结果可以看出来父进程退出后子进程自动被init进程领养ppid为1&lt;/p&gt;
&lt;p&gt;此时程序中的打印信息会一直进行打印，即使你按下 ctrl+c   也不会退出正在执行的程序 ./a.out；此时需要使用 ps -ef ，查看正在打印的程序信息；然后使用 kill -9  + 进程ID（./a.out 的进程ID）&lt;/p&gt;
&lt;h2 id=&quot;僵尸进程&quot;&gt;&lt;a href=&quot;#僵尸进程&quot; class=&quot;headerlink&quot; title=&quot;僵尸进程&quot;&gt;&lt;/a&gt;僵尸进程&lt;/h2&gt;&lt;p&gt;进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：僵尸进程是不能使用 kill 命令清除掉的。因为 kill 命令只是用来终止进程的，而僵尸进程已经终止。&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pid_t&lt;/span&gt; pid=fork();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        perror(&lt;span class=&quot;string&quot;&gt;&amp;quot;fork failed.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;This is the parent process. My PID is %d.\n&amp;quot;&lt;/span&gt;, getpid());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(; i &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i--)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;This is the child process. My PID is: %d. My PPID is: %d.\n&amp;quot;&lt;/span&gt;, getpid(), getppid());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果:&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tanhao@MacBook-Pro test % ./a.out  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This is the parent process. My PID is 46503.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This is the child process. My PID is: 46504. My PPID is: 46503.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 生成静态链接库与动态链接库</title>
    <link href="http://blog.huixing.org/linux-generates-static-link-library-and-dynamic-link-library/"/>
    <id>http://blog.huixing.org/linux-generates-static-link-library-and-dynamic-link-library/</id>
    <published>2020-02-10T06:11:12.000Z</published>
    <updated>2020-02-10T11:30:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>所谓的库就是一种可执行代码的二进制形式，可以被操作系统载入内存执行。</p><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><h3 id="静态库-a"><a href="#静态库-a" class="headerlink" title="静态库 .a"></a>静态库 .a</h3><p>文件的命名方式：“libxxx.a”,库名前加“lib”，后缀是“.a”,库名是“xxx”</p><p>链接时间：静态库的代码是在编译过程中被载入到程序中的</p><p>链接方式：静态库的链接是将整个函数库的所有数据都合成进了目标代码，优点是编译后的执行程序不需要外部的函数库支持，因为所使用的函数已经被编进去了；缺点是如果所使用的静态库发生更新改变，则需要重新编译生成静态库。</p><h3 id="动态库-so"><a href="#动态库-so" class="headerlink" title="动态库 .so"></a>动态库 .so</h3><p>文件命名方式：“libxxx.so”,库名前加“lib”，后缀是“.so”，库名是“xxx”</p><p>链接时间：动态库在编译时并没有被编译进目标代码，而是当你的程序执行到相关函数的时候才调用该函数库里的相应函数。缺点是函数库并没有整合进程序，所以程序的运行环境必须提供相应的库；优点是动态库的改变不影响程序。</p><p>二者的区别：同一个程序分别使用静态库和动态库生成两个可执行文件时，静态库链接所生成的那个可执行文件要比动态库链接所生成的可执行文件占用的空间大。</p><h2 id="gcc常用参数"><a href="#gcc常用参数" class="headerlink" title="gcc常用参数"></a>gcc常用参数</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>指定目标</td></tr><tr><td>c</td><td>生成二进制汇编文件</td></tr><tr><td>W</td><td>警告all</td></tr><tr><td>g</td><td>gdb调试</td></tr><tr><td>E,S</td><td>预处理和汇编</td></tr><tr><td>D</td><td>debug调试</td></tr><tr><td>I</td><td>指定包含路径</td></tr><tr><td>L</td><td>指定库路径</td></tr><tr><td>l</td><td>指定库名,libxxx.a,libxxx.so</td></tr></tbody></table><h2 id="文件准备"><a href="#文件准备" class="headerlink" title="文件准备"></a>文件准备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux static link library]# tree</span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h // 头文件</span><br><span class="line">├── lib</span><br><span class="line">│   ├── add.c // 加法</span><br><span class="line">│   └── sub.c // 减法</span><br><span class="line">└── main.c</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br></pre></td></tr></table></figure><p>head.h<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int add (int a, int b);</span><br><span class="line">int sub (int a, int b);</span><br></pre></td></tr></table></figure><br>add.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sub.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>main.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="静态库生成"><a href="#静态库生成" class="headerlink" title="静态库生成"></a>静态库生成</h2><ol><li>使用如下命令，将.c文件生成.o的汇编文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux lib]# gcc -c *.c -I ../include/</span><br><span class="line">[root@centos-linux lib]# ls</span><br><span class="line">add.c  add.o  sub.c  sub.o</span><br><span class="line">[root@centos-linux lib]# </span><br></pre></td></tr></table></figure><ol start="2"><li>由.o文件生成.a的静态库文件，静态库的名字问libCalc.a</li></ol><p><code>ar rcs libCalc.a *.o</code></p><p>执行完毕后可以通过目录看到多了一个libCalc.a的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux static link library]# tree</span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   ├── add.c</span><br><span class="line">│   ├── add.o</span><br><span class="line">│   ├── libCalc.a</span><br><span class="line">│   ├── sub.c</span><br><span class="line">│   └── sub.o</span><br><span class="line">└── main.c</span><br><span class="line"></span><br><span class="line">2 directories, 7 files</span><br></pre></td></tr></table></figure><p>nm查看文件链接符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux lib]# nm libCalc.a</span><br><span class="line"></span><br><span class="line">add.o:</span><br><span class="line">0000000000000000 T add</span><br><span class="line"></span><br><span class="line">sub.o:</span><br><span class="line">0000000000000000 T sub</span><br></pre></td></tr></table></figure><ol start="3"><li>使用静态库进行静态链接，生成可执行文件app</li></ol><p><code>gcc main.c -o app -I include/ -L lib/ -lCalc</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux static link library]# gcc main.c -o app -I include/ -L lib/ -lCalc</span><br><span class="line">[root@centos-linux static link library]# ls</span><br><span class="line">app  include  lib  main.c</span><br><span class="line">[root@centos-linux static link library]# ./app</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="动态库生成"><a href="#动态库生成" class="headerlink" title="动态库生成"></a>动态库生成</h2><ol><li>使用如下命令，将.c文件生成.o的汇编文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux lib]# gcc -c *.c -I ../include/</span><br><span class="line">[root@centos-linux lib]# ls</span><br><span class="line">add.c  add.o  sub.c  sub.o</span><br><span class="line">[root@centos-linux lib]# </span><br></pre></td></tr></table></figure><ol start="2"><li>生成动态库</li></ol><p><code>gcc -fPIC -shared -o libCalc.so *.o</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux lib]<span class="meta"># gcc -fPIC -shared -o libCalc.so *.o  </span></span><br><span class="line">[root@centos-linux <span class="keyword">static</span> link library]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   ├── add.c</span><br><span class="line">│   ├── add.o</span><br><span class="line">│   ├── libCalc.so</span><br><span class="line">│   ├── sub.c</span><br><span class="line">│   └── sub.o</span><br><span class="line">└── main.c</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> directories, <span class="number">8</span> files</span><br></pre></td></tr></table></figure><ol start="3"><li>链接生成可执行文件</li></ol><p><code>gcc main.c -o app -I include/ -L lib/ -lCalc</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux static link library]# gcc main.c -o app -I include/ -L lib/ -lCalc</span><br></pre></td></tr></table></figure><p>生成的可执行文件是app，./app执行可执行文件时报如下错<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux static link library]# ./app </span><br><span class="line">./app: error while loading shared libraries: libCalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure></p><p>因为执行程序找不到libCalc.so</p><p>用：ldd app命令查看libCalc.so库，发现其找不到</p><h3 id="找不到lib库解决方案"><a href="#找不到lib库解决方案" class="headerlink" title="找不到lib库解决方案"></a>找不到lib库解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>原因是在 /etc/ld.so.conf 文件中设置了动态链接库了寻找路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-linux lib]# vi /etc/ld.so.conf</span><br><span class="line">include ld.so.conf.d/*.conf</span><br><span class="line">#加上自己编译的lib目录</span><br><span class="line">/root/CppCode/static link library/lib</span><br></pre></td></tr></table></figure><p>可以看到有很多路径设置文件，在ld.so.conf文件中添加libCalc.so的路径</p><p>然后执行：ldconfig命令</p><p>此时执行可执行文件app就能成功了。</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>将编译好的链接库拷贝到/bin,/usr/lib这样的系统库目录下</p><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>设置环境变量,LD_LIBRAY_PATH, export LD_LIBRAY_PATH=libpath:$LD_LIBRAY_PATH</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;库&quot;&gt;&lt;a href=&quot;#库&quot; class=&quot;headerlink&quot; title=&quot;库&quot;&gt;&lt;/a&gt;库&lt;/h2&gt;&lt;p&gt;所谓的库就是一种可执行代码的二进制形式，可以被操作系统载入内存执行。&lt;/p&gt;
&lt;h2 id=&quot;静态库和动态库&quot;&gt;&lt;a href=&quot;#静态库和动态库&quot; class=&quot;headerlink&quot; title=&quot;静态库和动态库&quot;&gt;&lt;/a&gt;静态库和动态库&lt;/h2&gt;&lt;h3 id=&quot;静态库-a&quot;&gt;&lt;a href=&quot;#静态库-a&quot; class=&quot;headerlink&quot; title=&quot;静态库 .a&quot;&gt;&lt;/a&gt;静态库 .a&lt;/h3&gt;&lt;p&gt;文件的命名方式：“libxxx.a”,库名前加“lib”，后缀是“.a”,库名是“xxx”&lt;/p&gt;
&lt;p&gt;链接时间：静态库的代码是在编译过程中被载入到程序中的&lt;/p&gt;
&lt;p&gt;链接方式：静态库的链接是将整个函数库的所有数据都合成进了目标代码，优点是编译后的执行程序不需要外部的函数库支持，因为所使用的函数已经被编进去了；缺点是如果所使用的静态库发生更新改变，则需要重新编译生成静态库。&lt;/p&gt;
&lt;h3 id=&quot;动态库-so&quot;&gt;&lt;a href=&quot;#动态库-so&quot; class=&quot;headerlink&quot; title=&quot;动态库 .so&quot;&gt;&lt;/a&gt;动态库 .so&lt;/h3&gt;&lt;p&gt;文件命名方式：“libxxx.so”,库名前加“lib”，后缀是“.so”，库名是“xxx”&lt;/p&gt;
&lt;p&gt;链接时间：动态库在编译时并没有被编译进目标代码，而是当你的程序执行到相关函数的时候才调用该函数库里的相应函数。缺点是函数库并没有整合进程序，所以程序的运行环境必须提供相应的库；优点是动态库的改变不影响程序。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程-线程</title>
    <link href="http://blog.huixing.org/linux-system-program-of-thread/"/>
    <id>http://blog.huixing.org/linux-system-program-of-thread/</id>
    <published>2019-11-11T16:05:00.000Z</published>
    <updated>2019-11-12T02:26:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p><p>线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。</p><p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。<br>一个进程可以有很多线程，每条线程并行执行不同的任务。</p><p>在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。</p><ul><li>LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)</li><li>进程：独立地址空间，拥有PCB</li><li>线程：也有PCB，但没有独立的地址空间(共享)</li><li>区别：在于是否共享地址空间。<ul><li>独居(进程)</li><li>合租(线程)</li></ul></li></ul><p><strong>Linux下：</strong></p><ul><li>线程：最小的执行单位</li><li>进程：最小分配资源单位，可看成是只有一个线程的进程。</li></ul><p><img src="http://ww1.sinaimg.cn/large/a3eed545ly1g8ujxj4xb0j205m02gt8j.jpg" alt="image.png"></p><h2 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h2><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p><ol><li>轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li><li>从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</li><li>进程可以蜕变成线程</li><li>线程可看做寄存器和栈的集合</li><li>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</li></ol><p><strong>查看LWP号：ps –Lf pid 查看指定线程的lwp号。</strong></p><p><img src="http://ww1.sinaimg.cn/large/a3eed545ly1g8uk0uf5gej209j06iabu.jpg" alt="image.png"></p><p>三级映射：进程PCB –&gt; 页目录(可看成数组，首地址位于PCB中) –&gt; 页表 –&gt; 物理页面 –&gt; 内存单元</p><p>参考：《Linux内核源代码情景分析》 —-毛德操</p><p>对于进程来说，相同的地址(同一个虚拟地址)在不同的进程中，反复使用而不冲突。原因是他们虽虚拟址一样，但，页目录、页表、物理页面各不相同。相同的虚拟址，映射到不同的物理页面内存单元，最终访问不同的物理页面。</p><p>但！线程不同！两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。</p><p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。</p><p>如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。</p><p>因此：Linux内核是不区分进程和线程的。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p><h2 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h2><ol><li>文件描述符表</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户ID和组ID</li><li>内存地址空间 (.text/.data/.bss/heap/共享库)</li></ol><h2 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h2><ol><li>线程id</li><li>处理器现场和栈指针(内核栈)</li><li>独立的栈空间(用户空间栈)</li><li>errno变量</li><li>信号屏蔽字</li><li>调度优先级</li></ol><h2 id="线程优、缺点"><a href="#线程优、缺点" class="headerlink" title="线程优、缺点"></a>线程优、缺点</h2><p>优点：</p><ol><li>提高程序并发性</li><li>开销小</li><li>数据通信、共享数据方便</li></ol><p>缺点：</p><ol><li>库函数，不稳定</li><li>调试、编写困难、gdb不支持</li><li>对信号支持不好</li></ol><p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p><h2 id="线程控制函数"><a href="#线程控制函数" class="headerlink" title="线程控制函数"></a>线程控制函数</h2><h3 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h3><p>获取线程ID。其作用对应进程中 getpid() 函数。</p><ul><li><code>pthread_t pthread_self(void);</code><br>  返回值：成功：0；<br>  失败：无！</li></ul><p>线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现<br>线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)</p><p>注意：不应使用全局变量 pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</p><h3 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h3><p>创建一个新线程。<br>其作用，对应进程中fork() 函数。</p><ul><li><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code></li></ul><p>返回值：成功：0；    失败：错误号    —–Linux环境下，所有线程特点，失败均直接返回错误号。<br>参数：<br>pthread_t：当前Linux中可理解为：typedef unsigned long int pthread_t。</p><ol><li>传出参数，保存系统为我们分配好的线程ID</li><li>通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。</li><li>函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。</li><li>线程主函数执行期间所使用的参数。</li></ol><p>在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void <em>，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void </em>，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态，稍后详细介绍pthread_join。</p><p>pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2)可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self(3)可以获得当前线程的id。</p><p>attr参数表示线程属性，本节不深入讨论线程属性，所有代码例子都传NULL给attr参数，表示线程属性取缺省值，感兴趣的读者可以参考APUE。</p><p>创建线程示例:</p><p>创建一个新线程，打印线程ID。注意：链接线程库 -lpthread<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tfn-- pid = %d, tid = %lu\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main -- pid = %d, tid = %lu\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;pthread_create erro: %s\n&quot;, strerror(ret));</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;pthread_create erro: %s\n&quot;</span>, <span class="built_in">strerror</span>(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于pthread_create的错误码不保存在errno中，因此不能直接用perror(3)打印错误信息，可以先用strerror(3)把错误码转换成错误信息再打印。如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</p><p>创建多线程示例:</p><p>循环创建多个线程，每个线程打印自己是第几个被创建的线程。(类似于进程循环创建子进程)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="built_in">sleep</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %dth pthread   tid = %lu\n&quot;</span>, i+<span class="number">1</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, tfn, (<span class="keyword">void</span> *)&amp;i);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, <span class="built_in">strerror</span>(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----I&#x27;m main pthread  tid = %lu\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h3><p>将单个线程退出</p><ul><li><code>void pthread_exit(void *retval);</code>    参数：retval表示线程退出状态，通常传NULL</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line"><span class="comment">//    sleep(i);</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %dth pthread   tid = %lu\n&quot;</span>, i+<span class="number">1</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, tfn, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, <span class="built_in">strerror</span>(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----I&#x27;m main pthread  tid = %lu\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程中，禁止使用exit函数，会导致进程内所有线程全部退出。</p><p>在不添加sleep控制输出顺序的情况下。pthread_create在循环中，几乎瞬间创建5个线程，但只有第1个线程有机会输出（或者第2个也有，也可能没有，取决于内核调度）如果第3个线程执行了exit，将整个进程退出了，所以全部线程退出了。</p><p>所以，多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。</p><p>另注意，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</p><h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h3><p>阻塞等待线程退出，获取线程退出状态.其作用，对应进程中 waitpid() 函数。</p><ul><li><code>int pthread_join(pthread_t thread, void **retval);</code> 成功：0；失败：错误号</li></ul><p>参数：thread：线程ID （【注意】：不是指针）；retval：存储线程结束状态。</p><p>对比记忆：<br>进程中：main返回值、exit参数–&gt;int；等待子进程结束 wait 函数参数–&gt;int <em><br>线程中：线程主函数返回值、pthread_exit–&gt;void </em>；等待线程结束 pthread_join 函数参数–&gt;void **</p><p>示例:<br>参数 retval 非空用法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125; <span class="keyword">exit_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">exit_t</span> *ret;</span><br><span class="line">ret = <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">exit_t</span>)); </span><br><span class="line"></span><br><span class="line">ret-&gt;a = <span class="number">100</span>;</span><br><span class="line">ret-&gt;b = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">pthread_exit</span>((<span class="keyword">void</span> *)ret);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//should not be here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">exit_t</span> *retval;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*调用pthread_join可以获取线程的退出状态*/</span></span><br><span class="line"><span class="built_in">pthread_join</span>(tid, (<span class="keyword">void</span> **)&amp;retval);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d \n&quot;</span>, retval-&gt;a, retval-&gt;b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</p><ol><li>如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</li><li>如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。</li><li>如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</li><li>如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。</li></ol><p>示例:使用pthread_join函数将循环创建的多个子线程回收。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i = (<span class="keyword">int</span>)arg;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sleep</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;    <span class="comment">//i = 0  100  333  333  777  777  </span></span><br><span class="line">        var = <span class="number">333</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;var = %d\n&quot;</span>, var);</span><br><span class="line">        <span class="built_in">pthread_exit</span>((<span class="keyword">void</span> *)var);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">        var = <span class="number">777</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %dth pthread, pthread_id = %lu\n var = %d\n&quot;</span>, i+<span class="number">1</span>, <span class="built_in">pthread_self</span>(), var);</span><br><span class="line">        <span class="built_in">pthread_exit</span>((<span class="keyword">void</span> *)var);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %dth pthread, pthread_id = %lu\n var = %d\n&quot;</span>, i+<span class="number">1</span>, <span class="built_in">pthread_self</span>(), var);</span><br><span class="line">        <span class="built_in">pthread_exit</span>((<span class="keyword">void</span> *)var);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> i, *ret[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid[i], <span class="literal">NULL</span>, tfn, (<span class="keyword">void</span> *)i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(tid[i], (<span class="keyword">void</span> **)&amp;ret[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------%d &#x27;s ret = %d\n&quot;</span>, i, (<span class="keyword">int</span>)ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m main pthread tid = %lu\t var = %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h3><p>实现线程分离</p><ul><li><code>int pthread_detach(pthread_t thread);</code>    成功：0；失败：错误号</li></ul><p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p><p>进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</p><p>也可使用 pthread_create函数参2(线程属性)来设置线程分离。</p><p>示例:使用pthread_detach函数实现线程分离<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread tfn n = %d\n&quot;</span>, n);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> retvar = <span class="built_in">pthread_join</span>(tid, (<span class="keyword">void</span> **)&amp;ret);</span><br><span class="line">    <span class="keyword">if</span> (retvar != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;pthread_join error %s\n&quot;</span>, <span class="built_in">strerror</span>(retvar));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread exit with %d\n&quot;</span>, (<span class="keyword">int</span>)ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL。如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p><h3 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h3><p>杀死(取消)线程            其作用，对应进程中 kill() 函数。</p><ul><li><code>int pthread_cancel(pthread_t thread);</code>    成功：0；失败：错误号</li></ul><p><strong>线程的取消并不是实时的，而又一定的延时。需要等待线程到达某个取消点(检查点)。</strong></p><p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p><p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write…..</p><blockquote><p>——参 APUE.12.7 取消选项。</p></blockquote><p>可粗略认为一个系统调用(进入内核)即为一个取消点。</p><p>被取消的线程，退出值，定义在Linux的pthread库中常数PTHREAD_CANCELED的值是-1。可以在头文件pthread.h中找到它的定义：#define PTHREAD_CANCELED ((void *) -1)</p><p>示例:终止线程的三种方法。注意“取消点”的概念。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread 1 returning\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">111</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread 2 exiting\n&quot;</span>);</span><br><span class="line"><span class="built_in">pthread_exit</span>((<span class="keyword">void</span> *)<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn3</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//printf(&quot;thread 3: I&#x27;m going to die 1 seconds after...\n&quot;);</span></span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line"><span class="built_in">pthread_testcancel</span>();<span class="comment">//自己添加取消点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">void</span> *tret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, tfn1, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">pthread_join</span>(tid, &amp;tret);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread 1 exit code = %d\n\n&quot;</span>, (<span class="keyword">int</span>)tret);</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, tfn2, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">pthread_join</span>(tid, &amp;tret);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread 2 exit code = %d\n\n&quot;</span>, (<span class="keyword">int</span>)tret);</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, tfn3, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">pthread_cancel</span>(tid);</span><br><span class="line"><span class="built_in">pthread_join</span>(tid, &amp;tret);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread 3 exit code = %d\n&quot;</span>, (<span class="keyword">int</span>)tret);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="pthread-equal函数"><a href="#pthread-equal函数" class="headerlink" title="pthread_equal函数"></a>pthread_equal函数</h3><p>比较两个线程ID是否相等。</p><ul><li><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></li></ul><p>有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。</p><h3 id="终止线程方式"><a href="#终止线程方式" class="headerlink" title="终止线程方式"></a>终止线程方式</h3><p>总结：终止某个线程而不终止整个进程，有三种方法：</p><ol><li>从线程主函数return。这种方法对主控线程不适用，从main函数return相当于调用exit。</li><li>一个线程可以调用pthread_cancel终止同一进程中的另一个线程。</li><li>线程可以调用pthread_exit终止自己。</li></ol><h3 id="线程与共享"><a href="#线程与共享" class="headerlink" title="线程与共享"></a>线程与共享</h3><p><strong>线程默认共享数据段、代码段等地址空间，常用的是全局变量。而进程不共享全局变量，只能借助mmap。</strong></p><p>示例:设计程序，验证线程之间共享全局数据。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">var = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;At first var = %d\n&quot;</span>, var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after pthread_create, var = %d\n&quot;</span>, var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="控制原语对比"><a href="#控制原语对比" class="headerlink" title="控制原语对比"></a>控制原语对比</h3><table><thead><tr><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>fork</td><td>pthread_create</td></tr><tr><td>exit</td><td>pthread_exit</td></tr><tr><td>wait</td><td>pthread_join</td></tr><tr><td>kill</td><td>pthread_cancel</td></tr><tr><td>getpid</td><td>pthread_self</td></tr></tbody></table><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> etachstate; <span class="comment">//线程的分离状态</span></span><br><span class="line">    <span class="keyword">int</span> schedpolicy; <span class="comment">//线程调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span><span class="title">schedparam</span>;</span> <span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="keyword">int</span> inheritsched; <span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="keyword">int</span> scope; <span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="keyword">size_t</span> guardsize; <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span>stackaddr_set; <span class="comment">//线程的栈设置</span></span><br><span class="line">    <span class="keyword">void</span>* stackaddr; <span class="comment">//线程栈的位置</span></span><br><span class="line">    <span class="keyword">size_t</span> stacksize; <span class="comment">//线程栈的大小</span></span><br><span class="line">&#125; <span class="keyword">pthread_attr_t</span>; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要结构体成员：</p><ol><li>线程分离状态</li><li>线程栈大小（默认平均分配）</li><li>线程栈警戒缓冲区大小（位于栈末尾）参 APUE.12.3 线程属性</li><li>线程栈最低地址</li></ol><p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为<code>pthread_attr_init</code>，这个函数必须在<code>pthread_create</code>函数之前调用。之后须用<code>pthread_attr_destroy</code>函数来释放资源。</p><p>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p><h2 id="线程属性初始化"><a href="#线程属性初始化" class="headerlink" title="线程属性初始化"></a>线程属性初始化</h2><p>注意：应先初始化线程属性，再pthread_create创建线程<br>初始化线程属性</p><ul><li><code>int pthread_attr_init(pthread_attr_t *attr);</code> 成功：0；失败：错误号<br>销毁线程属性所占用的资源</li><li><code>int pthread_attr_destroy(pthread_attr_t *attr);</code> 成功：0；失败：错误号</li></ul><h2 id="线程的分离状态"><a href="#线程的分离状态" class="headerlink" title="线程的分离状态"></a>线程的分离状态</h2><p>线程的分离状态决定一个线程以什么样的方式来终止自己。</p><p>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</p><p>分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</p><p>线程分离状态的函数：</p><p>设置线程属性，分离or非分离<code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code></p><p>获取程属性，分离or非分离<code>pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);</code></p><p>参数：</p><ol><li>attr：已初始化的线程属性</li><li>detachstate：<ul><li>PTHREAD_CREATE_DETACHED（分离线程）</li><li>PTHREAD _CREATE_JOINABLE（非分离线程）</li></ul></li></ol><p>这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p><h2 id="线程的栈地址"><a href="#线程的栈地址" class="headerlink" title="线程的栈地址"></a>线程的栈地址</h2><p>POSIX.1定义了两个常量<code>_POSIX_THREAD_ATTR_STACKADDR</code> 和<code>_POSIX_THREAD_ATTR_STACKSIZE</code>检测系统是否支持栈属性。也可以给<code>sysconf</code>函数传递<code>_SC_THREAD_ATTR_STACKADDR</code>或 <code>_SC_THREAD_ATTR_STACKSIZE</code>来进行检测。</p><p>当进程栈地址空间不够用时，指定新建线程使用由<code>malloc</code>分配的空间作为自己的栈空间。通过<code>pthread_attr_setstack</code>和<code>pthread_attr_getstack</code>两个函数分别设置和获取线程的栈地址。</p><ul><li><code>int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);</code>成功：0；失败：错误号</li><li><code>int pthread_attr_getstack(pthread_attr_t *attr, void **stackaddr, size_t *stacksize);</code>成功：0；失败：错误号</li></ul><p>参数:</p><ol><li>attr：指向一个线程属性的指针</li><li>stackaddr：返回获取的栈地址</li><li>stacksize：返回获取的栈大小</li></ol><h2 id="线程的栈大小"><a href="#线程的栈大小" class="headerlink" title="线程的栈大小"></a>线程的栈大小</h2><p>当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用,当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。<br>函数<code>pthread_attr_getstacksize</code>和 <code>pthread_attr_setstacksize</code>提供设置。</p><ul><li><code>int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);</code>成功：0；失败：错误号</li><li><code>int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);</code> 成功：0；失败：错误号</li></ul><p>参数：    attr：指向一个线程属性的指针<br>stacksize：返回线程的堆栈大小</p><h2 id="线程属性控制示例"><a href="#线程属性控制示例" class="headerlink" title="线程属性控制示例"></a>线程属性控制示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">th_fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">int</span> err, detachstate, i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"><span class="keyword">size_t</span> stacksize;</span><br><span class="line"><span class="keyword">void</span> *stackaddr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line"><span class="built_in">pthread_attr_getstack</span>(&amp;attr, &amp;stackaddr, &amp;stacksize);</span><br><span class="line"><span class="built_in">pthread_attr_getdetachstate</span>(&amp;attr, &amp;detachstate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detachstate == PTHREAD_CREATE_DETACHED)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread detached\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (detachstate == PTHREAD_CREATE_JOINABLE)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread join\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread un known\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置线程分离属性 */</span></span><br><span class="line"><span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* 在堆上申请内存,指定线程栈的起始地址和大小 */</span></span><br><span class="line">stackaddr = <span class="built_in">malloc</span>(SIZE);</span><br><span class="line"><span class="keyword">if</span> (stackaddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">stacksize = SIZE;</span><br><span class="line"><span class="built_in">pthread_attr_setstack</span>(&amp;attr, stackaddr, stacksize);</span><br><span class="line"></span><br><span class="line">err = <span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, th_fun, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strerror</span>(err));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NPTL"><a href="#NPTL" class="headerlink" title="NPTL"></a>NPTL</h2><ol><li>查看当前pthread库版本getconf GNU_LIBPTHREAD_VERSION</li><li>NPTL实现机制(POSIX)，Native POSIX Thread Library</li><li>使用线程库时gcc指定 –lpthread</li></ol><h2 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h2><ol><li>主线程退出其他线程不退出，主线程应调用pthread_exit</li><li>避免僵尸线程<ul><li>pthread_join</li><li>pthread_detach</li><li>pthread_create指定分离属性被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;</li></ul></li><li>malloc和mmap申请的内存可以被其他线程释放 </li><li>应避免在多线程模型中调用fork除非，马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit</li><li>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。&lt;/p&gt;
&lt;p&gt;线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。&lt;/p&gt;
&lt;p&gt;同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。&lt;br&gt;一个进程可以有很多线程，每条线程并行执行不同的任务。&lt;/p&gt;
&lt;p&gt;在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)&lt;/li&gt;
&lt;li&gt;进程：独立地址空间，拥有PCB&lt;/li&gt;
&lt;li&gt;线程：也有PCB，但没有独立的地址空间(共享)&lt;/li&gt;
&lt;li&gt;区别：在于是否共享地址空间。&lt;ul&gt;
&lt;li&gt;独居(进程)&lt;/li&gt;
&lt;li&gt;合租(线程)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Linux下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程：最小的执行单位&lt;/li&gt;
&lt;li&gt;进程：最小分配资源单位，可看成是只有一个线程的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a3eed545ly1g8ujxj4xb0j205m02gt8j.jpg&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Linux内核线程实现原理&quot;&gt;&lt;a href=&quot;#Linux内核线程实现原理&quot; class=&quot;headerlink&quot; title=&quot;Linux内核线程实现原理&quot;&gt;&lt;/a&gt;Linux内核线程实现原理&lt;/h2&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="c/c++" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/c-c/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程-进程</title>
    <link href="http://blog.huixing.org/linux_system_program_of_process/"/>
    <id>http://blog.huixing.org/linux_system_program_of_process/</id>
    <published>2019-10-31T12:35:00.000Z</published>
    <updated>2019-11-01T03:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><ul><li><p>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)</p></li><li><p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)</p></li></ul><p>程序 → 剧本(纸)</p><p>进程 → 戏(舞台、演员、灯光、道具…)</p><p>同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响)</p><p>如：同时开两个终端。各自都有一个bash但彼此ID不同。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。</p><p>例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</p><p><img src="http://ww1.sinaimg.cn/large/007SHHrCly1g8hnz7rgjbj307d049mx6.jpg" alt="分时复用cpu"></p><h2 id="单道程序设计"><a href="#单道程序设计" class="headerlink" title="单道程序设计"></a>单道程序设计</h2><p>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p><h2 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h2><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p><p>时钟中断即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</p><p>在多道程序设计模型中，多个进程轮流使用CPU (分时复用CPU资源)。而当下常见CPU为纳秒级，1秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</p><p>1s = 1000ms, 1ms = 1000us, 1us = 1000ns    1000000000 </p><p>实质上，并发是宏观并行，微观串行！            —–推动了计算机蓬勃发展，将人类引入了多媒体时代。</p><h2 id="CPU和MMU"><a href="#CPU和MMU" class="headerlink" title="CPU和MMU"></a>CPU和MMU</h2><p><img src="http://ww1.sinaimg.cn/large/007SHHrCly1g8hnzwnzjtj30ej06e74t.jpg" alt="中央处理器(CPU)"></p><p><img src="http://ww1.sinaimg.cn/large/007SHHrCly1g8ho1zztdej30ej07dmxt.jpg" alt="MMU"></p><h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h2><p>我们知道，每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。<br><code>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h</code>文件中可以查看<code>struct task_struct</code> 结构体定义。其内部成员有很多，我们重点掌握以下部分即可：</p><ul><li>进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</li><li>进程的状态，有就绪、运行、挂起、停止等状态。</li><li>进程切换时需要保存和恢复的一些CPU寄存器。</li><li>描述虚拟地址空间的信息。</li><li>描述控制终端的信息。</li><li>当前工作目录（Current Working Directory）。</li><li>umask掩码。</li><li>文件描述符表，包含很多指向file结构体的指针。</li><li>和信号相关的信息。</li><li>用户id和组id。</li><li>会话（Session）和进程组。</li><li>进程可以使用的资源上限（Resource Limit）。</li></ul><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程基本的状态有5种。分别为初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量，是指在操作系统中用来指定操作系统运行环境的一些参数。通常具备以下特征：</p><ol><li>字符串(本质) </li><li>有统一的格式：名=值[:值] </li><li>值用来描述进程环境信息。</li></ol><ul><li>存储形式：与命令行参数类似。<code>char *[]</code>数组，数组名environ，内部存储字符串，NULL作为哨兵结尾。</li><li>使用形式：与命令行参数类似。</li><li>加载位置：与命令行参数类似。</li><li>位于用户区，高于stack的起始位置。</li><li>引入环境变量表：须声明环境变量。extern char ** environ;    </li></ul><p>打印当前进程的所有环境变量:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h2><p>按照惯例，环境变量字符串都是name=value这样的形式，大多数name由大写字母加下划线组成，一般把name的部分叫做环境变量，value的部分则是环境变量的值。环境变量定义了进程的运行环境，一些比较重要的环境变量的含义如下：</p><h3 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h3><p>可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out，这是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值：<br><code>$ echo $PATH</code></p><h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p>当前Shell，它的值通常是<code>/bin/bash</code>。</p><h3 id="TERM"><a href="#TERM" class="headerlink" title="TERM"></a>TERM</h3><p>当前终端类型，在图形界面终端下它的值通常是xterm。xterm是一个X Window System上的终端模拟器，用来提供多个独立的SHELL输入输出。终端类型决定了一些程序的输出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。</p><h3 id="LANG"><a href="#LANG" class="headerlink" title="LANG"></a>LANG</h3><p>语言和locale，决定了字符编码以及时间、货币等信息的显示格式。</p><h3 id="HOME"><a href="#HOME" class="headerlink" title="HOME"></a>HOME</h3><p>当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运行该程序时都有自己的一套配置。</p><h2 id="环境变量函数"><a href="#环境变量函数" class="headerlink" title="环境变量函数"></a>环境变量函数</h2><h3 id="getenv函数"><a href="#getenv函数" class="headerlink" title="getenv函数"></a>getenv函数</h3><p><strong>获取环境变量值</strong></p><p><code>char *getenv(const char *name);</code></p><ul><li>成功：返回环境变量的值；</li><li>失败：NULL (name不存在)</li></ul><h3 id="setenv函数"><a href="#setenv函数" class="headerlink" title="setenv函数"></a>setenv函数</h3><p><strong>设置环境变量的值</strong></p><p><code>int setenv(const char *name, const char *value, int overwrite);</code></p><ul><li>成功：0;</li><li>失败：-1;</li></ul><p><strong>参数overwrite取值：</strong></p><ul><li>1：覆盖原环境变量 </li><li>0：不覆盖。(该参数常用于设置新环境变量，如：ABC = haha-day-night)</li></ul><h3 id="unsetenv函数"><a href="#unsetenv函数" class="headerlink" title="unsetenv函数"></a>unsetenv函数</h3><p><strong>删除环境变量name的定义</strong></p><p><code>int unsetenv(const char *name);</code></p><ul><li>成功：0;</li><li>失败：-1;</li></ul><p><strong>注意事项：name不存在仍返回0(成功)，当name命名为”ABC=”时则会出错。</strong></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><p><strong>创建一个子进程。</strong><br><code>pid_t fork(void);</code></p><ul><li>失败：-1;</li><li>成功：<ul><li>①父进程返回子进程的ID(非负)    </li><li>②子进程返回 0 </li></ul></li></ul><p>pid_t类型表示进程ID，但为了表示-1，它是有符号整型。(0不是有效进程ID，init最小，为1)</p><p>注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子需【各自】返回一个。</p><h3 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a>getpid函数</h3><p><strong>获取当前进程ID</strong></p><p><code>pid_t getpid(void);</code></p><h3 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a>getppid函数</h3><p><strong>获取当前进程的父进程ID</strong></p><p><code>pid_t getppid(void);</code></p><p><strong>区分一个函数是“系统函数”还是“库函数”依据</strong></p><ol><li>是否访问内核数据结构</li><li>是否访问外部硬件资源</li></ol><p>二者有任一 → 系统函数;</p><p>二者均无 → 库函数;</p><h3 id="getuid函数"><a href="#getuid函数" class="headerlink" title="getuid函数"></a>getuid函数</h3><p><strong>获取当前进程实际用户ID</strong><br><code>uid_t getuid(void);</code></p><p><strong>获取当前进程有效用户ID</strong><br><code>uid_t geteuid(void);</code></p><h3 id="getgid函数"><a href="#getgid函数" class="headerlink" title="getgid函数"></a>getgid函数</h3><p><strong>获取当前进程使用用户组ID</strong></p><p><code>gid_t getgid(void);</code></p><p><strong>获取当前进程有效用户组ID</strong></p><p><code>gid_t getegid(void);</code></p><h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</p><p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</p><p>其实有六种以exec开头的函数，统称exec函数：</p><ul><li><code>int execl(const char *path, const char *arg, ...);</code></li><li><code>int execlp(const char *file, const char *arg, ...);</code></li><li><code>int execle(const char *path, const char *arg, ..., char *const envp[]);</code></li><li><code>int execv(const char *path, char *const argv[]);</code></li><li><code>int execvp(const char *file, char *const argv[]);</code></li><li><code>int execve(const char *path, char *const argv[], char *const envp[]);</code></li></ul><h3 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h3><p>加载一个进程，借助PATH环境变量</p><p><code>int execlp(const char *file, const char *arg, ...);</code></p><ul><li>成功：无返回；</li><li>失败：-1</li></ul><h3 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h3><p><strong>加载一个进程， 通过 路径+程序名 来加载。</strong> </p><p><code>int execl(const char *path, const char *arg, ...);</code></p><ul><li>成功：无返回；</li><li>失败：-1</li></ul><p>对比execlp，如加载”ls”命令带有-l，-F参数</p><p><code>execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-F&quot;, NULL);</code></p><p>使用程序名在PATH中搜索。</p><p><code>execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-F&quot;, NULL);</code></p><p>使用参数1给出的绝对路径搜索。</p><h3 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a>execvp函数</h3><p><strong>加载一个进程，使用自定义环境变量env</strong></p><p><code>int execvp(const char *file, const char *argv[]);</code></p><p>变参形式： ①… ② argv[]  (main函数也是变参函数，形式上等同于 <code>int main(int argc, char *argv0, ...))</code></p><p>变参终止条件：① NULL结尾 ② 固参指定<br>execvp与execlp参数形式不同，原理一致。</p><p>练习：将当前系统中的进程信息，打印到文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;ps.out&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open ps.out error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDOUT_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">execlp</span>(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ax&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//close(fd);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a>exec函数族一般规律</h3><p>exec函数一旦调用成功即执行新的程序，不返回。<strong>只有失败才返回，错误值-1。</strong>所以通常我们直接在exec函数调用后直接调用<code>perror()</code>和<code>exit()</code>，无需if判断。</p><ul><li>l (list)            命令行参数列表</li><li>p (path)            搜素file时使用path变量</li><li>v (vector)            使用命令行参数数组</li><li>e (environment)    使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</li></ul><p>事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，所以execve在man手册第2节，其它函数在man手册第3节。这些函数之间的关系如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/007SHHrCly1g8idugsa0mj309n04iglw.jpg" alt="exec函数族"></p><h2 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a>进程共享</h2><p>父子进程之间在fork后。有哪些相同，那些相异之处呢？</p><p><strong>fork之后：</strong></p><p>父子相同处: </p><ul><li>全局变量、</li><li>.data、</li><li>.text、</li><li>栈、</li><li>堆、</li><li>环境变量、</li><li>用户ID、</li><li>宿主目录、</li><li>进程工作目录、</li><li>信号处理方式…</li></ul><p>父子不同处: </p><ol><li>进程ID   </li><li>fork返回值   </li><li>父进程ID    </li><li>进程运行时间    </li><li>闹钟(定时器)   </li><li>未决信号集</li></ol><p>似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？</p><p>当然不是!<br>父子进程间遵循读时共享写时复制的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个全局变量</span></span><br><span class="line"><span class="keyword">int</span> global_variable = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span>  pid;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">0</span>);</span><br><span class="line">        global_variable+=<span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第1个子进程 全局变量=%d\n&quot;</span>,global_variable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        global_variable+=<span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第2个子进程 全局变量=%d\n&quot;</span>,global_variable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        global_variable+=<span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第3个子进程 全局变量=%d\n&quot;</span>,global_variable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是第1个子进程 全局变量=200</span><br><span class="line">我是第2个子进程 全局变量=200</span><br><span class="line">我是第3个子进程 全局变量=200</span><br></pre></td></tr></table></figure><p>由此可见,进程中全局变量不共享,因为fork之后 .text也是copy同样的,导致每个进程global_variable相互没有关系.</p><h2 id="练习-循环创建n个子进程"><a href="#练习-循环创建n个子进程" class="headerlink" title="练习:循环创建n个子进程"></a>练习:循环创建n个子进程</h2><p>一次fork函数调用可以创建一个子进程。那么创建N个子进程应该怎样实现呢？<br>简单想，<code>for(i = 0; i &lt; n; i++) &#123; fork() &#125;</code> 即可。但这样创建的是N个子进程吗？<br><img src="http://ww1.sinaimg.cn/large/007SHHrCly1g8icts1rsgj30b906kaay.jpg" alt="循环创建N个子进程"></p><p>从上图我们可以很清晰的看到，当n为3时候，循环创建了<code>(2^n)-1</code>个子进程，而不是N的子进程。需要在循环的过程，保证子进程不再执行fork ，因此当<code>(fork() == 0)</code>时，子进程应该立即<code>break;</code>才正确。</p><p>练习：通过命令行参数指定创建进程的个数，每个进程休眠1S打印自己是第几个被创建的进程。如：第1个子进程休眠0秒打印：“我是第1个子进程”；第2个进程休眠1秒打印：“我是第2个子进程”；第3个进程休眠2秒打印：“我是第3个子进程”。</p><p>通过该练习掌握框架：循环创建n个子进程，使用循环因子i对创建的子进程加以区分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span>  pid;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第1个子进程\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第2个子进程\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第3个子进程\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回收进程"><a href="#回收进程" class="headerlink" title="回收进程"></a>回收进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am child, my parent pid = %d\n&quot;</span>, <span class="built_in">getppid</span>());</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent, my pid is = %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">9</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------parent going to die------------\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---child, my parent= %d, going to sleep 10s\n&quot;</span>, <span class="built_in">getppid</span>());</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------child die--------------\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am parent, pid = %d, myson = %d\n&quot;</span>, <span class="built_in">getpid</span>(), pid);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>特别注意，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。思考！用什么办法可清除掉僵尸进程呢？</p><h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p><p>父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</p><ol><li>阻塞等待子进程退出</li><li>回收子进程残留资源</li><li>获取子进程结束状态(退出原因)。</li></ol><p><code>pid_t wait(int *status);</code></p><ul><li>成功：清理掉的子进程ID；</li><li>失败：-1 (没有子进程)</li></ul><p>当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p><p>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</p><ol><li>WIFEXITED(status) 为非0    → 进程正常结束<br> WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)</li><li>WIFSIGNALED(status) 为非0 → 进程异常终止<br> WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</li><li>WIFSTOPPED(status) 为非0 → 进程处于暂停状态<br> WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。<br> WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, pid2, wpid;</span><br><span class="line">    <span class="keyword">int</span> flg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    pid2 = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;<span class="comment">//son</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m process child, pid = %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//parent</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            wpid = <span class="built_in">waitpid</span>(pid, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">            <span class="comment">//wpid = wait(NULL);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;---wpid = %d--------%d\n&quot;</span>, wpid, flg++);</span><br><span class="line">            <span class="keyword">if</span>(wpid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO child exited\n&quot;</span>);</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (wpid == <span class="number">0</span>);<span class="comment">//子进程不可回收</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(wpid == pid)&#123;<span class="comment">//回收了指定子进程</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent, I catched child process,&quot;</span></span><br><span class="line">                   <span class="string">&quot;pid = %d\n&quot;</span>, wpid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;This is the child\n&quot;</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">34</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> stat_val;</span><br><span class="line">        <span class="built_in">waitpid</span>(pid, &amp;stat_val, <span class="number">0</span>);     <span class="comment">//阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(stat_val))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child exited with code %d\n&quot;</span>, <span class="built_in">WEXITSTATUS</span>(stat_val));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(stat_val))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child terminated abnormally, signal %d\n&quot;</span>, <span class="built_in">WTERMSIG</span>(stat_val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h3><p>作用同wait，但可指定pid进程清理，可以不阻塞。</p><p><code>pid_t waitpid(pid_t pid, int *status, in options);</code></p><ul><li>成功：返回清理掉的子进程ID；</li><li>失败：-1(无子进程)</li></ul><p>特殊参数和返回情况：</p><ul><li>> 0 回收指定ID的子进程__    </li><li>-1 回收任意子进程（相当于wait）</li><li>0 回收和当前调用waitpid一个组的所有子进程</li><li>&lt; -1 回收指定进程组内的任意子进程</li></ul><p><strong>返回0：参3为WNOHANG，且子进程正在运行。</strong></p><p><strong>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, pid2, wpid;</span><br><span class="line">    <span class="keyword">int</span> flg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    pid2 = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;<span class="comment">//son</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m process child, pid = %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//parent</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            wpid = <span class="built_in">waitpid</span>(pid, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">            <span class="comment">//wpid = wait(NULL);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;---wpid = %d--------%d\n&quot;</span>, wpid, flg++);</span><br><span class="line">            <span class="keyword">if</span>(wpid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO child exited\n&quot;</span>);</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (wpid == <span class="number">0</span>);<span class="comment">//子进程不可回收</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(wpid == pid)&#123;<span class="comment">//回收了指定子进程</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent, I catched child process,&quot;</span></span><br><span class="line">                   <span class="string">&quot;pid = %d\n&quot;</span>, wpid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;程序和进程&quot;&gt;&lt;a href=&quot;#程序和进程&quot; class=&quot;headerlink&quot; title=&quot;程序和进程&quot;&gt;&lt;/a&gt;程序和进程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序 → 剧本(纸)&lt;/p&gt;
&lt;p&gt;进程 → 戏(舞台、演员、灯光、道具…)&lt;/p&gt;
&lt;p&gt;同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响)&lt;/p&gt;
&lt;p&gt;如：同时开两个终端。各自都有一个bash但彼此ID不同。&lt;/p&gt;
&lt;h2 id=&quot;并发&quot;&gt;&lt;a href=&quot;#并发&quot; class=&quot;headerlink&quot; title=&quot;并发&quot;&gt;&lt;/a&gt;并发&lt;/h2&gt;&lt;p&gt;并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。&lt;/p&gt;
&lt;p&gt;例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/007SHHrCly1g8hnz7rgjbj307d049mx6.jpg&quot; alt=&quot;分时复用cpu&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="c/c++" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/c-c/"/>
    
    
  </entry>
  
  <entry>
    <title>STL Map和multimap容器详解</title>
    <link href="http://blog.huixing.org/stl-map-and-multimap-container-details/"/>
    <id>http://blog.huixing.org/stl-map-and-multimap-container-details/</id>
    <published>2019-10-29T15:21:00.000Z</published>
    <updated>2019-10-29T15:52:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="map-multimap的简介"><a href="#map-multimap的简介" class="headerlink" title="map/multimap的简介"></a>map/multimap的简介</h2><ul><li>map是标准的关联式容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。</li><li>map中key值是唯一的。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。</li><li>map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入操作和删除操作上比vector快。</li><li>map可以直接存取key所对应的value，支持[]操作符，如map[key]=value。</li><li>multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。</li></ul><p>头文件 <code>#include &lt;map&gt;</code></p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8fhpzk9iqj30dw050abl.jpg" alt="map and multimaps"></p><p>map/multimap采用模板类实现，对象的默认构造形式：</p><ul><li><code>map&lt;T1,T2&gt; mapTT;</code></li><li><code>multimap&lt;T1,T2&gt;  multimapTT;</code></li></ul><p>如：</p><ul><li><code>map&lt;int, char&gt; mapA;</code></li><li><code>map&lt;string,float&gt; mapB;</code></li></ul><p>其中T1,T2还可以用各种指针类型或自定义类型</p><h2 id="map的插入与迭代器"><a href="#map的插入与迭代器" class="headerlink" title="map的插入与迭代器"></a>map的插入与迭代器</h2><ul><li><code>map.insert(...);    //往容器插入元素，返回pair&lt;iterator,bool&gt;</code></li></ul><p>在map中插入元素的三种方式：</p><p><code>map&lt;int, string&gt; mapStu;</code></p><ul><li><p>一、通过pair的方式插入对象<br><code>mapStu.insert(  pair&lt;int,string&gt;(3,&quot;小张&quot;)  );</code></p></li><li><p>二、通过pair的方式插入对象<br><code>mapStu.inset(make_pair(-1, “校长-1”));</code></p></li><li><p>三、通过value_type的方式插入对象<br><code>mapStu.insert(  map&lt;int,string&gt;::value_type(1,&quot;小李&quot;)  );</code></p></li><li><p>四、通过数组的方式插入值<br><code>mapStu[3] = “小刘&quot;;mapStu[5] = “小王&quot;；</code></p></li></ul><p>前三种方法，采用的是insert()方法，该方法返回值为pair&lt;iterator,bool&gt;<br>第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值修改成“小刘”。若发现已存在3这个键，则修改这个键对应的value。</p><p><code>string strName = mapStu[2];   //取操作或插入操作</code></p><p>只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值。</p><p>假设<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapA;</span><br><span class="line"><span class="comment">//插入方式一</span></span><br><span class="line">pair&lt; map&lt;<span class="keyword">int</span>,string&gt;::iterator, <span class="keyword">bool</span> &gt; pairResult = mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//iFirst == 3;</span></span><br><span class="line"><span class="keyword">int</span> iFirstFirst = (pairResult.first)-&gt;first;</span><br><span class="line"><span class="comment">//strFirstSecond为&quot;小张&quot;</span></span><br><span class="line">string strFirstSecond = (pairResult.first)-&gt;second;</span><br><span class="line"><span class="comment">//bSecond == true;</span></span><br><span class="line"><span class="keyword">bool</span> bSecond = pairResult.second;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入方式二</span></span><br><span class="line">mapA.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>,<span class="string">&quot;小李&quot;</span>));</span><br><span class="line"></span><br><span class="line">mapA[<span class="number">3</span>] = <span class="string">&quot;小刘&quot;</span>;<span class="comment">//修改value</span></span><br><span class="line">mapA[<span class="number">5</span>] = <span class="string">&quot;小王&quot;</span>;<span class="comment">//插入方式三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行插入 string() 操作，返回的str1的字符串内容为空。</span></span><br><span class="line">string str1 = mapA[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//取得value，str2为&quot;小刘&quot;</span></span><br><span class="line">string str2 = mapA[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">int</span>,string&gt;::iterator it=mapA.<span class="built_in">begin</span>(); it!=mapA.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, string&gt; pr = *it;</span><br><span class="line"><span class="keyword">int</span> iKey = pr.first;</span><br><span class="line">string strValue = pr.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>map.rbegin()</code>与<code>map.rend()</code> 略。</p><ul><li><code>map&lt;T1,T2,less&lt;T1&gt; &gt;  mapA;  //该容器是按键的升序方式排列元素。未指定函数对象，默认采用less&lt;T1&gt;函数对象。</code></li><li><code>map&lt;T1,T2,greater&lt;T1&gt;&gt; mapB;   //该容器是按键的降序方式排列元素。</code></li></ul><p><code>less&lt;T1&gt;</code>与<code>greater&lt;T1&gt;</code>  可以替换成其它的函数对象<code>functor</code>。</p><p>可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。</p><ul><li><code>map.begin();  //返回容器中第一个数据的迭代器。</code></li><li><code>map.end();  //返回容器中最后一个数据之后的迭代器。</code></li><li><code>map.rbegin();  //返回容器中倒数第一个元素的迭代器。</code></li><li><code>map.rend();   //返回容器中倒数最后一个元素的后面的迭代器。</code></li></ul><h2 id="map对象的拷贝构造与赋值"><a href="#map对象的拷贝构造与赋值" class="headerlink" title="map对象的拷贝构造与赋值"></a>map对象的拷贝构造与赋值</h2><ul><li><code>map(const map &amp;mp);             //拷贝构造函数</code></li><li><code>map&amp; operator=(const map &amp;mp);    //重载等号操作符</code></li><li><code>map.swap(mp);                //交换两个集合容器</code></li></ul><p>例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function">map&lt;<span class="keyword">int</span> ,string&gt; <span class="title">mapB</span><span class="params">(mapA)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapC;</span><br><span class="line">mapC = mapA;<span class="comment">//赋值</span></span><br><span class="line"></span><br><span class="line">mapC[<span class="number">3</span>] = <span class="string">&quot;老张&quot;</span>;</span><br><span class="line">mapC.<span class="built_in">swap</span>(mapA);<span class="comment">//交换</span></span><br></pre></td></tr></table></figure><h2 id="map的大小"><a href="#map的大小" class="headerlink" title="map的大小"></a>map的大小</h2><ul><li><code>map.size();    //返回容器中元素的数目</code></li><li><code>map.empty();//判断容器是否为空</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mapA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> iSize = mapA.<span class="built_in">size</span>();<span class="comment">//iSize == 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map的删除"><a href="#map的删除" class="headerlink" title="map的删除"></a>map的删除</h2><ul><li><code>map.clear();        //删除所有元素</code></li><li><code>map.erase(pos);    //删除pos迭代器所指的元素，返回下一个元素的迭代器。</code></li><li><code>map.erase(beg,end);        //删除区间[beg,end)的所有元素    ，返回下一个元素的迭代器。</code></li><li><code>map.erase(keyElem);     //删除容器中key为keyElem的对组。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除区间内的元素</span></span><br><span class="line">map&lt;<span class="keyword">int</span>,string&gt;::iterator itBegin=mapA.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">++ itBegin;</span><br><span class="line">map&lt;<span class="keyword">int</span>,string&gt;::iterator itEnd=mapA.<span class="built_in">end</span>();</span><br><span class="line"><span class="comment">//此时容器mapA包含按顺序的&#123;1,&quot;小杨&quot;&#125;&#123;3,&quot;小张&quot;&#125;两个元素。</span></span><br><span class="line">mapA.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"></span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中第一个元素</span></span><br><span class="line">mapA.<span class="built_in">erase</span>(mapA.<span class="built_in">begin</span>());<span class="comment">//此时容器mapA包含了按顺序的&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;三个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中key为5的元素</span></span><br><span class="line">mapA.<span class="built_in">erase</span>(<span class="number">5</span>);    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除mapA的所有元素</span></span><br><span class="line">mapA.<span class="built_in">clear</span>();<span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure><h2 id="map的查找"><a href="#map的查找" class="headerlink" title="map的查找"></a>map的查找</h2><ul><li><code>map.find(key);   查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</code></li><li><code>map.count(keyElem);   //返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>,string&gt;::iterator it=mapStu.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span>(it == mapStu.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//找到了</span></span><br><span class="line">    pair&lt;<span class="keyword">int</span>, string&gt; pairStu = *it;</span><br><span class="line">    <span class="comment">//或   int  iID = it-&gt;first;</span></span><br><span class="line">    <span class="keyword">int</span> iID = pairStu.first;</span><br><span class="line">    <span class="comment">//或   string strName = it-&gt;second;</span></span><br><span class="line">    string strName = pairStu.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>map.lower_bound(keyElem);  //返回第一个key&gt;=keyElem元素的迭代器。</code></li><li><code>map.upper_bound(keyElem);       //  返回第一个key&gt;keyElem元素的迭代器。</code></li></ul><p>例如：</p><p>mapStu是用<code>map&lt;int,string&gt;</code>声明的容器，已包含{1,”小李”}{3,”小张”}{5,”小王”}{7,”小赵”}{9,”小陈”}元素。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>,string&gt;::iterator it;</span><br><span class="line">it = mapStu.<span class="built_in">lower_bound</span>(<span class="number">5</span>);  <span class="comment">//it-&gt;first==5    it-&gt;second==&quot;小王&quot;</span></span><br><span class="line">it = mapStu.<span class="built_in">upper_bound</span>(<span class="number">5</span>);   <span class="comment">//it-&gt;first==7   it-&gt;second==&quot;小赵&quot;</span></span><br><span class="line">it = mapStu.<span class="built_in">lower_bound</span>(<span class="number">6</span>);  <span class="comment">//it-&gt;first==7    it-&gt;second==&quot;小赵&quot;</span></span><br><span class="line">it = mapStu.<span class="built_in">upper_bound</span>(<span class="number">6</span>);    <span class="comment">//it-&gt;first==7   it-&gt;second==&quot;小赵&quot;</span></span><br></pre></td></tr></table></figure></p><ul><li><code>map.equal_range(keyElem);        //返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</code></li></ul><p>以上函数返回两个迭代器，而这两个迭代器被封装在pair中。</p><p>例如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>,string&gt; mapStu;</span><br><span class="line">...  <span class="comment">//往mapStu容器插入元素&#123;1,&quot;小李&quot;&#125;&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;&#123;9,&quot;小陈&quot;&#125;</span></span><br><span class="line">pair&lt; map&lt;<span class="keyword">int</span>,string&gt;::iterator , map&lt;<span class="keyword">int</span>,string&gt;::iterator &gt; pairIt = mapStu.<span class="built_in">equal_range</span>(<span class="number">5</span>);</span><br><span class="line">map&lt;<span class="keyword">int</span>, string&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">map&lt;<span class="keyword">int</span>, string&gt;::iterator itEnd = pairIt.second;</span><br><span class="line"><span class="comment">//此时 itBeg-&gt;first==5  ,  itEnd-&gt;first == 7,</span></span><br><span class="line">itBeg-&gt;second==<span class="string">&quot;小王&quot;</span>, itEnd-&gt;second==<span class="string">&quot;小赵&quot;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;map-multimap的简介&quot;&gt;&lt;a href=&quot;#map-multimap的简介&quot; class=&quot;headerlink&quot; title=&quot;map/multimap的简介&quot;&gt;&lt;/a&gt;map/multimap的简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;map是标准的关联式容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。&lt;/li&gt;
&lt;li&gt;map中key值是唯一的。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。&lt;/li&gt;
&lt;li&gt;map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入操作和删除操作上比vector快。&lt;/li&gt;
&lt;li&gt;map可以直接存取key所对应的value，支持[]操作符，如map[key]=value。&lt;/li&gt;
&lt;li&gt;multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;头文件 &lt;code&gt;#include &amp;lt;map&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tva1.sinaimg.cn/large/007X8olVly1g8fhpzk9iqj30dw050abl.jpg&quot; alt=&quot;map and multimaps&quot;&gt;&lt;/p&gt;
&lt;p&gt;map/multimap采用模板类实现，对象的默认构造形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map&amp;lt;T1,T2&amp;gt; mapTT;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multimap&amp;lt;T1,T2&amp;gt;  multimapTT;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map&amp;lt;int, char&amp;gt; mapA;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map&amp;lt;string,float&amp;gt; mapB;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中T1,T2还可以用各种指针类型或自定义类型&lt;/p&gt;
&lt;h2 id=&quot;map的插入与迭代器&quot;&gt;&lt;a href=&quot;#map的插入与迭代器&quot; class=&quot;headerlink&quot; title=&quot;map的插入与迭代器&quot;&gt;&lt;/a&gt;map的插入与迭代器&lt;/h2&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="c/c++" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/c-c/"/>
    
    
  </entry>
  
  <entry>
    <title>STL Set和multiset容器详解</title>
    <link href="http://blog.huixing.org/stl-set-and-multiset-container-details/"/>
    <id>http://blog.huixing.org/stl-set-and-multiset-container-details/</id>
    <published>2019-10-24T10:33:00.000Z</published>
    <updated>2019-10-29T15:52:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="set-multiset的简介"><a href="#set-multiset的简介" class="headerlink" title="set/multiset的简介"></a>set/multiset的简介</h2><ul><li>set是一个集合容器，其中所包含的元素是唯一的，集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。<br>set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。</li><li>set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</li><li>multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。</li><li>不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。</li></ul><p>头文件 <code>#include &lt;set&gt;</code> </p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8fhq4ih5wj31hw0u04j5.jpg" alt="图解"></p><h2 id="set-multiset对象的默认构造"><a href="#set-multiset对象的默认构造" class="headerlink" title="set/multiset对象的默认构造"></a>set/multiset对象的默认构造</h2><ul><li><code>set&lt;int&gt; setInt;            //一个存放int的set容器。</code></li><li><code>set&lt;float&gt; setFloat;     //一个存放float的set容器。</code></li><li><code>set&lt;string&gt; setString;     //一个存放string的set容器。</code></li><li><code>multiset&lt;int&gt; mulsetInt;            //一个存放int的multi set容器。</code></li><li><code>multi set&lt;float&gt; multisetFloat;     //一个存放float的multi set容器。</code></li><li><code>multi set&lt;string&gt; multisetString;     //一个存放string的multi set容器。</code></li></ul><h2 id="set的插入与迭代器"><a href="#set的插入与迭代器" class="headerlink" title="set的插入与迭代器"></a>set的插入与迭代器</h2><ul><li><code>set.insert(elem);     //在容器中插入元素。</code></li><li><code>set.begin();  //返回容器中第一个数据的迭代器。</code></li><li><code>set.end();  //返回容器中最后一个数据之后的迭代器。</code></li><li><code>set.rbegin();  //返回容器中倒数第一个元素的迭代器。</code></li><li><code>set.rend();   //返回容器中倒数最后一个元素的后面的迭代器。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>); setInt.<span class="built_in">insert</span>(<span class="number">1</span>);setInt.<span class="built_in">insert</span>(<span class="number">5</span>);setInt.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="keyword">int</span>&gt;::iterator it=setInt.<span class="built_in">begin</span>(); it!=setInt.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">int</span> iItem = *it;</span><br><span class="line">      cout &lt;&lt; iItem;    <span class="comment">//或直接使用cout &lt;&lt; *it</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样子便顺序输出  1 2 3 5。</span></span><br></pre></td></tr></table></figure><p><code>set.rbegin()</code>与<code>set.rend()</code>略。</p><h2 id="Set集合的元素排序"><a href="#Set集合的元素排序" class="headerlink" title="Set集合的元素排序"></a>Set集合的元素排序</h2><ul><li><code>set&lt;int,less&lt;int&gt; &gt;  setIntA;  //该容器是按升序方式排列元素。</code></li><li><code>set&lt;int,greater&lt;int&gt;&gt; setIntB;   //该容器是按降序方式排列元素。</code></li><li><code>set&lt;int&gt; 相当于 set&lt;int,less&lt;int&gt;&gt;。</code></li><li><code>less&lt;int&gt;</code>与<code>greater&lt;int&gt;</code>中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。</li></ul><ul><li>疑问1：<code>less&lt;&gt;</code>与<code>greater&lt;&gt;</code>是什么？</li><li>疑问2：如果<code>set&lt;&gt;</code>不包含int类型，而是包含自定义类型，set容器如何排序？<br>要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫<code>functor</code>。<br>下面将讲解什么是<code>functor</code>，<code>functor</code>的用法。</li></ul><p>使用stl提供的函数对象<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; setIntB;   </span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><br>此时容器setIntB就包含了按顺序的5,3,2,1元素</p><ul><li><code>functor</code>，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。<ul><li><code>greater&lt;&gt;</code>与<code>less&lt;&gt;</code>就是函数对象。</li></ul></li></ul><p>下面举出<code>greater&lt;int&gt;</code>的简易实现原理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">greater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; iLeft, <span class="keyword">const</span> <span class="keyword">int</span>&amp; iRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (iLeft&gt;iRight);    <span class="comment">//如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器就是调用函数对象的operator()方法去比较两个值的大小。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题:"></a>例题:</h2><p>题目：学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。</p><p>解：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CStudent</span>(<span class="keyword">int</span> iID, string strName)</span><br><span class="line">&#123;</span><br><span class="line">m_iID = iID;</span><br><span class="line">m_strName = strName;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="keyword">int</span> m_iID;<span class="comment">//学号</span></span><br><span class="line">     string m_strName; <span class="comment">//姓名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为保持主题鲜明，本类不写拷贝构造函数，不类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StuFunctor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span>  <span class="params">(<span class="keyword">const</span> CStudent &amp;stu1, <span class="keyword">const</span> CStudent &amp;stu2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (stu1.m_iID&lt;stu2.m_iID);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;CStudent, StuFunctor&gt; setStu;</span><br><span class="line">setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">1</span>,<span class="string">&quot;小李&quot;</span>));</span><br><span class="line">setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line">setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">2</span>,<span class="string">&quot;小刘&quot;</span>));</span><br><span class="line"><span class="comment">//此时容器setStu包含了四个学生对象，分别是按姓名顺序的“小李”，“小刘”，“小张”，“小王” </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="set对象的拷贝构造与赋值"><a href="#set对象的拷贝构造与赋值" class="headerlink" title="set对象的拷贝构造与赋值"></a>set对象的拷贝构造与赋值</h2><p>set(const set &amp;st);             //拷贝构造函数<br>set&amp; operator=(const set &amp;st);    //重载等号操作符<br>set.swap(st);                //交换两个集合容器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setIntA;</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">setIntB</span><span class="params">(setIntA)</span></span>;  <span class="comment">//1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; setIntC;</span><br><span class="line">setIntC = setIntA;<span class="comment">//1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">setIntC.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">setIntC.<span class="built_in">swap</span>(setIntA);  <span class="comment">//交换</span></span><br></pre></td></tr></table></figure><h2 id="set的大小"><a href="#set的大小" class="headerlink" title="set的大小"></a>set的大小</h2><ul><li><code>set.size();    //返回容器中元素的数目</code></li><li><code>set.empty();//判断容器是否为空</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setIntA;</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!setIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> iSize = setIntA.<span class="built_in">size</span>();<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set的删除"><a href="#set的删除" class="headerlink" title="set的删除"></a>set的删除</h2><ul><li><code>set.clear();        //清除所有元素</code></li><li><code>set.erase(pos);    //删除pos迭代器所指的元素，返回下一个元素的迭代器。</code></li><li><code>set.erase(beg,end);        //删除区间[beg,end)的所有元素    ，返回下一个元素的迭代器。</code></li><li><code>set.erase(elem);     //删除容器中值为elem的元素。</code></li></ul><h3 id="删除区间内的元素"><a href="#删除区间内的元素" class="headerlink" title="删除区间内的元素"></a>删除区间内的元素</h3><p>setInt是用set<int>声明的容器，现已包含按顺序的1,3,5,6,9,11元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator itBegin=setInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator itEnd=setInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">setInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器setInt包含按顺序的1,6,9,11四个元素。</span></span><br></pre></td></tr></table></figure><h3 id="删除容器中第一个元素"><a href="#删除容器中第一个元素" class="headerlink" title="删除容器中第一个元素"></a>删除容器中第一个元素</h3><ul><li><code>setInt.erase(setInt.begin());        //6,9,11</code></li></ul><h3 id="删除容器中值为9的元素"><a href="#删除容器中值为9的元素" class="headerlink" title="删除容器中值为9的元素"></a>删除容器中值为9的元素</h3><ul><li><code>set.erase(9);</code></li></ul><h3 id="删除setInt的所有元素"><a href="#删除setInt的所有元素" class="headerlink" title="删除setInt的所有元素"></a>删除setInt的所有元素</h3><ul><li><code>setInt.clear();            //容器为空</code></li></ul><h2 id="set的查找"><a href="#set的查找" class="headerlink" title="set的查找"></a>set的查找</h2><ul><li><code>set.find(elem);   //查找elem元素，返回指向elem元素的迭代器。</code></li><li><code>set.count(elem);   //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</code></li><li><code>set.lower_bound(elem);  //返回第一个&gt;=elem元素的迭代器。</code></li><li><code>set.upper_bound(elem);       //  返回第一个&gt;elem元素的迭代器。</code></li><li><code>set.equal_range(elem);        //返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</code></li></ul><p><strong>以上函数返回两个迭代器，而这两个迭代器被封装在pair中。</strong></p><h2 id="pair的含义与使用方法"><a href="#pair的含义与使用方法" class="headerlink" title="pair的含义与使用方法"></a>pair的含义与使用方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator itA = setInt.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> iA = *itA;<span class="comment">//iA == 5</span></span><br><span class="line"><span class="keyword">int</span> iCount = setInt.<span class="built_in">count</span>(<span class="number">5</span>);<span class="comment">//iCount == 1</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator itB = setInt.<span class="built_in">lower_bound</span>(<span class="number">5</span>);</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator itC = setInt.<span class="built_in">upper_bound</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> iB = *itB;<span class="comment">//iB == 5</span></span><br><span class="line"><span class="keyword">int</span> iC = *itC; <span class="comment">//iC == 7</span></span><br><span class="line"></span><br><span class="line">pair&lt; set&lt;<span class="keyword">int</span>&gt;::iterator, set&lt;<span class="keyword">int</span>&gt;::iterator &gt; pairIt = setInt.<span class="built_in">equal_range</span>(<span class="number">5</span>);  <span class="comment">//pair是什么？</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pair的使用"><a href="#pair的使用" class="headerlink" title="pair的使用"></a>pair的使用</h3><ul><li>pair译为对组，可以将两个值视为一个单元。</li><li><code>pair&lt;T1,T2&gt;</code>存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。</li><li>pair.first是pair里面的第一个值，是T1类型。</li><li>pair.second是pair里面的第二个值，是T2类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setInt;</span><br><span class="line">...  <span class="comment">//往setInt容器插入元素1,3,5,7,9</span></span><br><span class="line">pair&lt; set&lt;<span class="keyword">int</span>&gt;::iterator , set&lt;<span class="keyword">int</span>&gt;::iterator &gt; pairIt = setInt.<span class="built_in">equal_range</span>(<span class="number">5</span>);</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator itEnd = pairIt.second;</span><br><span class="line"><span class="comment">//此时 *itBeg==5  而  *itEnd == 7</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>一、容器set/multiset的使用方法；红黑树的变体，查找效率高，插入不能指定位置，插入时自动排序。</li><li>二、functor的使用方法；类似于函数的功能，可用来自定义一些规则，如元素比较规则。</li><li>三、pair的使用方法。对组，一个整体的单元，存放两个类型(T1,T2，T1可与T2一样)的两个元素。</li></ul><p>案例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,&amp;x);</span><br><span class="line"><span class="comment">//建立一个multiset类型，变量名是h，h序列里面存的是int类型,初始h为空</span></span><br><span class="line">multiset&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//将x插入h中</span></span><br><span class="line">    h.<span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,&amp;x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt; multiset&lt;<span class="keyword">int</span>&gt;::iterator , multiset&lt;<span class="keyword">int</span>&gt;::iterator &gt; pairIt = h.<span class="built_in">equal_range</span>(<span class="number">22</span>);</span><br><span class="line">multiset&lt;<span class="keyword">int</span>&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">multiset&lt;<span class="keyword">int</span>&gt;::iterator itEnd = pairIt.second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nBeg = *itBeg;</span><br><span class="line"><span class="keyword">int</span> nEnd = *itEnd;</span><br><span class="line"><span class="comment">// 序列非空h.empty()==true时表示h已经空了</span></span><br><span class="line"><span class="keyword">while</span>(!h.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="comment">//c指向h序列中第一个元素的地址，第一个元素是最小的元素</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt;::iterator c = h.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//将地址c存的数据输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld &quot;</span>,*c);</span><br><span class="line">    <span class="comment">//从h序列中将c指向的元素删除</span></span><br><span class="line">    h.<span class="built_in">erase</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;set-multiset的简介&quot;&gt;&lt;a href=&quot;#set-multiset的简介&quot; class=&quot;headerlink&quot; title=&quot;set/multiset的简介&quot;&gt;&lt;/a&gt;set/multiset的简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;set是一个集合容器，其中所包含的元素是唯一的，集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。&lt;br&gt;set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。&lt;/li&gt;
&lt;li&gt;set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。&lt;/li&gt;
&lt;li&gt;multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。&lt;/li&gt;
&lt;li&gt;不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;头文件 &lt;code&gt;#include &amp;lt;set&amp;gt;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tva1.sinaimg.cn/large/007X8olVly1g8fhq4ih5wj31hw0u04j5.jpg&quot; alt=&quot;图解&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;set-multiset对象的默认构造&quot;&gt;&lt;a href=&quot;#set-multiset对象的默认构造&quot; class=&quot;headerlink&quot; title=&quot;set/multiset对象的默认构造&quot;&gt;&lt;/a&gt;set/multiset对象的默认构造&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set&amp;lt;int&amp;gt; setInt;            //一个存放int的set容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&amp;lt;float&amp;gt; setFloat;     //一个存放float的set容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&amp;lt;string&amp;gt; setString;     //一个存放string的set容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multiset&amp;lt;int&amp;gt; mulsetInt;            //一个存放int的multi set容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multi set&amp;lt;float&amp;gt; multisetFloat;     //一个存放float的multi set容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multi set&amp;lt;string&amp;gt; multisetString;     //一个存放string的multi set容器。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;set的插入与迭代器&quot;&gt;&lt;a href=&quot;#set的插入与迭代器&quot; class=&quot;headerlink&quot; title=&quot;set的插入与迭代器&quot;&gt;&lt;/a&gt;set的插入与迭代器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set.insert(elem);     //在容器中插入元素。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set.begin();  //返回容器中第一个数据的迭代器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set.end();  //返回容器中最后一个数据之后的迭代器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set.rbegin();  //返回容器中倒数第一个元素的迭代器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set.rend();   //返回容器中倒数最后一个元素的后面的迭代器。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;set&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; setInt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setInt.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;); setInt.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);setInt.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);setInt.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(set&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::iterator it=setInt.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(); it!=setInt.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;(); ++it)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; iItem = *it;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      cout &amp;lt;&amp;lt; iItem;    &lt;span class=&quot;comment&quot;&gt;//或直接使用cout &amp;lt;&amp;lt; *it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//这样子便顺序输出  1 2 3 5。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;set.rbegin()&lt;/code&gt;与&lt;code&gt;set.rend()&lt;/code&gt;略。&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="c/c++" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/c-c/"/>
    
    
  </entry>
  
  <entry>
    <title>STL List 容器详解</title>
    <link href="http://blog.huixing.org/stl-list-container-details/"/>
    <id>http://blog.huixing.org/stl-list-container-details/</id>
    <published>2019-10-16T11:04:00.000Z</published>
    <updated>2019-10-16T11:21:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List简介"><a href="#List简介" class="headerlink" title="List简介"></a>List简介</h2><ul><li>list是一个双向链表容器，可高效地进行插入删除元素。</li><li>list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok) it+5(err)</li></ul><p>头文件 <code>#include &lt;list&gt;</code></p><h2 id="list对象的默认构造"><a href="#list对象的默认构造" class="headerlink" title="list对象的默认构造"></a>list对象的默认构造</h2><p>list采用采用模板类实现,对象的默认构造形式：<code>list&lt;T&gt; lstT;</code><br>如：</p><ul><li><code>list&lt;int&gt; lstInt;            //定义一个存放int的list容器。</code></li><li><code>list&lt;float&gt; lstFloat;     //定义一个存放float的list容器。</code></li><li><code>list&lt;string&gt; lstString;     //定义一个存放string的list容器。</code></li><li><code>list&lt;xxxx&gt; lstXxxx;     //定义一个存放xxxx的list容器。</code></li></ul><p>尖括号内还可以设置指针类型或自定义类型。</p><h2 id="list头尾的添加移除操作"><a href="#list头尾的添加移除操作" class="headerlink" title="list头尾的添加移除操作"></a>list头尾的添加移除操作</h2><ul><li><code>list.push_back(elem);       //在容器尾部加入一个元素</code></li><li><code>list.pop_back();              //删除容器中最后一个元素</code></li><li><code>list.push_front(elem);     //在容器开头插入一个元素</code></li><li><code>list.pop_front();              //从容器开头移除第一个元素</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">lstInt.<span class="built_in">pop_front</span>();</span><br><span class="line">lstInt.<span class="built_in">pop_front</span>();</span><br><span class="line">lstInt.<span class="built_in">push_front</span>(<span class="number">11</span>);</span><br><span class="line">lstInt.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line">lstInt.<span class="built_in">pop_back</span>();</span><br><span class="line">lstInt.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// lstInt    &#123;13,11,5&#125;</span></span><br></pre></td></tr></table></figure><h2 id="list的数据存取"><a href="#list的数据存取" class="headerlink" title="list的数据存取"></a>list的数据存取</h2><ul><li><code>list.front();   //返回第一个元素。</code></li><li><code>list.back();  //返回最后一个元素。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iFront = lstInt.<span class="built_in">front</span>();<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> iBack = lstInt.<span class="built_in">back</span>();<span class="comment">//9</span></span><br><span class="line">lstInt.<span class="built_in">front</span>() = <span class="number">11</span>;<span class="comment">//11</span></span><br><span class="line">lstInt.<span class="built_in">back</span>() = <span class="number">19</span>;<span class="comment">//19</span></span><br></pre></td></tr></table></figure><h2 id="list与迭代器"><a href="#list与迭代器" class="headerlink" title="list与迭代器"></a>list与迭代器</h2><ul><li><code>list.begin();                     //返回容器中第一个元素的迭代器。</code></li><li><code>list.end();                       //返回容器中最后一个元素之后的迭代器。</code></li><li><code>list.rbegin();         //返回容器中倒数第一个元素的迭代器。</code></li><li><code>list.rend();         //返回容器中倒数最后一个元素的后面的迭代器。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::iterator it=lstInt.<span class="built_in">begin</span>(); it!=lstInt.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit=lstInt.<span class="built_in">rbegin</span>(); rit!=lstInt.<span class="built_in">rend</span>(); ++rit)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *rit;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list对象的带参数构造"><a href="#list对象的带参数构造" class="headerlink" title="list对象的带参数构造"></a>list对象的带参数构造</h2><p>list(beg,end);    //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。<br>list(n,elem);   //构造函数将n个elem拷贝给本身。<br>list(const list &amp;lst);  //拷贝构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstIntA;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">lstIntB</span><span class="params">(lstIntA.begin(),lstIntA.end())</span></span>;<span class="comment">//1 3 5 7 9</span></span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">lstIntC</span><span class="params">(<span class="number">5</span>,<span class="number">8</span>)</span></span>;<span class="comment">//8 8 8 8 8 </span></span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">lstIntD</span><span class="params">(lstIntA)</span></span>;<span class="comment">//1 3 5 7 9</span></span><br></pre></td></tr></table></figure><h2 id="list的赋值"><a href="#list的赋值" class="headerlink" title="list的赋值"></a>list的赋值</h2><ul><li><code>list.assign(beg,end);    //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</code></li><li><code>list.assign(n,elem);  //将n个elem拷贝赋值给本身。</code></li><li><code>list&amp; operator=(const list &amp;lst);    //重载等号操作符</code></li><li><code>list.swap(lst);  // 将lst与本身的元素互换。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstIntA,lstIntB,lstIntC,lstIntD;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstIntB.<span class="built_in">assign</span>(lstIntA.<span class="built_in">begin</span>(),lstIntA.<span class="built_in">end</span>());<span class="comment">//1 3 5 7 9</span></span><br><span class="line">lstIntC.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="number">8</span>);<span class="comment">//8 8 8 8 8</span></span><br><span class="line">lstIntD = lstIntA;<span class="comment">//1 3 5 7 9</span></span><br><span class="line">lstIntC.<span class="built_in">swap</span>(lstIntD);<span class="comment">//互换</span></span><br></pre></td></tr></table></figure><h2 id="list的大小"><a href="#list的大小" class="headerlink" title="list的大小"></a>list的大小</h2><ul><li><code>list.size();       //返回容器中元素的个数</code></li><li><code>list.empty();       //判断容器是否为空</code></li><li><code>list.resize(num);   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</code></li><li><code>list.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstIntA;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!lstIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iSize = lstIntA.<span class="built_in">size</span>();<span class="comment">//3</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">5</span>);<span class="comment">//1 3 5 0 0</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">7</span>,<span class="number">1</span>);<span class="comment">//1 3 5 0 0 1 1</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">2</span>);<span class="comment">//1 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list的插入"><a href="#list的插入" class="headerlink" title="list的插入"></a>list的插入</h2><ul><li><code>list.insert(pos,elem);   //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</code></li><li><code>list.insert(pos,n,elem);   //在pos位置插入n个elem数据，无返回值。</code></li><li><code>list.insert(pos,beg,end);   //在pos位置插入[beg,end)区间的数据，无返回值。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstA;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; lstB;</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">insert</span>(lstA.<span class="built_in">begin</span>(), <span class="number">11</span>);<span class="comment">//&#123;11, 1, 3, 5, 7, 9&#125;</span></span><br><span class="line">lstA.<span class="built_in">insert</span>(++lstA.<span class="built_in">begin</span>(),<span class="number">2</span>,<span class="number">33</span>);<span class="comment">//&#123;11,33,33,1,3,5,7,9&#125;</span></span><br><span class="line">lstA.<span class="built_in">insert</span>(lstA.<span class="built_in">begin</span>() , lstB.<span class="built_in">begin</span>() , lstB.<span class="built_in">end</span>() );<span class="comment">//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span></span><br></pre></td></tr></table></figure><h2 id="list的删除"><a href="#list的删除" class="headerlink" title="list的删除"></a>list的删除</h2><ul><li><code>list.clear();        //移除容器的所有数据</code></li><li><code>list.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</code></li><li><code>list.erase(pos);    //删除pos位置的数据，返回下一个数据的位置.</code></li><li><code>list.remove(elem);   //删除容器中所有与elem值匹配的元素。</code></li></ul><p>删除区间内的元素<br>lstInt是用list<int>声明的容器，现已包含按顺序的1,3,5,6,9元素。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt;::iterator itBegin=lstInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt;::iterator itEnd=lstInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">lstInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器lstInt包含按顺序的1,6,9三个元素。</span></span><br></pre></td></tr></table></figure></p><p>假设 lstInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素的方法一</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(list&lt;<span class="keyword">int</span>&gt;::iterator it=lstInt.<span class="built_in">being</span>(); it!=lstInt.<span class="built_in">end</span>(); )    <span class="comment">//小括号里不需写  ++it</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(*it == <span class="number">3</span>)</span><br><span class="line">   &#123;</span><br><span class="line">  <span class="comment">//以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span></span><br><span class="line">        it  =  lstInt.<span class="built_in">erase</span>(it);       </span><br><span class="line">        <span class="comment">//此时，不执行  ++it；  </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除容器中等于3的元素的方法二</p><p><code>lstInt.remove(3);</code></p><p>删除lstInt的所有元素</p><p><code>lstInt.clear();            //容器为空</code></p><h2 id="list的反序排列"><a href="#list的反序排列" class="headerlink" title="list的反序排列"></a>list的反序排列</h2><ul><li><code>list.reverse();     //反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstA;</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">reverse</span>();<span class="comment">//9 7 5 3 1</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>容器deque的使用方法<br> 适合    在头尾添加移除元素。使用方法与vector类似。</li><li>容器queue,stack的使用方法<br> 适合队列，堆栈的操作方式。</li><li>容器list的使用方法<br> 适合在任意位置快速插入移除元素</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;List简介&quot;&gt;&lt;a href=&quot;#List简介&quot; class=&quot;headerlink&quot; title=&quot;List简介&quot;&gt;&lt;/a&gt;List简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;list是一个双向链表容器，可高效地进行插入删除元素。&lt;/li&gt;
&lt;li&gt;list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok) it+5(err)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;头文件 &lt;code&gt;#include &amp;lt;list&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;list对象的默认构造&quot;&gt;&lt;a href=&quot;#list对象的默认构造&quot; class=&quot;headerlink&quot; title=&quot;list对象的默认构造&quot;&gt;&lt;/a&gt;list对象的默认构造&lt;/h2&gt;&lt;p&gt;list采用采用模板类实现,对象的默认构造形式：&lt;code&gt;list&amp;lt;T&amp;gt; lstT;&lt;/code&gt;&lt;br&gt;如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;list&amp;lt;int&amp;gt; lstInt;            //定义一个存放int的list容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list&amp;lt;float&amp;gt; lstFloat;     //定义一个存放float的list容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list&amp;lt;string&amp;gt; lstString;     //定义一个存放string的list容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list&amp;lt;xxxx&amp;gt; lstXxxx;     //定义一个存放xxxx的list容器。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尖括号内还可以设置指针类型或自定义类型。&lt;/p&gt;
&lt;h2 id=&quot;list头尾的添加移除操作&quot;&gt;&lt;a href=&quot;#list头尾的添加移除操作&quot; class=&quot;headerlink&quot; title=&quot;list头尾的添加移除操作&quot;&gt;&lt;/a&gt;list头尾的添加移除操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;list.push_back(elem);       //在容器尾部加入一个元素&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list.pop_back();              //删除容器中最后一个元素&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list.push_front(elem);     //在容器开头插入一个元素&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list.pop_front();              //从容器开头移除第一个元素&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;list&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; lstInt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lstInt.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lstInt.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lstInt.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lstInt.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lstInt.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lstInt.&lt;span class=&quot;built_in&quot;&gt;pop_front&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lstInt.&lt;span class=&quot;built_in&quot;&gt;pop_front&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lstInt.&lt;span class=&quot;built_in&quot;&gt;push_front&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lstInt.&lt;span class=&quot;built_in&quot;&gt;push_front&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lstInt.&lt;span class=&quot;built_in&quot;&gt;pop_back&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lstInt.&lt;span class=&quot;built_in&quot;&gt;pop_back&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// lstInt    &amp;#123;13,11,5&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="c/c++" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/c-c/"/>
    
    
  </entry>
  
  <entry>
    <title>STL Queue 容器详解</title>
    <link href="http://blog.huixing.org/stl-queue-container-details/"/>
    <id>http://blog.huixing.org/stl-queue-container-details/</id>
    <published>2019-10-16T10:58:00.000Z</published>
    <updated>2019-10-16T11:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Queue简介"><a href="#Queue简介" class="headerlink" title="Queue简介"></a>Queue简介</h2><blockquote><p>queue是队列容器，是一种“先进先出”的容器。</p></blockquote><p>头文件 <code>#include &lt;queue&gt;</code></p><h2 id="queue对象的默认构造"><a href="#queue对象的默认构造" class="headerlink" title="queue对象的默认构造"></a>queue对象的默认构造</h2><p>queue采用模板类实现，queue对象的默认构造形式：<code>queue&lt;T&gt; queT;</code><br>如：</p><ul><li><code>queue&lt;int&gt; queInt;            //一个存放int的queue容器。</code></li><li><code>queue&lt;float&gt; queFloat;     //一个存放float的queue容器。</code></li><li><code>queue&lt;string&gt; queString;     //一个存放string的queue容器。</code></li><li><code>queue&lt;xxxx&gt; queXxxx;     //一个存放xxxx的queue容器。</code></li></ul><p>尖括号内还可以设置指针类型或自定义类型。</p><h2 id="queue的push-与pop-方法"><a href="#queue的push-与pop-方法" class="headerlink" title="queue的push()与pop()方法"></a>queue的push()与pop()方法</h2><ul><li><code>queue.push(elem);   //往队尾添加元素</code></li><li><code>queue.pop();   //从队头移除第一个元素</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queInt;</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">1</span>);queInt.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">5</span>);queInt.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">9</span>);queInt.<span class="built_in">pop</span>();</span><br><span class="line">queInt.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure><p>此时queInt存放的元素是5,7,9</p><h2 id="queue对象的拷贝构造与赋值"><a href="#queue对象的拷贝构造与赋值" class="headerlink" title="queue对象的拷贝构造与赋值"></a>queue对象的拷贝构造与赋值</h2><ul><li><code>queue(const queue &amp;que);             //拷贝构造函数</code></li><li><code>queue&amp; operator=(const queue &amp;que);    //重载等号操作符</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntA;</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">queue&lt;<span class="keyword">int</span>&gt; <span class="title">queIntB</span><span class="params">(queIntA)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntC;</span><br><span class="line">queIntC = queIntA;<span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><h2 id="queue的数据存取"><a href="#queue的数据存取" class="headerlink" title="queue的数据存取"></a>queue的数据存取</h2><ul><li><code>queue.back();   //返回最后一个元素</code></li><li><code>queue.front();   //返回第一个元素</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntA;</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iFront = queIntA.<span class="built_in">front</span>();<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> iBack = queIntA.<span class="built_in">back</span>();<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">queIntA.<span class="built_in">front</span>() = <span class="number">11</span>;<span class="comment">//11</span></span><br><span class="line">queIntA.<span class="built_in">back</span>() = <span class="number">19</span>;<span class="comment">//19</span></span><br></pre></td></tr></table></figure><h2 id="queue的大小"><a href="#queue的大小" class="headerlink" title="queue的大小"></a>queue的大小</h2><ul><li><code>queue.empty();   //判断队列是否为空</code></li><li><code>queue.size();          //返回队列的大小</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntA;</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!queIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iSize = queIntA.<span class="built_in">size</span>();<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Queue简介&quot;&gt;&lt;a href=&quot;#Queue简介&quot; class=&quot;headerlink&quot; title=&quot;Queue简介&quot;&gt;&lt;/a&gt;Queue简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;queue是队列容器，是一种“先进先出”的容器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;头文件 &lt;code&gt;#include &amp;lt;queue&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;queue对象的默认构造&quot;&gt;&lt;a href=&quot;#queue对象的默认构造&quot; class=&quot;headerlink&quot; title=&quot;queue对象的默认构造&quot;&gt;&lt;/a&gt;queue对象的默认构造&lt;/h2&gt;&lt;p&gt;queue采用模板类实现，queue对象的默认构造形式：&lt;code&gt;queue&amp;lt;T&amp;gt; queT;&lt;/code&gt;&lt;br&gt;如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;queue&amp;lt;int&amp;gt; queInt;            //一个存放int的queue容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;queue&amp;lt;float&amp;gt; queFloat;     //一个存放float的queue容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;queue&amp;lt;string&amp;gt; queString;     //一个存放string的queue容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;queue&amp;lt;xxxx&amp;gt; queXxxx;     //一个存放xxxx的queue容器。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尖括号内还可以设置指针类型或自定义类型。&lt;/p&gt;
&lt;h2 id=&quot;queue的push-与pop-方法&quot;&gt;&lt;a href=&quot;#queue的push-与pop-方法&quot; class=&quot;headerlink&quot; title=&quot;queue的push()与pop()方法&quot;&gt;&lt;/a&gt;queue的push()与pop()方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;queue.push(elem);   //往队尾添加元素&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;queue.pop();   //从队头移除第一个元素&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;queue&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; queInt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queInt.&lt;span class=&quot;built_in&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);queInt.&lt;span class=&quot;built_in&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queInt.&lt;span class=&quot;built_in&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);queInt.&lt;span class=&quot;built_in&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queInt.&lt;span class=&quot;built_in&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;);queInt.&lt;span class=&quot;built_in&quot;&gt;pop&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queInt.&lt;span class=&quot;built_in&quot;&gt;pop&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="c/c++" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/c-c/"/>
    
    
  </entry>
  
  <entry>
    <title>STL Stack 容器详解</title>
    <link href="http://blog.huixing.org/stl-stack-container-details/"/>
    <id>http://blog.huixing.org/stl-stack-container-details/</id>
    <published>2019-10-15T16:30:00.000Z</published>
    <updated>2019-10-16T11:23:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stack简介"><a href="#Stack简介" class="headerlink" title="Stack简介"></a>Stack简介</h2><ul><li>stack是堆栈容器，是一种“先进后出”的容器。</li><li>stack是简单地装饰deque容器而成为另外的一种容器。</li></ul><p>头文件 <code>#include &lt;stack&gt;</code></p><h2 id="stack对象的默认构造"><a href="#stack对象的默认构造" class="headerlink" title="stack对象的默认构造"></a>stack对象的默认构造</h2><p>stack采用模板类实现， stack对象的默认构造形式： <code>stack &lt;T&gt; stkT;</code></p><ul><li><code>stack &lt;int&gt; stkInt;            //一个存放int的stack容器。</code></li><li><code>stack &lt;float&gt; stkFloat;     //一个存放float的stack容器。</code></li><li><code>stack &lt;string&gt; stkString;     //一个存放string的stack容器。</code></li><li><code>stack &lt;xxx&gt; xxx;                //尖括号内还可以设置指针类型或自定义类型。</code></li></ul><h2 id="stack的push-与pop-方法"><a href="#stack的push-与pop-方法" class="headerlink" title="stack的push()与pop()方法"></a>stack的push()与pop()方法</h2><ul><li><code>stack.push(elem);   //往栈头添加元素</code></li><li><code>stack.pop();   //从栈头移除第一个元素</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkInt;  </span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">1</span>);stkInt.<span class="built_in">push</span>(<span class="number">3</span>);stkInt.<span class="built_in">pop</span>();   </span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">5</span>);stkInt.<span class="built_in">push</span>(<span class="number">7</span>);  </span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">9</span>);stkInt.<span class="built_in">pop</span>();   </span><br><span class="line">stkInt.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure><p>此时stkInt存放的元素是1,5  </p><h2 id="stack对象的拷贝构造与赋值"><a href="#stack对象的拷贝构造与赋值" class="headerlink" title="stack对象的拷贝构造与赋值"></a>stack对象的拷贝构造与赋值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>(<span class="keyword">const</span> stack &amp;stk);     <span class="comment">//拷贝构造函数</span></span><br><span class="line">stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> stack &amp;stk);<span class="comment">//重载等号操作符</span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">stack&lt;<span class="keyword">int</span>&gt; <span class="title">stkIntB</span><span class="params">(stkIntA)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntC;</span><br><span class="line">stkIntC = stkIntA;<span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><h2 id="stack的数据存取"><a href="#stack的数据存取" class="headerlink" title="stack的数据存取"></a>stack的数据存取</h2><ul><li><code>stack.top();      //返回最后一个压入栈元素</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iTop = stkIntA.<span class="built_in">top</span>();<span class="comment">//9</span></span><br><span class="line">stkIntA.<span class="built_in">top</span>() = <span class="number">19</span>;<span class="comment">//19</span></span><br></pre></td></tr></table></figure><h2 id="stack的大小"><a href="#stack的大小" class="headerlink" title="stack的大小"></a>stack的大小</h2><ul><li><code>stack.empty();   //判断堆栈是否为空</code></li><li><code>stack.size();          //返回堆栈的大小</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!stkIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iSize = stkIntA.<span class="built_in">size</span>();<span class="comment">//5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Stack简介&quot;&gt;&lt;a href=&quot;#Stack简介&quot; class=&quot;headerlink&quot; title=&quot;Stack简介&quot;&gt;&lt;/a&gt;Stack简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;stack是堆栈容器，是一种“先进后出”的容器。&lt;/li&gt;
&lt;li&gt;stack是简单地装饰deque容器而成为另外的一种容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;头文件 &lt;code&gt;#include &amp;lt;stack&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;stack对象的默认构造&quot;&gt;&lt;a href=&quot;#stack对象的默认构造&quot; class=&quot;headerlink&quot; title=&quot;stack对象的默认构造&quot;&gt;&lt;/a&gt;stack对象的默认构造&lt;/h2&gt;&lt;p&gt;stack采用模板类实现， stack对象的默认构造形式： &lt;code&gt;stack &amp;lt;T&amp;gt; stkT;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack &amp;lt;int&amp;gt; stkInt;            //一个存放int的stack容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack &amp;lt;float&amp;gt; stkFloat;     //一个存放float的stack容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack &amp;lt;string&amp;gt; stkString;     //一个存放string的stack容器。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack &amp;lt;xxx&amp;gt; xxx;                //尖括号内还可以设置指针类型或自定义类型。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;stack的push-与pop-方法&quot;&gt;&lt;a href=&quot;#stack的push-与pop-方法&quot; class=&quot;headerlink&quot; title=&quot;stack的push()与pop()方法&quot;&gt;&lt;/a&gt;stack的push()与pop()方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack.push(elem);   //往栈头添加元素&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack.pop();   //从栈头移除第一个元素&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;stack&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; stkInt;  	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stkInt.&lt;span class=&quot;built_in&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);stkInt.&lt;span class=&quot;built_in&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);stkInt.&lt;span class=&quot;built_in&quot;&gt;pop&lt;/span&gt;();   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stkInt.&lt;span class=&quot;built_in&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);stkInt.&lt;span class=&quot;built_in&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stkInt.&lt;span class=&quot;built_in&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;);stkInt.&lt;span class=&quot;built_in&quot;&gt;pop&lt;/span&gt;();   	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stkInt.&lt;span class=&quot;built_in&quot;&gt;pop&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此时stkInt存放的元素是1,5  &lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="c/c++" scheme="http://blog.huixing.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/c-c/"/>
    
    
  </entry>
  
</feed>
