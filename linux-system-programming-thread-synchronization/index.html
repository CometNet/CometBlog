<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referrer" content="no-referrer" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.huixing.org","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="同步概念所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等… 而，编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程-线程同步">
<meta property="og:url" content="http://blog.huixing.org/linux-system-programming-thread-synchronization/index.html">
<meta property="og:site_name" content="Haohao Notes">
<meta property="og:description" content="同步概念所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等… 而，编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/a3eed545ly1gcd55qns9jj205z04aaa1.jpg">
<meta property="article:published_time" content="2020-02-29T04:03:09.000Z">
<meta property="article:modified_time" content="2020-02-29T05:30:41.000Z">
<meta property="article:author" content="Tan Hao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ww1.sinaimg.cn/large/a3eed545ly1gcd55qns9jj205z04aaa1.jpg">

<link rel="canonical" href="http://blog.huixing.org/linux-system-programming-thread-synchronization/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux系统编程-线程同步 | Haohao Notes</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5202a7e94920d0c374589510b87a35e0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Haohao Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">DREAM OF TECHNICAL ACHIEVEMENT</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.huixing.org/linux-system-programming-thread-synchronization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="作者">
      <meta itemprop="description" content="谈浩的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haohao Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux系统编程-线程同步
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-29 12:03:09 / 修改时间：13:30:41" itemprop="dateCreated datePublished" datetime="2020-02-29T12:03:09+08:00">2020-02-29</time>
            </span>

          
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-copyright"></i>
    </span>
    <span class="post-meta-item-text">作者：</span><span>Tan Hao</span>
  </span>
  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/linux-system-programming-thread-synchronization/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="linux-system-programming-thread-synchronization/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a>同步概念</h2><p>所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等…</p>
<p>而，编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次序运行。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>同步即协同步调，按预定的先后次序运行。</p>
<p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p>
<p>举例1：    银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000</p>
<p>举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续    从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。</p>
<p>产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。</p>
<p>“同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p>
<p>因此，所有“<strong>多个控制流，共同操作一个共享资源</strong>”的情况，都需要同步。</p>
<h2 id="数据混乱原因"><a href="#数据混乱原因" class="headerlink" title="数据混乱原因"></a>数据混乱原因</h2><p>据混乱原因：</p>
<ol>
<li>资源共享（独享资源则不会）    </li>
<li>调度随机（意味着数据访问会出现竞争）    </li>
<li>线程间缺乏必要的同步机制。</li>
</ol>
<p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</p>
<p>所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p>
<h2 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h2><p>Linux中提供一把互斥锁mutex（也称之为互斥量）。</p>
<p>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p>
<p>资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p>
<p><img src="https://ww1.sinaimg.cn/large/a3eed545ly1gcd55qns9jj205z04aaa1.jpg" alt="加锁图例"></p>
<p>但，应注意：同一时刻，只能有一个线程持有该锁。</p>
<p>当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</p>
<p>所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。</p>
<p>因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。</p>
<h3 id="主要应用函数"><a href="#主要应用函数" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><p>pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。</p>
<p>pthread_mutex_t mutex; 变量mutex只有两种取值1、0。</p>
<h4 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a>pthread_mutex_init函数</h4><p>初始化一个互斥锁(互斥量) —&gt; 初值可看作1<br><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></p>
<ul>
<li>参1：传出参数，调用时应传 &amp;mutex<br>  restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</li>
<li>参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性</li>
</ul>
<p>静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;<br>动态初始化：局部变量应采用动态初始化。e.g.  pthread_mutex_init(&amp;mutex, NULL)</p>
<h4 id="pthread-mutex-destroy函数"><a href="#pthread-mutex-destroy函数" class="headerlink" title="pthread_mutex_destroy函数"></a>pthread_mutex_destroy函数</h4><p>销毁一个互斥锁<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p>
<h4 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a>pthread_mutex_lock函数</h4><p>加锁。可理解为将mutex–（或-1）<code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></p>
<h4 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a>pthread_mutex_unlock函数</h4><p>解锁。可理解为将mutex ++（或+1）<code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></p>
<h4 id="pthread-mutex-trylock函数"><a href="#pthread-mutex-trylock函数" class="headerlink" title="pthread_mutex_trylock函数"></a>pthread_mutex_trylock函数</h4><p>尝试加锁<code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p>
<p>以上5个函数的返回值都是：成功返回0， 失败返回错误号。</p>
<h2 id="加锁与解锁"><a href="#加锁与解锁" class="headerlink" title="加锁与解锁"></a>加锁与解锁</h2><h3 id="lock与unlock"><a href="#lock与unlock" class="headerlink" title="lock与unlock"></a>lock与unlock</h3><p>lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</p>
<p>unlock主动解锁函数，<strong>同时将阻塞在该锁上的所有线程全部唤醒</strong>，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</p>
<p>例如：T1 T2 T3 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2 T3 T4均被唤醒，并自动再次尝试加锁。</p>
<p>可假想mutex锁 init成功初值为1。    lock 功能是将mutex–。    unlock将mutex++</p>
<h3 id="lock与trylock"><a href="#lock与trylock" class="headerlink" title="lock与trylock"></a>lock与trylock</h3><p>lock加锁失败会阻塞，等待锁释放。</p>
<p>trylock加锁失败直接返回错误号（如：EBUSY），不阻塞。</p>
<h2 id="加锁步骤测试"><a href="#加锁步骤测试" class="headerlink" title="加锁步骤测试"></a>加锁步骤测试</h2><p>看如下程序：该程序是非常典型的，由于共享、竞争而没有加任何同步机制，导致产生于时间有关的错误<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;hello &quot;);</span><br><span class="line">        sleep(rand() % 3);	/*模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误*/</span><br><span class="line">        printf(&quot;world\n&quot;);</span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;HELLO &quot;);</span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">        printf(&quot;WORLD\n&quot;);</span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost code]# ./test</span><br><span class="line">HELLO WORLD</span><br><span class="line">HELLO WORLD</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello HELLO world</span><br><span class="line">hello WORLD</span><br><span class="line">HELLO world</span><br><span class="line">hello WORLD</span><br><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure><br>加锁后的程序:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);   //mutex--</span><br><span class="line">        printf(&quot;hello &quot;);</span><br><span class="line">        sleep(rand() % 3);	/*模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误*/</span><br><span class="line">        printf(&quot;world\n&quot;);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);   //mutex--</span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    int flag = 5;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, NULL);  //mutex = 1</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">    while (flag--) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);   //mutex--</span><br><span class="line">        printf(&quot;HELLO &quot;);</span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">        printf(&quot;WORLD\n&quot;);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex); //mutex++</span><br><span class="line"></span><br><span class="line">        sleep(rand() % 3);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost code]# ./test                      </span><br><span class="line">HELLO WORLD</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">HELLO WORLD</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<p>结论：在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ol>
<li>线程试图对同一个互斥量A加锁两次。</li>
<li>线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁</li>
</ol>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>与互斥量类似，但读写锁允许更高的并行性。其特性为：写独占，读共享。</p>
<h3 id="读写锁状态"><a href="#读写锁状态" class="headerlink" title="读写锁状态"></a>读写锁状态</h3><p>一把读写锁具备三种状态：</p>
<ol>
<li>读模式下加锁状态 (读锁)</li>
<li>写模式下加锁状态 (写锁)</li>
<li>不加锁状态</li>
</ol>
<h3 id="读写锁特性"><a href="#读写锁特性" class="headerlink" title="读写锁特性"></a>读写锁特性</h3><ol>
<li>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</li>
<li>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li>
<li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高</li>
</ol>
<p>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。<strong>写独占、读共享</strong>。</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。</p>
<h3 id="主要应用函数-1"><a href="#主要应用函数-1" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><h4 id="pthread-rwlock-init函数"><a href="#pthread-rwlock-init函数" class="headerlink" title="pthread_rwlock_init函数"></a>pthread_rwlock_init函数</h4><p>初始化一把读写锁<code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code><br>参2：attr表读写锁属性，通常使用默认属性，传NULL即可。</p>
<h4 id="pthread-rwlock-destroy函数"><a href="#pthread-rwlock-destroy函数" class="headerlink" title="pthread_rwlock_destroy函数"></a>pthread_rwlock_destroy函数</h4><p>销毁一把读写锁<code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></p>
<h4 id="pthread-rwlock-rdlock函数"><a href="#pthread-rwlock-rdlock函数" class="headerlink" title="pthread_rwlock_rdlock函数"></a>pthread_rwlock_rdlock函数</h4><p>以读方式请求读写锁。（常简称为：请求读锁）<code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></p>
<h4 id="pthread-rwlock-wrlock函数"><a href="#pthread-rwlock-wrlock函数" class="headerlink" title="pthread_rwlock_wrlock函数"></a>pthread_rwlock_wrlock函数</h4><p>以写方式请求读写锁。（常简称为：请求写锁）<code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></p>
<h4 id="pthread-rwlock-unlock函数"><a href="#pthread-rwlock-unlock函数" class="headerlink" title="pthread_rwlock_unlock函数"></a>pthread_rwlock_unlock函数</h4><p>解锁<code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></p>
<h4 id="pthread-rwlock-tryrdlock函数"><a href="#pthread-rwlock-tryrdlock函数" class="headerlink" title="pthread_rwlock_tryrdlock函数"></a>pthread_rwlock_tryrdlock函数</h4><p>非阻塞以读方式请求读写锁（非阻塞请求读锁）<code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></p>
<h4 id="pthread-rwlock-trywrlock函数"><a href="#pthread-rwlock-trywrlock函数" class="headerlink" title="pthread_rwlock_trywrlock函数"></a>pthread_rwlock_trywrlock函数</h4><p>非阻塞以写方式请求读写锁（非阻塞请求写锁）<code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>同时有多个线程对同一全局数据读、写操作。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int counter;</span><br><span class="line">pthread_rwlock_t rwlock;</span><br><span class="line"></span><br><span class="line">/* 3个线程不定时写同一全局资源，5个线程不定时读同一全局资源 */</span><br><span class="line">void *th_write(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int t, i = (int)arg;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        t = counter;</span><br><span class="line">        usleep(1000);</span><br><span class="line">        printf(&quot;=======write %d: %lu: counter=%d ++counter=%d\n&quot;, i, pthread_self(), t, ++counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(10000);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">void *th_read(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i = (int)arg;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        printf(&quot;----------------------------read %d: %lu: %d\n&quot;, i, pthread_self(), counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(2000);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    pthread_t tid[8];</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, NULL);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 3; i++)</span><br><span class="line">        pthread_create(&amp;tid[i], NULL, th_write, (void *)i);</span><br><span class="line">    for (i = 0; i &lt; 5; i++)</span><br><span class="line">        pthread_create(&amp;tid[i+3], NULL, th_read, (void *)i);</span><br><span class="line">    for (i = 0; i &lt; 8; i++)</span><br><span class="line">        pthread_join(tid[i], NULL);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;					</span><br></pre></td></tr></table></figure></p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</p>
<h3 id="主要应用函数-2"><a href="#主要应用函数-2" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><h4 id="pthread-cond-init函数"><a href="#pthread-cond-init函数" class="headerlink" title="pthread_cond_init函数"></a>pthread_cond_init函数</h4><p>初始化一个条件变量<code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code><br>参2：attr表条件变量属性，通常为默认值，传NULL即可<br>也可以使用静态初始化的方法，初始化条件变量：<br><code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></p>
<h4 id="pthread-cond-destroy函数"><a href="#pthread-cond-destroy函数" class="headerlink" title="pthread_cond_destroy函数"></a>pthread_cond_destroy函数</h4><p>销毁一个条件变量<code>int pthread_cond_destroy(pthread_cond_t *cond);</code></p>
<h4 id="pthread-cond-wait函数"><a href="#pthread-cond-wait函数" class="headerlink" title="pthread_cond_wait函数"></a>pthread_cond_wait函数</h4><p>阻塞等待一个条件变量<code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code><br>函数作用：<br>阻塞等待条件变量cond（参1）满足<br>释放已掌握的互斥锁（解锁互斥量）相当于<code>pthread_mutex_unlock(&amp;mutex);</code><br> 1.2.两步为一个原子操作。<br>当被唤醒，<code>pthread_cond_wait</code>函数返回时，解除阻塞并重新申请获取互斥锁<code>pthread_mutex_lock(&amp;mutex);</code></p>
<h4 id="pthread-cond-timedwait函数"><a href="#pthread-cond-timedwait函数" class="headerlink" title="pthread_cond_timedwait函数"></a>pthread_cond_timedwait函数</h4><p>限时等待一个条件变量<br><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></p>
<p>参3：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct timespec &#123;</span><br><span class="line">	time_t tv_sec;		/* seconds */ 秒</span><br><span class="line">	long   tv_nsec;	/* nanosecondes*/ 纳秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>形参abstime：绝对时间。</p>
<p>如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。    <code>struct timespec t = &#123;1, 0&#125;;sem_timedwait(&amp;sem, &amp;t);</code> 这样只能定时到 1970年1月1日  00:00:01秒(早已经过去)<br>正确用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time_t cur = time(NULL);// 获取当前时间。</span><br><span class="line">struct timespec t;	//定义timespec 结构体变量t</span><br><span class="line">t.tv_sec = cur+1; //定时1秒</span><br><span class="line">pthread_cond_timedwait (&amp;cond, &amp;t); //传参</span><br></pre></td></tr></table></figure><br>参APUE.11.6线程同步条件变量小节</p>
<p>在讲解setitimer函数时我们还提到另外一种时间类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct timeval &#123;</span><br><span class="line">     time_t      tv_sec;  /* seconds */ 秒</span><br><span class="line">     suseconds_t tv_usec; 	/* microseconds */ 微秒</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="pthread-cond-signal函数"><a href="#pthread-cond-signal函数" class="headerlink" title="pthread_cond_signal函数"></a>pthread_cond_signal函数</h4><p>唤醒至少一个阻塞在条件变量上的线程<code>int pthread_cond_signal(pthread_cond_t *cond);</code></p>
<h4 id="pthread-cond-broadcast函数"><a href="#pthread-cond-broadcast函数" class="headerlink" title="pthread_cond_broadcast函数"></a>pthread_cond_broadcast函数</h4><p>唤醒全部阻塞在条件变量上的线程<code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></p>
<h3 id="生产者消费者条件变量模型"><a href="#生产者消费者条件变量模型" class="headerlink" title="生产者消费者条件变量模型"></a>生产者消费者条件变量模型</h3><p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">struct msg &#123;</span><br><span class="line">    struct msg *next;</span><br><span class="line">    int num;</span><br><span class="line">&#125;;</span><br><span class="line">struct msg *head;</span><br><span class="line"></span><br><span class="line">pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">void *consumer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    struct msg *mp;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        while (head == NULL) &#123;           //头指针为空,说明没有节点    可以为if吗</span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        mp = head;      </span><br><span class="line">        head = mp-&gt;next;    			//模拟消费掉一个产品</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">        printf(&quot;-Consume ---%d\n&quot;, mp-&gt;num);</span><br><span class="line">        free(mp);</span><br><span class="line">        sleep(rand() % 5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void *producer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    struct msg *mp;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        mp = malloc(sizeof(struct msg));</span><br><span class="line">        mp-&gt;num = rand() % 1000 + 1;        //模拟生产一个产品</span><br><span class="line">        printf(&quot;-Produce ---%d\n&quot;, mp-&gt;num);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        mp-&gt;next = head;</span><br><span class="line">        head = mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">        pthread_cond_signal(&amp;has_product);  //将等待在该条件变量上的一个线程唤醒</span><br><span class="line">        sleep(rand() % 5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t pid, cid;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">    pthread_create(&amp;cid, NULL, consumer, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_join(pid, NULL);</span><br><span class="line">    pthread_join(cid, NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件变量的优点"><a href="#条件变量的优点" class="headerlink" title="条件变量的优点"></a>条件变量的优点</h3><p>相较于mutex而言，条件变量可以减少竞争。</p>
<p>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>进化版的互斥锁（1 –&gt; N）</p>
<p>由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。</p>
<p>信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p>
<h3 id="主要应用函数-3"><a href="#主要应用函数-3" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><p>信号量基本操作：<br>sem_wait:</p>
<ol>
<li>信号量大于0，则信号量–类比pthread_mutex_lock）</li>
<li>信号量等于0，造成线程阻塞</li>
</ol>
<p>sem_post：将信号量++，同时唤醒阻塞在信号量上的线程（类比pthread_mutex_unlock）<br>但，由于sem_t的实现对用户隐藏，所以所谓的++、–操作只能通过函数来实现，而不能直接++、–符号。</p>
<p>信号量的初值，决定了占用信号量的线程的个数。</p>
<h4 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a>sem_init函数</h4><p>初始化一个信号量<code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></p>
<ul>
<li>参1：sem信号量    </li>
<li>参2：pshared取0用于线程间；取非0用于进程间    </li>
<li>参3：value指定信号量初值</li>
</ul>
<h4 id="sem-destroy函数"><a href="#sem-destroy函数" class="headerlink" title="sem_destroy函数"></a>sem_destroy函数</h4><p>销毁一个信号量<code>int sem_destroy(sem_t *sem);</code></p>
<h4 id="sem-wait函数"><a href="#sem-wait函数" class="headerlink" title="sem_wait函数"></a>sem_wait函数</h4><p>给信号量加锁 –<code>int sem_wait(sem_t *sem);</code></p>
<h4 id="sem-post函数"><a href="#sem-post函数" class="headerlink" title="sem_post函数"></a>sem_post函数</h4><p>给信号量解锁 ++<code>int sem_post(sem_t *sem);</code>    </p>
<h4 id="sem-trywait函数"><a href="#sem-trywait函数" class="headerlink" title="sem_trywait函数"></a>sem_trywait函数</h4><p>尝试对信号量加锁 –    (与sem_wait的区别类比lock和trylock)<code>int sem_trywait(sem_t *sem);</code></p>
<h4 id="sem-timedwait函数"><a href="#sem-timedwait函数" class="headerlink" title="sem_timedwait函数"></a>sem_timedwait函数</h4><p>限时尝试对信号量加锁 – <code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code><br>参2：abs_timeout采用的是绝对时间。<br>定时1秒：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time_t cur = time(NULL); //获取当前时间。</span><br><span class="line">struct timespec t;//定义timespec 结构体变量t</span><br><span class="line">t.tv_sec = cur+1; //定时1秒</span><br><span class="line">sem_timedwait(&amp;sem, &amp;t); //传参</span><br></pre></td></tr></table></figure></p>
<h3 id="生产者消费者信号量模型"><a href="#生产者消费者信号量模型" class="headerlink" title="生产者消费者信号量模型"></a>生产者消费者信号量模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">#define NUM 5               </span><br><span class="line"></span><br><span class="line">int queue[NUM];                                     //全局数组实现环形队列</span><br><span class="line">sem_t blank_number, product_number;                 //空格子信号量, 产品信号量</span><br><span class="line">void *producer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        sem_wait(&amp;blank_number);                    //生产者将空格子数--,为0则阻塞等待</span><br><span class="line">        queue[i] = rand() % 1000 + 1;               //生产一个产品</span><br><span class="line">        printf(&quot;----Produce---%d\n&quot;, queue[i]);        </span><br><span class="line">        sem_post(&amp;product_number);                  //将产品数++</span><br><span class="line"></span><br><span class="line">        i = (i+1) % NUM;                            //借助下标实现环形</span><br><span class="line">        sleep(rand()%1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *consumer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        sem_wait(&amp;product_number);                  //消费者将产品数--,为0则阻塞等待</span><br><span class="line">        printf(&quot;-Consume---%d       %lu\n&quot;, queue[i], pthread_self());</span><br><span class="line">        queue[i] = 0;                               //消费一个产品 </span><br><span class="line">        sem_post(&amp;blank_number);                    //消费掉以后,将空格子数++</span><br><span class="line"></span><br><span class="line">        i = (i+1) % NUM;</span><br><span class="line">        sleep(rand()%1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t pid, cid;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;blank_number, 0, NUM);                //初始化空格子信号量为5</span><br><span class="line">    sem_init(&amp;product_number, 0, 0);                //产品数为0</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;cid, NULL, consumer, NULL);</span><br><span class="line">    pthread_create(&amp;cid, NULL, consumer, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_join(pid, NULL);</span><br><span class="line">    pthread_join(cid, NULL);</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h2><h3 id="互斥量mutex-1"><a href="#互斥量mutex-1" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h3><p>进程间也可以使用互斥锁，来达到同步的目的。但应在pthread_mutex_init初始化之前，修改其属性为进程间共享。mutex的属性修改函数主要有以下几个。</p>
<h3 id="主要应用函数-4"><a href="#主要应用函数-4" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><ul>
<li>pthread_mutexattr_t mattr 类型：        用于定义mutex锁的【属性】</li>
<li>pthread_mutexattr_init函数：            初始化一个mutex属性对象</li>
<li>int pthread_mutexattr_init(pthread_mutexattr_t *attr);</li>
<li>pthread_mutexattr_destroy函数：        销毁mutex属性对象 (而非销毁锁)</li>
<li>int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);</li>
<li>pthread_mutexattr_setpshared函数：    修改mutex属性。</li>
<li>int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);</li>
</ul>
<p>参2：pshared取值：<br>    线程锁：PTHREAD_PROCESS_PRIVATE (mutex的默认属性即为线程锁，进程间私有)<br>    进程锁：PTHREAD_PROCESS_SHARED</p>
<h3 id="进程间mutex示例"><a href="#进程间mutex示例" class="headerlink" title="进程间mutex示例"></a>进程间mutex示例</h3><p>进程间使用mutex来实现同步<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">struct mt &#123;</span><br><span class="line">    int num;</span><br><span class="line">    pthread_mutex_t mutex;</span><br><span class="line">    pthread_mutexattr_t mutexattr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int fd, i;</span><br><span class="line">    struct mt *mm;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;mt_test&quot;, O_CREAT | O_RDWR, 0777);</span><br><span class="line">    ftruncate(fd, sizeof(*mm));</span><br><span class="line">    mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">    close(fd);</span><br><span class="line">    unlink(&quot;mt_test&quot;);</span><br><span class="line">    //mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);</span><br><span class="line">    memset(mm, 0, sizeof(*mm));</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_init(&amp;mm-&gt;mutexattr);                                  //初始化mutex属性对象</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;mm-&gt;mutexattr, PTHREAD_PROCESS_SHARED);    //修改属性为进程间共享</span><br><span class="line">    pthread_mutex_init(&amp;mm-&gt;mutex, &amp;mm-&gt;mutexattr);                          //初始化一把mutex琐</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            (mm-&gt;num)++;</span><br><span class="line">            printf(&quot;-child----num++   %d\n&quot;, mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">        for ( i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            sleep(1);</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            mm-&gt;num += 2;</span><br><span class="line">            printf(&quot;-parent---num+=2  %d\n&quot;, mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_destroy(&amp;mm-&gt;mutexattr);          //销毁mutex属性对象</span><br><span class="line">    pthread_mutex_destroy(&amp;mm-&gt;mutex);                //销毁mutex</span><br><span class="line">    munmap(mm,sizeof(*mm));                          //释放映射区</span><br><span class="line">    return 0;</span><br><span class="line">&#125;								</span><br></pre></td></tr></table></figure></p>
<h3 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h3><p>借助 fcntl函数来实现锁机制。    操作文件的进程没有获得锁时，可以打开，但无法执行read、write操作。</p>
<p>fcntl函数：    获取、设置文件访问控制属性。<code>int fcntl(int fd, int cmd, ... /* arg */ );</code></p>
<p>参2：</p>
<ul>
<li>F_SETLK (struct flock *)    设置文件锁（trylock）</li>
<li>F_SETLKW (struct flock *) 设置文件锁（lock）W –&gt; wait</li>
<li>F_GETLK (struct flock *)    获取文件锁</li>
</ul>
<p>参3：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct flock &#123;</span><br><span class="line">    ...</span><br><span class="line">    short l_type;    	锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK</span><br><span class="line">    short l_whence;  	偏移位置：SEEK_SET、SEEK_CUR、SEEK_END </span><br><span class="line">    off_t l_start;   		起始偏移：</span><br><span class="line">    off_t l_len;     		长度：0表示整个文件加锁</span><br><span class="line">    pid_t l_pid;     	持有该锁的进程ID：(F_GETLK only)</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="进程间文件锁示例"><a href="#进程间文件锁示例" class="headerlink" title="进程间文件锁示例"></a>进程间文件锁示例</h3><p>多个进程对加锁文件进行访问<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str); exit(1);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    struct flock f_lock;</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf(&quot;./a.out filename\n&quot;); exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    if ((fd = open(argv[1], O_RDWR)) &lt; 0)</span><br><span class="line">        sys_err(&quot;open&quot;);</span><br><span class="line"></span><br><span class="line">    //f_lock.l_type = F_WRLCK;        /*选用写琐*/</span><br><span class="line">    f_lock.l_type = F_RDLCK;          /*选用读琐*/ </span><br><span class="line"></span><br><span class="line">    f_lock.l_whence = SEEK_SET;</span><br><span class="line">    f_lock.l_start = 0;</span><br><span class="line">    f_lock.l_len = 0;               /* 0表示整个文件加锁 */</span><br><span class="line"></span><br><span class="line">    fcntl(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line">    printf(&quot;get flock\n&quot;);</span><br><span class="line">    sleep(10);</span><br><span class="line"></span><br><span class="line">    f_lock.l_type = F_UNLCK;</span><br><span class="line">    fcntl(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line">    printf(&quot;un flock\n&quot;);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;						</span><br></pre></td></tr></table></figure><br>依然遵循“读共享、写独占”特性。但！如若进程不加锁直接操作文件，依然可访问成功，但数据势必会出现混乱。</p>
<p>多线程中，可以使用文件锁吗？</p>
<p>多线程间共享文件描述符，而给文件加锁，是通过修改文件描述符所指向的文件结构体中的成员变量来实现的。因此，多线程中无法使用文件锁。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/linux-signal/" rel="prev" title="Linux系统编程-信号">
      <i class="fa fa-chevron-left"></i> Linux系统编程-信号
    </a></div>
      <div class="post-nav-item">
    <a href="/linux-socket/" rel="next" title="Linux系统编程-socket编程">
      Linux系统编程-socket编程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">同步概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">2.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B7%B7%E4%B9%B1%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.</span> <span class="nav-text">数据混乱原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8Fmutex"><span class="nav-number">4.</span> <span class="nav-text">互斥量mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">主要应用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-mutex-init%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.1.</span> <span class="nav-text">pthread_mutex_init函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-mutex-destroy%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.2.</span> <span class="nav-text">pthread_mutex_destroy函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-mutex-lock%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.3.</span> <span class="nav-text">pthread_mutex_lock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-mutex-unlock%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.4.</span> <span class="nav-text">pthread_mutex_unlock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-mutex-trylock%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.5.</span> <span class="nav-text">pthread_mutex_trylock函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E4%B8%8E%E8%A7%A3%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">加锁与解锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lock%E4%B8%8Eunlock"><span class="nav-number">5.1.</span> <span class="nav-text">lock与unlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lock%E4%B8%8Etrylock"><span class="nav-number">5.2.</span> <span class="nav-text">lock与trylock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E6%AD%A5%E9%AA%A4%E6%B5%8B%E8%AF%95"><span class="nav-number">6.</span> <span class="nav-text">加锁步骤测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">7.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%8A%B6%E6%80%81"><span class="nav-number">8.1.</span> <span class="nav-text">读写锁状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%89%B9%E6%80%A7"><span class="nav-number">8.2.</span> <span class="nav-text">读写锁特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0-1"><span class="nav-number">8.3.</span> <span class="nav-text">主要应用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-rwlock-init%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.1.</span> <span class="nav-text">pthread_rwlock_init函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-rwlock-destroy%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.2.</span> <span class="nav-text">pthread_rwlock_destroy函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-rwlock-rdlock%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.3.</span> <span class="nav-text">pthread_rwlock_rdlock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-rwlock-wrlock%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.4.</span> <span class="nav-text">pthread_rwlock_wrlock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-rwlock-unlock%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.5.</span> <span class="nav-text">pthread_rwlock_unlock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-rwlock-tryrdlock%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.6.</span> <span class="nav-text">pthread_rwlock_tryrdlock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-rwlock-trywrlock%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.7.</span> <span class="nav-text">pthread_rwlock_trywrlock函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">8.4.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">9.</span> <span class="nav-text">条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0-2"><span class="nav-number">9.1.</span> <span class="nav-text">主要应用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-cond-init%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.1.</span> <span class="nav-text">pthread_cond_init函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-cond-destroy%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.2.</span> <span class="nav-text">pthread_cond_destroy函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-cond-wait%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.3.</span> <span class="nav-text">pthread_cond_wait函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-cond-timedwait%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.4.</span> <span class="nav-text">pthread_cond_timedwait函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-cond-signal%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.5.</span> <span class="nav-text">pthread_cond_signal函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-cond-broadcast%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.6.</span> <span class="nav-text">pthread_cond_broadcast函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">9.2.</span> <span class="nav-text">生产者消费者条件变量模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">9.3.</span> <span class="nav-text">条件变量的优点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">10.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0-3"><span class="nav-number">10.1.</span> <span class="nav-text">主要应用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sem-init%E5%87%BD%E6%95%B0"><span class="nav-number">10.1.1.</span> <span class="nav-text">sem_init函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sem-destroy%E5%87%BD%E6%95%B0"><span class="nav-number">10.1.2.</span> <span class="nav-text">sem_destroy函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sem-wait%E5%87%BD%E6%95%B0"><span class="nav-number">10.1.3.</span> <span class="nav-text">sem_wait函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sem-post%E5%87%BD%E6%95%B0"><span class="nav-number">10.1.4.</span> <span class="nav-text">sem_post函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sem-trywait%E5%87%BD%E6%95%B0"><span class="nav-number">10.1.5.</span> <span class="nav-text">sem_trywait函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sem-timedwait%E5%87%BD%E6%95%B0"><span class="nav-number">10.1.6.</span> <span class="nav-text">sem_timedwait函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">10.2.</span> <span class="nav-text">生产者消费者信号量模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5"><span class="nav-number">11.</span> <span class="nav-text">进程间同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8Fmutex-1"><span class="nav-number">11.1.</span> <span class="nav-text">互斥量mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0-4"><span class="nav-number">11.2.</span> <span class="nav-text">主要应用函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4mutex%E7%A4%BA%E4%BE%8B"><span class="nav-number">11.3.</span> <span class="nav-text">进程间mutex示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E9%94%81"><span class="nav-number">11.4.</span> <span class="nav-text">文件锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%96%87%E4%BB%B6%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">11.5.</span> <span class="nav-text">进程间文件锁示例</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">作者</p>
  <div class="site-description" itemprop="description">谈浩的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://huixing.org" title="http://huixing.org" rel="noopener" target="_blank">彗星网</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tanhao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://huixing-org.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://blog.huixing.org/linux-system-programming-thread-synchronization/";
    this.page.identifier = "linux-system-programming-thread-synchronization/";
    this.page.title = "Linux系统编程-线程同步";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://huixing-org.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
