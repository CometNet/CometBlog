<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referrer" content="no-referrer" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.huixing.org","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="c语言之所以强大，以及其自由性，很大部分体现在其灵活的指针运用上。因此，说指针是c语言的灵魂，一点都不为过。通过本文,向大家深入浅出指针.  概述指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。让我们分别说明。 例一:12345int *p;			&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言指针详解">
<meta property="og:url" content="http://blog.huixing.org/c-language-pointer-explanation/index.html">
<meta property="og:site_name" content="Haohao Notes">
<meta property="og:description" content="c语言之所以强大，以及其自由性，很大部分体现在其灵活的指针运用上。因此，说指针是c语言的灵魂，一点都不为过。通过本文,向大家深入浅出指针.  概述指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。让我们分别说明。 例一:12345int *p;			&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/a3eed545gy1g339jo8f1zj20zv2m119l.jpg">
<meta property="article:published_time" content="2019-05-10T01:53:00.000Z">
<meta property="article:modified_time" content="2019-10-16T06:26:48.000Z">
<meta property="article:author" content="Tan Hao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ww1.sinaimg.cn/large/a3eed545gy1g339jo8f1zj20zv2m119l.jpg">

<link rel="canonical" href="http://blog.huixing.org/c-language-pointer-explanation/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C语言指针详解 | Haohao Notes</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5202a7e94920d0c374589510b87a35e0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Haohao Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">DREAM OF TECHNICAL ACHIEVEMENT</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.huixing.org/c-language-pointer-explanation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="作者">
      <meta itemprop="description" content="谈浩的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haohao Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C语言指针详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-10 09:53:00" itemprop="dateCreated datePublished" datetime="2019-05-10T09:53:00+08:00">2019-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-16 14:26:48" itemprop="dateModified" datetime="2019-10-16T14:26:48+08:00">2019-10-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a>
                </span>
            </span>

          
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-copyright"></i>
    </span>
    <span class="post-meta-item-text">作者：</span><span>Tan Hao</span>
  </span>
  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/c-language-pointer-explanation/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="c-language-pointer-explanation/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>c语言之所以强大，以及其自由性，很大部分体现在其灵活的指针运用上。因此，说指针是c语言的灵魂，一点都不为过。通过本文,向大家深入浅出指针.</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。让我们分别说明。</p>
<p>例一:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int *p;			//指针的类型是int*	所指向的类型是int</span><br><span class="line">char *p;		//指针的类型是char*	所指向的的类型是char</span><br><span class="line">int **p;		//指针的类型是int**	所指向的的类型是int*</span><br><span class="line">int (*p)[3];	//指针的类型是int(*)[3]	所指向的的类型是int()[3]</span><br><span class="line">int *(*p)[4];	//指针的类型是int*(*)[4]	所指向的的类型是int*()[4]</span><br></pre></td></tr></table></figure></p>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。</p>
<h3 id="指针所指向的类型"><a href="#指针所指向的类型" class="headerlink" title="指针所指向的类型"></a>指针所指向的类型</h3><p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p>
<p>从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。</p>
<p>在指针的算术运算中，指针所指向的类型有很大的作用。</p>
<p>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。</p>
<p>当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一。</p>
<h3 id="指针所指向的内存区或地址"><a href="#指针所指向的内存区或地址" class="headerlink" title="指针所指向的内存区或地址"></a>指针所指向的内存区或地址</h3><p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。</p>
<p>在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。</p>
<p>指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为<code>sizeof</code>(指针所指向的类型)的一片内存区。</p>
<p>以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。</p>
<p>指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在上面代码中可以看出，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。</p>
<p><strong>以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？（重点注意）</strong></p>
<h3 id="指针本身所占据的内存区"><a href="#指针本身所占据的内存区" class="headerlink" title="指针本身所占据的内存区"></a>指针本身所占据的内存区</h3><p>指针本身占了多大的内存？</p>
<p>你只要用函数<code>sizeof</code>(指针的类型)测一下就知道了。</p>
<p>在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。</p>
<h2 id="运算符-amp-和"><a href="#运算符-amp-和" class="headerlink" title="运算符&amp;和*"></a>运算符&amp;和*</h2><p>这里&amp;是取地址运算符，*是间接运算符也可以叫做指针运算符。</p>
<p>&amp;a 的运算结果是一个指针，指针的类型是a 的类型加个*，指针所指向的类型是a 的类型，指针所指向的地址嘛，那就是a 的地址。</p>
<p>*p 的运算结果就五花八门了。总之*p 的结果是p 所指向的东西，这个东西有这些特点：它的类型是p 指向的类型，它所占用的地址是p所指向的地址。</p>
<p>例二:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a=12;</span><br><span class="line">int b;</span><br><span class="line">int *p;</span><br><span class="line">int **ptr;</span><br><span class="line"></span><br><span class="line">p=&amp;a; //&amp;a 的结果是一个指针，类型是int*，指向的类型是int，p指向的地址是a 的地址。</span><br><span class="line"></span><br><span class="line">*p=24; //*p 的结果，在这里它的类型是int，它所占用的地址是p 所指向的地址，显然，*p 就是变量a。</span><br><span class="line"></span><br><span class="line">ptr=&amp;p; //&amp;p 的结果是个指针，该指针的类型是p 的类型加个*，在这里是int **。该指针所指向的类型是p 的类型，这里是int*。该指针所指向的地址就是指针p 自己的地址。</span><br><span class="line"></span><br><span class="line">*ptr=&amp;b; //*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋值就是毫无问题的了。</span><br><span class="line"></span><br><span class="line">**ptr=34; //*ptr 的结果是ptr 所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果是一个int 类型的变量。</span><br></pre></td></tr></table></figure>
<h2 id="指针算术运算"><a href="#指针算术运算" class="headerlink" title="指针算术运算"></a>指针算术运算</h2><p>指针变量不能相加,不能相乘,不能相除.</p>
<p>指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。</p>
<p>举例来说,如果两个指针变量指向的是同一块连续空间中的不同存储单元,则这两个指正变量才可以相减.</p>
<p>例三:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a[10];			//定义一个a的字符串数组长度为10</span><br><span class="line">int *p=(int *)a; 	//强制类型转换并不会改变a 的类型</span><br><span class="line">p++;</span><br></pre></td></tr></table></figure>
<p>在上例中，指针p 的类型是int*,它指向的类型是int，它被初始化为指向整型变量a。</p>
<p>接下来的第3句中，指针p被加了1，编译器是这样处理的：它把指针p 的值加上了sizeof(int)，在32 位程序中，是被加上了4，因为在32 位程序中，int 占4 个字节。</p>
<p>由于地址是用字节做单位的，故p 所指向的地址由原来的变量a 的地址向高地址方向增加了4 个字节。由于char 类型的长度是一个字节，所以，原来p 是指向数组a 的第0 号单元开始的四个字节，此时指向了数组a 中从第4 号单元开始的四个字节。</p>
<p>我们可以用一个指针和一个循环来遍历一个数组.</p>
<p>例四:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int array[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">int *p = array;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;%d&quot;,*p);</span><br><span class="line">   (*p)++;</span><br><span class="line">   p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<code>0123456789</code></p>
<p>这个例子将整型数组中各个单元的值加1。由于每次循环都将指针p加1 个单元，所以每次循环都能访问数组的下一个单元。</p>
<p>例五:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a[20]=&quot;You_are_a_girl&quot;;</span><br><span class="line">int *p=(int *)a;</span><br><span class="line">p+=5;</span><br></pre></td></tr></table></figure>
<p>编译器是这样处理的：</p>
<p>将指针p 的值加上5 乘<code>sizeof(int)</code>，在32 位程序中就是加上了5 乘4=20。由于地址的单位是字节，故现在的p 所指向的地址比起加5 后的p 所指向的地址来说，向高地址方向移动了20 个字节。</p>
<p>在这个例子中，没加5 前的p 指向数组a 的第0 号单元开始的四个字节，加5 后，p 已经指向了数组a 的合法范围之外了。</p>
<p>虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。如果上例中，p 是被减去5，那么处理过程大同小异，只不过p 的值是被减去5 乘<code>sizeof(int)</code>，新的p 指向的地址将比原来的p 所指向的地址向低地址方向移动了20 个字节。</p>
<h2 id="指针表达式"><a href="#指针表达式" class="headerlink" title="指针表达式"></a>指针表达式</h2><p>一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。<br>下面是一些指针表达式的例子：</p>
<p>例六:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a,b;</span><br><span class="line">int array[10];</span><br><span class="line">int *pa;</span><br><span class="line">pa=&amp;a; //&amp;a 是一个指针表达式。</span><br><span class="line">Int **ptr=&amp;pa; //&amp;pa 也是一个指针表达式。</span><br><span class="line">*ptr=&amp;b; //*ptr 和&amp;b 都是指针表达式。</span><br><span class="line">pa=array;</span><br><span class="line">pa++; //这也是指针表达式。</span><br></pre></td></tr></table></figure></p>
<p>例七：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char *arr[20];</span><br><span class="line">char **parr=arr; //如果把arr 看作指针的话，arr 也是指针表达式</span><br><span class="line">char *str;</span><br><span class="line">str=*parr; //*parr 是指针表达式</span><br><span class="line">str=*(parr+1); //*(parr+1)是指针表达式</span><br><span class="line">str=*(parr+2); //*(parr+2)是指针表达式</span><br></pre></td></tr></table></figure><br>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。</p>
<p>好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，&amp;a 不是一个左值，因为它还没有占据明确的内存。<em>ptr 是一个左值，因为</em>ptr 这个指针已经占据了内存，其实<em>ptr 就是指针pa，既然pa 已经在内存中有了自己的位置，那么</em>ptr 当然也有了自己的位置。</p>
<h2 id="数组和指针的关系"><a href="#数组和指针的关系" class="headerlink" title="数组和指针的关系"></a>数组和指针的关系</h2><p>数组的数组名其实可以看作一个指针。看下例：<br>例八：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int array[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;,value;</span><br><span class="line">value=array[0]; //也可写成：value=*array;</span><br><span class="line">value=array[3]; //也可写成：value=*(array+3);</span><br><span class="line">value=array[4]; //也可写成：value=*(array+4);</span><br></pre></td></tr></table></figure></p>
<p>上例中，一般而言数组名array 代表数组本身，类型是int[10]，但如果把array 看做指针的话，它指向数组的第0 个单元，类型是int<em> 所指向的类型是数组单元的类型即int。因此</em>array 等于0 就一点也不奇怪了。同理，array+3 是一个指向数组第3 个单元的指针，所以*(array+3)等于3。其它依此类推。</p>
<p>例九：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char *str[3]=&#123;</span><br><span class="line">    &quot;Hello,thisisasample!&quot;,</span><br><span class="line">    &quot;Hi,goodmorning.&quot;,</span><br><span class="line">    &quot;Helloworld&quot;</span><br><span class="line">&#125;;</span><br><span class="line">char s[80]；</span><br><span class="line">strcpy(s,str[0]); //也可写成strcpy(s,*str);</span><br><span class="line">strcpy(s,str[1]); //也可写成strcpy(s,*(str+1));</span><br><span class="line">strcpy(s,str[2]); //也可写成strcpy(s,*(str+2));</span><br></pre></td></tr></table></figure></p>
<p>上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str 当作一个指针的话，它指向数组的第0 号单元，它的类型是char *<em>，它指向的类型是char </em>。</p>
<p><em>str 也是一个指针，它的类型是char </em>，它所指向的类型是char，它指向的地址是字符串”Hello,thisisasample!”的第一个字符的地址，即’H’的地址。注意:字符串相当于是一个数组,在内存中以数组的形式储存,只不过字符串是一个数组常量,内容不可改变,且只能是右值.如果看成指针的话,他即是常量指针,也是指针常量.</p>
<p>str+1 也是一个指针，它指向数组的第1 号单元，它的类型是char*<em>，它指向的类型是char</em>。<br><em>(str+1)也是一个指针，它的类型是char</em>，它所指向的类型是char，它指向”Hi,goodmorning.”的第一个字符’H’</p>
<p><strong>下面总结一下数组的数组名(数组中储存的也是数组)的问题:</strong></p>
<p>声明了一个数组TYPE array[n]，则数组名称array 就有了两重含义：<br>第一，它代表整个数组，它的类型是TYPE[n]；</p>
<p>第二，它是一个常量指针，该指针的类型是TYPE*，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0 号单元，该指针自己占有单独的内存区，注意它和数组第0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。在不同的表达式中数组名array 可以扮演不同的角色。在表达式sizeof(array)中，数组名array 代表数组本身，故这时sizeof 函数测出的是整个数组的大小。</p>
<p>在表达式<em>array 中，array 扮演的是指针，因此这个表达式的结果就是数组第0 号单元的值。sizeof(</em>array)测出的是数组单元的大小。</p>
<p>表达式array+n（其中n=0，1，2，…..）中，array 扮演的是指针，故array+n 的结果是一个指针，它的类型是TYPE *，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。在32 位程序中结果是4</p>
<p>例十:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int array[10];  </span><br><span class="line">int (*ptr)[10];  </span><br><span class="line">ptr=&amp;array;</span><br></pre></td></tr></table></figure></p>
<p>上例中ptr 是一个指针，它的类型是int(*)[10]，他指向的类型是int[10] ，我们用整个数组的首地址来初始化它。在语句ptr=&amp;array中，array 代表数组本身。<br>本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？<br>答案是前者。例如：</p>
<p><code>int(*ptr)[10];</code></p>
<p>则在32 位程序中，有：</p>
<p><code>sizeof(int(*)[10])==4</code><br><code>sizeof(int[10])==40</code><br><code>sizeof(ptr)==4</code></p>
<h2 id="指针和结构类型的关系"><a href="#指针和结构类型的关系" class="headerlink" title="指针和结构类型的关系"></a>指针和结构类型的关系</h2><p>可以声明一个指向结构类型对象的指针。</p>
<p>例十一:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct  </span><br><span class="line">&#123;  </span><br><span class="line">   int a;  </span><br><span class="line">   int b;  </span><br><span class="line">   int c;  </span><br><span class="line">&#125;;  </span><br><span class="line">struct MyStruct ss=&#123;20,30,40&#125;;  </span><br><span class="line">//声明了结构对象ss，并把ss 的成员初始化为20，30 和40。  </span><br><span class="line">struct MyStruct *ptr=&amp;ss;  </span><br><span class="line">//声明了一个指向结构对象ss 的指针。它的类型是  </span><br><span class="line">//MyStruct *,它指向的类型是MyStruct。  </span><br><span class="line">int *pstr=(int*)&amp;ss;  </span><br><span class="line">//声明了一个指向结构对象ss 的指针。但是pstr 和  </span><br><span class="line">//它被指向的类型ptr 是不同的</span><br></pre></td></tr></table></figure><br>请问怎样通过指针ptr 来访问ss 的三个成员变量？<br>答案：<br>ptr-&gt;a; //指向运算符，或者可以这们(*ptr).a,建议使用前者<br>ptr-&gt;b;<br>ptr-&gt;c;</p>
<p>又请问怎样通过指针pstr 来访问ss 的三个成员变量？<br>答案：<br><em>pstr； //访问了ss 的成员a。
</em>(pstr+1); //访问了ss 的成员b。<br>*(pstr+2) //访问了ss 的成员c。</p>
<p>例十二:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int array[3]=&#123;35,56,37&#125;;  </span><br><span class="line">int *pa=array;  </span><br><span class="line">//通过指针pa 访问数组array 的三个单元的方法是：  </span><br><span class="line">*pa; //访问了第0 号单元  </span><br><span class="line">*(pa+1); //访问了第1 号单元  </span><br><span class="line">*(pa+2); //访问了第2 号单元 </span><br></pre></td></tr></table></figure></p>
<p>从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。<br>所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个”填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。</p>
<p>所以，在例十二中，即使<em>pstr 访问到了结构对象ss 的第一个成员变量a，也不能保证</em>(pstr+1)就一定能访问到结构成员b。因为成员a 和成员b 之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。<br>不过指针访问结构成员的正确方法应该是象例十二中使用指针ptr 的方法。</p>
<h2 id="指针和函数的关系"><a href="#指针和函数的关系" class="headerlink" title="指针和函数的关系"></a>指针和函数的关系</h2><p>可以把一个指针声明成为一个指向函数的指针。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fun1(char *,int);</span><br><span class="line">int (*pfun1)(char *,int);</span><br><span class="line">pfun1=fun1;</span><br><span class="line">int a=(*pfun1)(&quot;abcdefg&quot;,7); //通过函数指针调用函数。</span><br></pre></td></tr></table></figure><br>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p>
<p>例十三:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int fun(char *);  </span><br><span class="line">inta;  </span><br><span class="line">char str[]=&quot;abcdefghijklmn&quot;;  </span><br><span class="line">a=fun(str);  </span><br><span class="line">int fun(char *s)  </span><br><span class="line">&#123;  </span><br><span class="line">   int num=0;  </span><br><span class="line">   for(int i=0;;)  </span><br><span class="line">   &#123;  </span><br><span class="line">      num+=*s;s++;  </span><br><span class="line">   &#125;  </span><br><span class="line">   return num;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中的函数fun 统计一个字符串中各个字符的ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s 后，实际是把str 的值传递给了s，s 所指向的地址就和str 所指向的地址一致，但是str 和s 各自占用各自的存储空间。在函数体内对s 进行自加1 运算，并不意味着同时对str 进行了自加1 运算。</p>
<h2 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h2><p>当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。</p>
<p>例十四：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f=12.3;  </span><br><span class="line">float *fptr=&amp;f;  </span><br><span class="line">int *p;</span><br></pre></td></tr></table></figure><br>在上面的例子中，假如我们想让指针p 指向实数f，应该怎么办？<br>是用下面的语句吗？<br><code>p=&amp;f;</code></p>
<p>不对。因为指针p 的类型是int <em>，它指向的类型是int。表达式&amp;f 的结果是一个指针，指针的类型是float </em>,它指向的类型是float。<br>两者不一致，直接赋值的方法是不行的。至少在我的MSVC++6.0 上，对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。为了实现我们的目的，需要进行”强制类型转换”：</p>
<p><code>p=(int*)&amp;f;</code></p>
<p>如果有一个指针p，我们需要把它的类型和所指向的类型改为TYEP *TYPE， 那么语法格式是：</p>
<p><code>(TYPE *)p；</code></p>
<p>这样强制类型转换的结果是一个新指针，该新指针的类型是TYPE *，它指向的类型是TYPE，它指向的地址就是原指针指向的地址。</p>
<p>而原来的指针p 的一切属性都没有被修改。（切记）</p>
<p>一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换</p>
<p>例十五：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void fun(char*);  </span><br><span class="line">int a=125,b;  </span><br><span class="line">fun((char*)&amp;a);  </span><br><span class="line">void fun(char*s)  </span><br><span class="line">&#123;  </span><br><span class="line">  char c;  </span><br><span class="line">  c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;  </span><br><span class="line">  c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>注意这是一个32 位程序，故int 类型占了四个字节，char 类型占一个字节。函数fun 的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？</p>
<p>在函数调用语句中，实参&amp;a 的结果是一个指针，它的类型是int <em>，它指向的类型是int。形参这个指针的类型是char </em>，它指向的类型是char。这样，在实参和形参的结合过程中，我们必须进行一次从int <em>类型到char </em>类型的转换。<br>结合这个例子，我们可以这样来<br>想象编译器进行转换的过程：编译器先构造一个临时指针char <em>temp，然后执行temp=(char </em>)&amp;a，最后再把temp 的值传递给s。所以最后的结果是：s 的类型是char *,它指向的类型是char，它指向的地址就是a 的首地址。</p>
<p>我们已经知道，指针的值就是指针指向的地址，在32 位程序中，指针的值其实是一个32 位整数。<br>那可不可以把一个整数当作指针的值直接赋给指针呢？就象下面的语句：</p>
<p>例十六:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unsigned int a;  </span><br><span class="line">TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。  </span><br><span class="line">a=20345686;  </span><br><span class="line">ptr=20345686; //我们的目的是要使指针ptr 指向地址20345686  </span><br><span class="line">      </span><br><span class="line">ptr=a; //我们的目的是要使指针ptr 指向地址20345686  </span><br><span class="line">//编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能达到了吗？不，还有办法：  </span><br><span class="line">unsigned int a;  </span><br><span class="line">TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。  </span><br><span class="line">a=N //N 必须代表一个合法的地址；  </span><br><span class="line">ptr=(TYPE*)a； //呵呵，这就可以了。</span><br></pre></td></tr></table></figure><br>严格说来这里的(TYPE <em>)和指针类型转换中的(TYPE </em>)还不一样。这里的(TYPE*)的意思是把无符号整数a 的值当作一个地址来看待。上面强调了a 的值必须代表一个合法的地址，否则的话，在你使用ptr 的时候，就会出现非法操作错误。想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：</p>
<p>例十七：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=123,b;  </span><br><span class="line">int *ptr=&amp;a;  </span><br><span class="line">char *str;  </span><br><span class="line">b=(int)ptr; //把指针ptr 的值当作一个整数取出来。  </span><br><span class="line">str=(char*)b; //把这个整数的值当作一个地址赋给指针str</span><br></pre></td></tr></table></figure>
<p>现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。</p>
<h2 id="指针的安全问题"><a href="#指针的安全问题" class="headerlink" title="指针的安全问题"></a>指针的安全问题</h2><p>例十八：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char s=&#x27;a&#x27;;  </span><br><span class="line">int *ptr;  </span><br><span class="line">ptr=(int *)&amp;s;  </span><br><span class="line">*ptr=1298；</span><br></pre></td></tr></table></figure><br>指针ptr 是一个int *类型的指针，它指向的类型是int。它指向的地址就是s 的首地址。在32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了s 所占的一个字节，还把和s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。<br>让我们再来看一例：</p>
<p>例十九：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char a;  </span><br><span class="line">int *ptr=&amp;a;  </span><br><span class="line">ptr++;  </span><br><span class="line">*ptr=115;</span><br></pre></td></tr></table></figure><br>该例子完全可以通过编译，并能执行。但是看到没有？第3 句对指针ptr 进行自加1 运算后，ptr 指向了和整形变量a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。</p>
<p>而第4 句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。</p>
<p>在指针的强制类型转换：<code>ptr1=(TYPE *)ptr2</code> 中，如果<code>sizeof(ptr2的类型)</code>大于<code>sizeof(ptr1 的类型)</code>，那么在使用指针ptr1 来访问ptr2所指向的存储区时是安全的。如果<code>sizeof(ptr2 的类型)</code> 小于<code>sizeof(ptr1 的类型)</code>，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。至于为什么，读者结合例十八来想一想，应该会明白的。</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://ww1.sinaimg.cn/large/a3eed545gy1g339jo8f1zj20zv2m119l.jpg" alt="指针图解"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/php-josn-decode-exception-handling/" rel="prev" title="json_decode 异常处理方法">
      <i class="fa fa-chevron-left"></i> json_decode 异常处理方法
    </a></div>
      <div class="post-nav-item">
    <a href="/operation-and-maintenance-notes/" rel="next" title="运维学习笔记">
      运维学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">指针类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">指针所指向的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E6%88%96%E5%9C%B0%E5%9D%80"><span class="nav-number">1.3.</span> <span class="nav-text">指针所指向的内存区或地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%9C%AC%E8%BA%AB%E6%89%80%E5%8D%A0%E6%8D%AE%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA"><span class="nav-number">1.4.</span> <span class="nav-text">指针本身所占据的内存区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-amp-%E5%92%8C"><span class="nav-number">2.</span> <span class="nav-text">运算符&amp;和*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="nav-number">3.</span> <span class="nav-text">指针算术运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">指针表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.</span> <span class="nav-text">数组和指针的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">6.</span> <span class="nav-text">指针和结构类型的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">7.</span> <span class="nav-text">指针和函数的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">8.</span> <span class="nav-text">指针类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">指针的安全问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3"><span class="nav-number">10.</span> <span class="nav-text">图解</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">作者</p>
  <div class="site-description" itemprop="description">谈浩的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://huixing.org" title="http://huixing.org" rel="noopener" target="_blank">彗星网</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tanhao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://huixing-org.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://blog.huixing.org/c-language-pointer-explanation/";
    this.page.identifier = "c-language-pointer-explanation/";
    this.page.title = "C语言指针详解";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://huixing-org.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
